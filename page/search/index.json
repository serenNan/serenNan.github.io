[{"content":"æˆ‘æ˜¯ç›´æ¥æŠŠè¿™äº›åŠ¨ç”»æ•ˆæœå…¨æ”¾ä¸€ä¸ªcssæ–‡ä»¶äº†\nåˆ›å»ºä¸€ä¸ªhover-animation.cssæ–‡ä»¶(å¯è‡ªå®šä¹‰)ï¼Œç„¶åè®°å¾—åœ¨assets/scss/style.scssä¸‹æ·»åŠ @import \u0026quot;hover-animation\u0026quot;; ç„¶ååœ¨åˆ›å»ºçš„cssæ–‡ä»¶æ·»åŠ ä»¥ä¸‹ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /* ä¸»é¡µåšå®¢å¡ç‰‡ */ .article-list article { transition: transform 0.6s ease; -webkit-font-smoothing: antialiased; will-change: transform; transform-origin: center; \u0026amp;:hover { transform: scale(1.02, 1.02); } } /* å·¦ä¾§æ é€‰é¡¹ */ #main-menu { overflow: visible; li { a { -webkit-font-smoothing: antialiased; will-change: transform; transition: transform 0.6s ease; \u0026amp;:hover { transform: scale(1.1, 1.1); will-change: transform; } } } } /* å½’æ¡£å’Œé“¾æ¥å¡ç‰‡ */ .article-list--compact { overflow: visible; } .article-list--compact article { transition: transform 0.6s ease; -webkit-font-smoothing: antialiased; will-change: transform; \u0026amp;:hover { transform: scale(1.05,1.05); z-index: 4; } } /* åˆ†ç±»é¡µé¢ */ .article-list--tile article { transition: 0.6s ease; } .article-list--tile article:hover { transform: scale(1.05, 1.05); will-change: transform; } /* å³ä¾§å¯¼èˆªæ  */ // æœç´¢ .search-form.widget { transition: transform 0.6s ease; } .search-form.widget:hover { transform: scale(1.1, 1.1); will-change: transform; -webkit-font-smoothing: antialiased; } //å½’æ¡£ .widget.archives .widget-archive--list { transition: transform .3s ease; will-change: transform; } .widget.archives .widget-archive--list:hover { transform: scale(1.05, 1.05); } // æ ‡ç­¾ .tagCloud .tagCloud-tags a { border-radius: 10px; font-size: 1.4rem; transition: transform .3s ease; } .tagCloud .tagCloud-tags a:hover { transform: scale(1.1, 1.1); will-change: transform; -webkit-font-smoothing: antialiased; } å‚æ•°ç®€å•ä»‹ç»:\n1 2 3 4 5 6 7 8 9 10 11 12 // åŠ¨ç”»æ—¶é—´ transition: 0.6s ease; // æ”¾å¤§ transform: scale(1.1, 1.1); // å…è®¸è¶…å‡ºè¾¹æ¡† overflow: visible; // è¿™ä¸ªæ˜¯ä¸ºäº†æ”¾å¤§åˆ«å‡ºç°å­—ä½“æŠ–åŠ¨ï¼ˆä½†å¥½åƒæ²¡ä»€ä¹ˆæ•ˆæœï¼‰ will-change: transform; -webkit-font-smoothing: antialiased; ","date":"2025-01-05T00:00:00Z","image":"https://example.com/post/hugo-animation/word.jpg","permalink":"https://example.com/post/hugo-animation/","title":"HugoåŠ¨ç”»"},{"content":"","date":"2025-01-05T00:00:00Z","permalink":"https://example.com/post/hugo-clock/","title":"Hugoæ—¶é’Ÿ"},{"content":"å­—ä½“ å­—ä½“æ–‡ä»¶æ”¾åœ¨assets/fontsä¸‹ï¼Œç„¶ååœ¨layouts/partials/footer/costom.html(æ²¡æœ‰å°±åˆ›å»º)ä¸­å¼•å…¥,æ ¼å¼å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MapleMono2\u0026#39;; src: url(\u0026#39;{{ (resources.Get \u0026#34;font/MapleMono2.ttf\u0026#34;).Permalink }}\u0026#39;) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;MapleMono2\u0026#39;; --code-font-family: \u0026#39;MapleMono2\u0026#39;; } \u0026lt;/style\u0026gt; æ³¨æ„: å­—ä½“æ–‡ä»¶è·¯å¾„srcè¦æœ‰åç¼€\nè‡ªå®šä¹‰åˆ†ç±»é¡µé¢æ ·å¼ æˆ‘ä¸å–œæ¬¢åŸæœ¬é»˜è®¤çš„å½’æ¡£é¡µé¢ï¼Œæƒ³æŠŠå½’æ¡£å’Œåˆ†ç±»åˆ†æˆä¸¤ä¸ªé¡µé¢ï¼Œå…·ä½“æ“ä½œå†™åœ¨äº†æˆ‘çš„Hugoé…ç½®åšå®¢Hugoé…ç½®(stackä¸»é¢˜)\nåç»­æƒ³æ·»åŠ å¯¹åº”çš„é¡µé¢æ ·å¼ï¼Œå°±åœ¨layoutsæ·»åŠ å¯¹åº”çš„htmlæ–‡ä»¶ï¼Œæ¯”å¦‚layouts/page/category.htmlï¼Œç„¶ååœ¨contents/page/category.mdä¸­æ·»åŠ layout: \u0026quot;category\u0026quot;ï¼Œè¿™æ ·å°±ä¼šä½¿ç”¨layouts/page/category.htmlçš„æ ·å¼äº†\nè¯„è®ºåŠŸèƒ½ è¿™é‡Œä½¿ç”¨çš„giscusé…ç½®\nå…ˆåœ¨github pageä¸Šæ‰“å¼€discussionåŠŸèƒ½ ç‚¹å‡»settingï¼Œå‘ä¸‹æ»‘æ‰¾åˆ°discussionï¼Œå‹¾é€‰discussion 2. ä¸‹è½½giscus\ngiscus app\né€‰æ‹©ä»“åº“åœ°å€ 3. é…ç½®hugo\nè¿›å…¥giscuså®˜ç½‘ giscus\næŒ‰ç…§æ­¥éª¤é…ç½®ï¼Œæœ€åå¤åˆ¶ä»£ç  äº”ä¸ªé‡è¦å‚æ•°ï¼š\ndata-repo data-repo-id data-category data-category-id data-mapping æ·»åŠ åˆ°é…ç½®æ–‡ä»¶ä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 comments: enabled: true provider: giscus giscus: repo: serenNan/serenNan.github.io repoID: category: Announcements categoryID: mapping: pathname lightTheme: light darkTheme: dark reactionsEnabled: 1 emitMetadata: 0 inputPosition: bottom lang: zh-CN åšå®¢èƒŒæ™¯ æˆ‘è¿™é‡Œç”¨çš„æ˜¯particlesåŠ¨æ€ç²’å­èƒŒæ™¯\né…ç½®ï¼š\\\nè¿›å…¥ç½‘ç«™è‡ªå®šä¹‰é…ç½®ï¼šparticles å”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯æœ‰ä¸ªé€‰é¡¹æ”¹æˆwindow é…ç½®å¥½åä¸‹è½½æ–‡ä»¶ å°†particles.min.js å’Œ particlesjs-config.jsonæ”¾åœ¨assets/backgroundæ–‡ä»¶å¤¹ä¸‹\nåœ¨layouts/partials/footer/custom.htmlä¸­æ·»åŠ ä»¥ä¸‹ä»£ç ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;div id=\u0026#34;particles-js\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{ (resources.Get \u0026#34;background/particles.min.js\u0026#34;).RelPermalink }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; particlesJS.load(\u0026#39;particles-js\u0026#39;, \u0026#39;{{ (resources.Get \u0026#34;background/particlesjs-config.json\u0026#34;).RelPermalink }}\u0026#39;, function() { console.log(\u0026#39;particles.js loaded - callback\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #particles-js { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; } \u0026lt;/style\u0026gt; ","date":"2025-01-02T00:00:00Z","image":"https://example.com/post/hugo-beautify/blog2.jpg","permalink":"https://example.com/post/hugo-beautify/","title":"Hugoç¾åŒ–\u0026ä¼˜åŒ–(stackä¸»é¢˜)"},{"content":"æ‹·è´æ„é€ å‡½æ•° å‚è€ƒæ–‡ç«  csdnï¼šC++æ‹·è´æ„é€ å‡½æ•°\næ¦‚è¿° æ‹·è´æ„é€ å‡½æ•°ï¼Œåˆç§°å¤åˆ¶æ„é€ å‡½æ•°ï¼Œæ˜¯ä¸€ç§ç‰¹æ®Šçš„æ„é€ å‡½æ•°ï¼Œå®ƒç”±ç¼–è¯‘å™¨è°ƒç”¨æ¥å®Œæˆä¸€äº›åŸºäºåŒä¸€ç±»çš„å…¶ä»–å¯¹è±¡çš„æ„é€ åŠåˆå§‹åŒ–ã€‚\nå…¶å”¯ä¸€çš„å½¢å‚å¿…é¡»æ˜¯å¼•ç”¨ï¼Œä½†å¹¶ä¸é™åˆ¶ä¸ºconstï¼Œä¸€èˆ¬æ™®éçš„ä¼šåŠ ä¸Šconsté™åˆ¶ã€‚\nè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°çš„æƒ…å½¢ ä¸€ä¸ªå¯¹è±¡ä½œä¸ºå‡½æ•°å‚æ•°ï¼Œä»¥å€¼ä¼ é€’çš„æ–¹å¼ä¼ å…¥å‡½æ•°ä½“ï¼ˆå‡½æ•°ä¼ å‚ï¼Œç±»ç±»å‹çš„å€¼ä¼ é€’ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 class Complex { }; void Fun(Complex c1) { } int main() { Complex c1(1,2); Fun(c1); // è¿™é‡Œå°±è°ƒç”¨äº†é»˜è®¤çš„æ‹·è´æ„é€ å‡½æ•° } ä¸€ä¸ªå¯¹è±¡ä½œä¸ºå‡½æ•°è¿”å›å€¼ï¼Œä»¥å€¼ä¼ é€’çš„æ–¹å¼ä»å‡½æ•°è¿”å›;ï¼ˆå‡½æ•°çš„è¿”å›ç±»å‹æ˜¯ç±»ï¼Œä»å±€éƒ¨å¯¹è±¡åˆ°ä¸´æ—¶å¯¹è±¡çš„æ‹·è´æ„é€ ï¼‰ 1 2 3 4 5 Complex Fun() { Complex c(10,20); return c; // è¿™é‡Œä¼šè°ƒç”¨ } ä¸€ä¸ªå¯¹è±¡ç”¨äºç»™å¦å¤–ä¸€ä¸ªå¯¹è±¡è¿›è¡Œåˆå§‹åŒ–(å¸¸ç§°ä¸ºèµ‹å€¼åˆå§‹åŒ–);ï¼ˆç”¨å·²æœ‰å¯¹è±¡å»åˆå§‹åŒ–æœ¬ç±»çš„å…¶ä»–å¯¹è±¡ï¼‰ 1 2 3 4 5 6 int main() { Complex c1(1,2); Complex c2(c1); // æ­¤å¤„ Complex c3=c1; // æ­¤å¤„ } æµ…æ‹·è´ä¸æ·±æ‹·è´ å½“å¯¹è±¡çš„æˆå‘˜å˜é‡ä¸­å­˜åœ¨æŒ‡é’ˆå˜é‡æ—¶ï¼Œç”¨å­˜åœ¨çš„å¯¹è±¡åˆå§‹åŒ–æ–°å»ºå¯¹è±¡æ—¶æŒ‡é’ˆå˜é‡ä¸€åŒåˆå§‹åŒ–ï¼Œä½†è¿™æ—¶è°ƒç”¨ä¸€èˆ¬æ‹·è´æ„é€ å‡½æ•°ï¼ˆæµ…æ‹·è´ï¼‰ä¼šä½¿æ–°å¯¹è±¡ä¸­çš„æŒ‡é’ˆæŒ‡å‘å’Œåˆå§‹åŒ–å¯¹è±¡æŒ‡é’ˆæŒ‡å‘ä¸€è‡´ï¼Œé‚£ä¹ˆå½“ç”¨æ¥åˆå§‹åŒ–çš„å¯¹è±¡åœ¨é‡Šæ”¾å†…å­˜æ—¶ä¼šé‡Šæ”¾æ‰æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜ï¼Œè€Œå½“æ–°åˆ›å»ºçš„å¯¹è±¡é‡Šæ”¾æ—¶ä¼šå‡ºç°ç¨‹åºé”™è¯¯ï¼Œä»¥ä¸ºè¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å†…å­˜è¢«é‡Šæ”¾äº†ä¸¤æ¬¡ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨æä¾›å¦ä¸€ç§æ‹·è´æ„é€ å‡½æ•°ï¼ˆæ·±æ‹·è´ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyClass { public: int* data; MyClass(int d) { data = new int(d); // åŠ¨æ€åˆ†é…å†…å­˜ } ~MyClass() { delete data; // é‡Šæ”¾å†…å­˜ } MyClass(const MyClass\u0026amp; other) { data = new int(*other.data); // æ·±æ‹·è´ï¼šåˆ†é…æ–°å†…å­˜å¹¶å¤åˆ¶å†…å®¹ } }; int main() { MyClass original(10); MyClass copy(original); // è°ƒç”¨æ·±æ‹·è´æ„é€ å‡½æ•° return 0; } è™šææ„å‡½æ•° æ€»çš„æ¥è¯´è™šææ„å‡½æ•°æ˜¯ä¸ºäº†é¿å…å†…å­˜æ³„éœ²ï¼Œè€Œä¸”æ˜¯å½“å­ç±»ä¸­ä¼šæœ‰æŒ‡é’ˆæˆå‘˜å˜é‡æ—¶æ‰ä¼šä½¿ç”¨å¾—åˆ°çš„ã€‚ä¹Ÿå°±è¯´è™šææ„å‡½æ•°ä½¿å¾—åœ¨åˆ é™¤æŒ‡å‘å­ç±»å¯¹è±¡çš„åŸºç±»æŒ‡é’ˆæ—¶å¯ä»¥è°ƒç”¨å­ç±»çš„ææ„å‡½æ•°è¾¾åˆ°é‡Šæ”¾å­ç±»ä¸­å †å†…å­˜çš„ç›®çš„ï¼Œè€Œé˜²æ­¢å†…å­˜æ³„éœ²çš„.\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; class Fish { public: Fish() { cout \u0026lt;\u0026lt; \u0026#34;Constructed Fish\u0026#34; \u0026lt;\u0026lt; endl; } // å¦‚æœè¿™é‡Œä¸æ˜¯è™šææ„å‡½æ•°ï¼Œé‚£ä¹ˆdelete pFishæ—¶åªä¼šè°ƒç”¨åŸºç±»çš„ææ„å‡½æ•°ï¼Œè€Œä¸ä¼šè°ƒç”¨å­ç±»çš„ææ„å‡½æ•° virtual ~Fish() // virtual destructor! { cout \u0026lt;\u0026lt; \u0026#34;Destroyed Fish\u0026#34; \u0026lt;\u0026lt; endl; } }; class Tuna : public Fish { public: Tuna() { cout \u0026lt;\u0026lt; \u0026#34;Constructed Tuna\u0026#34; \u0026lt;\u0026lt; endl; } ~Tuna() { cout \u0026lt;\u0026lt; \u0026#34;Destroyed Tuna\u0026#34; \u0026lt;\u0026lt; endl; } }; void DeleteFishMemory(Fish *pFish) { delete pFish; } int main() { cout \u0026lt;\u0026lt; \u0026#34;Allocating a Tuna on the free store:\u0026#34; \u0026lt;\u0026lt; endl; Tuna *pTuna = new Tuna; cout \u0026lt;\u0026lt; \u0026#34;Deleting the Tuna: \u0026#34; \u0026lt;\u0026lt; endl; DeleteFishMemory(pTuna); cout \u0026lt;\u0026lt; \u0026#34;Instantiating a Tuna on the stack:\u0026#34; \u0026lt;\u0026lt; endl; Tuna myDinner; cout \u0026lt;\u0026lt; \u0026#34;Automatic destruction as it goes out of scope: \u0026#34; \u0026lt;\u0026lt; endl; return 0; } å¸¸é‡æˆå‘˜å‡½æ•° å¸¸é‡å¯¹è±¡å’Œéå¸¸é‡å¯¹è±¡ ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; class MyClass { private: int x; public: MyClass(int n) { x = n; } void setX(int n) // éå¸¸é‡æˆå‘˜å‡½æ•° { x = n; } int getX() const // å¸¸é‡æˆå‘˜å‡½æ•° { return x; } }; int main() { MyClass obj1(10); // éå¸¸é‡å¯¹è±¡ const MyClass obj2(20); // å¸¸é‡å¯¹è±¡ obj1.setX(30); // å¯ä»¥ä¿®æ”¹obj1çš„æ•°æ®æˆå‘˜ cout \u0026lt;\u0026lt; \u0026#34;obj1.x = \u0026#34; \u0026lt;\u0026lt; obj1.getX() \u0026lt;\u0026lt; endl; // obj1.x = 30 // obj2.setX(40); // ç¼–è¯‘é”™è¯¯ï¼Œä¸èƒ½ä¿®æ”¹obj2çš„æ•°æ®æˆå‘˜ï¼ˆå¸¸é‡å¯¹è±¡ä¸èƒ½è°ƒç”¨éå¸¸é‡æˆå‘˜å‡½æ•°ï¼‰ cout \u0026lt;\u0026lt; \u0026#34;obj2.x = \u0026#34; \u0026lt;\u0026lt; obj2.getX() \u0026lt;\u0026lt; endl; // obj1.x = 20 return 0; } å¸¸é‡æˆå‘˜å‡½æ•° å¸¸é‡æˆå‘˜å‡½æ•°çš„ç‰¹ç‚¹ å¸¸é‡æˆå‘˜å‡½æ•°ä¸ä¼šä¿®æ”¹ç±»çš„æˆå‘˜å‡½æ•°ï¼Œå³å®ƒä»¬æ˜¯åªè¯»çš„ã€‚å› æ­¤ï¼Œå¸¸é‡æˆå‘˜å‡½æ•°ä¸èƒ½ä¿®æ”¹ç±»çš„æ•°æ®æˆå‘˜ï¼Œä¹Ÿä¸èƒ½è°ƒç”¨éå¸¸é‡æˆå‘˜å‡½æ•°,å› ä¸ºéå¸¸é‡æˆå‘˜å‡½æ•°å¯èƒ½ä¼šä¿®æ”¹ç±»çš„æ•°æ®æˆå‘˜ã€‚ å¸¸é‡æˆå‘˜å‡½æ•°å¯ä»¥è¢«å¸¸é‡å¯¹è±¡å’Œéå¸¸é‡å¯¹è±¡è°ƒç”¨ã€‚å¦‚æœä¸€ä¸ªå¯¹è±¡æ˜¯å¸¸é‡å¯¹è±¡ï¼Œåˆ™åªèƒ½è°ƒç”¨è¯¥å¯¹è±¡çš„å¸¸é‡æˆå‘˜å‡½æ•°ï¼Œè€Œä¸èƒ½è°ƒç”¨éå¸¸é‡æˆå‘˜å‡½æ•°ã€‚ å¸¸é‡æˆå‘˜å‡½æ•°å¯ä»¥è®¿é—®ç±»çš„æ‰€æœ‰æˆå‘˜å˜é‡å’Œå¸¸é‡æˆå‘˜å‡½æ•°ã€‚ å¸¸é‡æˆå‘˜å‡½æ•°çš„ä½œç”¨æ˜¯ä¿è¯ç±»çš„æ•°æ®æˆå‘˜ä¸è¢«ä¿®æ”¹ï¼Œä»è€Œæé«˜ç¨‹åºçš„å®‰å…¨æ€§å’Œå¯é æ€§ã€‚ å¸¸é‡æˆå‘˜å‡½æ•°é€šå¸¸ç”¨äºè®¿é—®ç±»çš„æ•°æ®æˆå‘˜ï¼Œè€Œä¸æ˜¯ä¿®æ”¹å®ƒä»¬ã€‚ ä¾‹å¦‚ï¼šå¯ä»¥ä½¿ç”¨å¸¸é‡æˆå‘˜å‡½æ•°æ¥å®ç°ç±»çš„æ•°æ®æˆå‘˜çš„è¯»å–æ“ä½œï¼Œè€Œä½¿ç”¨éå¸¸é‡æˆå‘˜å‡½æ•°æ¥å®ç°ç±»çš„æ•°æ®æˆå‘˜çš„å†™å…¥æ“ä½œã€‚\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { private: string name; int age; public: Person(string n, int a) { name = n; age = a; } string getName() const { return name; } int getAge() const { return age; } void show() const { cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;, Age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } }; int main() { Person p(\u0026#34;Alice\u0026#34;, 20); p.show(); return 0; } å·¦å€¼å’Œå³å€¼ å‚è€ƒæ–‡ç«  csdnï¼šC++ å·¦å€¼å’Œå³å€¼\nå·¦å€¼å’Œå³å€¼çš„å®šä¹‰ å·¦å€¼ï¼ˆloactor valueï¼‰:å­˜å‚¨åœ¨å†…å­˜ä¸­ã€å¯å¯»å€çš„æ•°æ®\nå³å€¼ï¼ˆread valueï¼‰:å¯ä»¥æä¾›æ•°æ®å€¼çš„æ•°æ®ï¼ˆä¸ä¸€å®šå¯å¯»å€ï¼Œä¾‹å¦‚å­˜å‚¨åœ¨å¯„å­˜å™¨ä¸­çš„æ•°æ®ï¼‰\nå³å€¼å¼•ç”¨ å·¦å€¼å¼•ç”¨æ— æ³•å¼•ç”¨å³å€¼ï¼› å¸¸é‡å·¦å€¼å¼•ç”¨å¯ä»¥æ“ä½œå³å€¼ï¼Œä½†æ˜¯æ— æ³•å¯¹å³å€¼è¿›è¡Œä¿®æ”¹ï¼› å³å€¼å¼•ç”¨å¯ä»¥å¯¹å³å€¼è¿›è¡Œä¿®æ”¹ï¼› å¸¸é‡å³å€¼å¼•ç”¨ï¼šå¼•ç”¨ä¸€ä¸ªå³å€¼ï¼Œå¹¶ä¸”ä¸å¯æ›´æ”¹ã€‚å¯ä»¥å¸¸é‡å·¦å€¼å¼•ç”¨ä»£æ›¿ã€‚ 1 2 3 4 5 6 7 int a = 10; int \u0026amp;b = a; // å·¦å€¼å¼•ç”¨ // int \u0026amp;c = 10; // é”™è¯¯ï¼Œå·¦å€¼å¼•ç”¨æ— æ³•æ“ä½œå³å€¼ b = 20; const int \u0026amp;d = 10; // å¸¸é‡å·¦å€¼å¼•ç”¨å¯ä»¥æ“ä½œå³å€¼ int \u0026amp;\u0026amp;e = 20; // å³å€¼å¼•ç”¨ e = 25; // ä¿®æ”¹å³å€¼ å› æ­¤c++11ä¸­å¼•å…¥å³å€¼å¼•ç”¨\u0026amp;\u0026amp;ã€‚\nå³å€¼å¼•ç”¨ä½¿ç”¨åœºæ™¯ æ‹·è´æ„é€ å‡½æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; class demo { public: // æ„é€ å‡½æ•° demo() : num(new int(0)) { cout \u0026lt;\u0026lt; \u0026#34;construct!\u0026#34; \u0026lt;\u0026lt; endl; } // æ‹·è´æ„é€ å‡½æ•°ï¼ˆæ·±æ‹·è´ï¼‰ demo(const demo \u0026amp;d) : num(new int(*d.num)) { cout \u0026lt;\u0026lt; \u0026#34;copy construct!\u0026#34; \u0026lt;\u0026lt; endl; } ~demo() { cout \u0026lt;\u0026lt; \u0026#34;class destruct!\u0026#34; \u0026lt;\u0026lt; endl; } private: int *num; }; demo get_demo() { return demo(); // è¿”å›ä¸€ä¸ªdemoå¯¹è±¡ï¼Œæ˜¯ä¸€ä¸ªå³å€¼ } int main() { demo a (get_demo()); // æ‹·è´æ„é€  return 0; } è¾“å‡ºï¼š\nconstruct! copy construct! copy construct! class destruct! class destruct! æœ‰äº›ç¼–è¯‘å™¨å¯èƒ½ä¼šä¼˜åŒ–ï¼Œåªè¾“å‡ºä¸€æ¬¡æ‹·è´æ„é€ å‡½æ•°ã€‚\nå¦‚ä¸Šæ‰€ç¤ºï¼Œdemo ç±»è‡ªå®šä¹‰äº†ä¸€ä¸ªæ‹·è´æ„é€ å‡½æ•°ã€‚è¯¥å‡½æ•°åœ¨æ‹·è´ d.num æŒ‡é’ˆæˆå‘˜æ—¶ï¼Œå¿…é¡»é‡‡ç”¨æ·±æ‹·è´çš„æ–¹å¼ï¼Œå³æ‹·è´è¯¥æŒ‡é’ˆæˆå‘˜æœ¬èº«çš„åŒæ—¶ï¼Œè¿˜è¦æ‹·è´æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜èµ„æºã€‚å¦åˆ™ä¸€æ—¦å¤šä¸ªå¯¹è±¡ä¸­çš„æŒ‡é’ˆæˆå‘˜æŒ‡å‘åŒä¸€å—å †ç©ºé—´ï¼Œè¿™äº›å¯¹è±¡ææ„æ—¶å°±ä¼šå¯¹è¯¥ç©ºé—´é‡Šæ”¾å¤šæ¬¡ï¼Œè¿™æ˜¯ä¸å…è®¸çš„ã€‚\ndemo a (get_demo()) çš„æµç¨‹ï¼š\næ‰§è¡Œ get_demo() å‡½æ•°ï¼Œdemo()è°ƒç”¨æ„é€ å‡½æ•°ç”Ÿæˆä¸€ä¸ªåŒ¿åå¯¹è±¡ æ‰§è¡Œ return demo() ï¼Œè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°æ‹·è´åŒ¿åå¯¹è±¡ï¼Œä½œä¸ºå‡½æ•°get_demo()çš„è¿”å›å€¼ï¼ˆget_demo()æ‰§è¡Œå®Œæ¯•ï¼ŒåŒ¿åå¯¹è±¡ä¼šè¢«é”€æ¯ï¼‰ æ‰§è¡Œ a(get_demo()), è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°(æ­¤è¡Œä»£ç æ‰§è¡Œå®Œæ¯•ï¼Œget_demo()çš„è¿”å›å€¼ä¼šè¢«ææ„) ç¨‹åºç»“æŸå‰ï¼Œaè¢«ææ„ã€‚ åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œåº•å±‚æ‰§è¡Œäº†2æ¬¡æ·±æ‹·è´ã€‚å¦‚æœæŒ‡é’ˆæŒ‡å‘çš„å †ç©ºé—´è¾ƒå¤§ï¼Œä¼šå¤§å¤§é™ä½æ‰§è¡Œçš„æ•ˆç‡ã€‚é€šè¿‡ç§»åŠ¨æ„é€ å‡½æ•°å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚\nä½•æ—¶è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ï¼Ÿï¼ˆè¯¦è§ï¼šæ‹·è´æ„é€ å‡½æ•°ï¼‰\nç§»åŠ¨æ„é€ å‡½æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; class demo { public: // æ„é€ å‡½æ•° demo() : num(new int(0)) { cout \u0026lt;\u0026lt; \u0026#34;construct!\u0026#34; \u0026lt;\u0026lt; endl; } // æ‹·è´æ„é€ å‡½æ•°ï¼ˆæ·±æ‹·è´ï¼‰ demo(const demo \u0026amp;d) : num(new int(*d.num)) { cout \u0026lt;\u0026lt; \u0026#34;copy construct!\u0026#34; \u0026lt;\u0026lt; endl; } // ç§»åŠ¨æ„é€ å‡½æ•° demo(demo \u0026amp;\u0026amp;d) : num(d.num) { d.num = nullptr; cout \u0026lt;\u0026lt; \u0026#34;move construct!\u0026#34; \u0026lt;\u0026lt; endl; } ~demo() { cout \u0026lt;\u0026lt; \u0026#34;class destruct!\u0026#34; \u0026lt;\u0026lt; endl; } private: int *num; }; demo get_demo() { demo temp; // åˆ›å»ºä¸€ä¸ªå±€éƒ¨å¯¹è±¡ return temp; // è¿”å›å±€éƒ¨å¯¹è±¡ } int main() { demo a(get_demo()); // è°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•° return 0; } è¾“å‡ºï¼š\nconstruct! move construct! class destruct! class destruct! ä½¿ç”¨å³å€¼å¼•ç”¨ç±»å‹çš„å‚æ•°ï¼ŒæŒ‡é’ˆæµ…æ‹·è´ï¼Œå³å€¼å¯¹è±¡æŒ‡é’ˆç½®ä¸ºnullptr, ä»è€Œï¼Œé¿å…æ‹·è´å †ç©ºé—´ï¼Œå®Œæˆåˆå§‹åŒ–ã€‚\nå½“ç±»ä¸­åŒæ—¶åŒ…å«æ‹·è´æ„é€ å‡½æ•°å’Œç§»åŠ¨æ„é€ å‡½æ•°æ—¶ï¼Œå¦‚æœä½¿ç”¨ä¸´æ—¶å¯¹è±¡åˆå§‹åŒ–å½“å‰ç±»çš„å¯¹è±¡ï¼Œç¼–è¯‘å™¨ä¼šä¼˜å…ˆè°ƒç”¨ç§»åŠ¨æ„é€ å‡½æ•°æ¥å®Œæˆæ­¤æ“ä½œã€‚åªæœ‰å½“ç±»ä¸­æ²¡æœ‰åˆé€‚çš„ç§»åŠ¨æ„é€ å‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨æ‰ä¼šé€€è€Œæ±‚å…¶æ¬¡ï¼Œè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ã€‚\nstd::move()å¯ä»¥å°†å·¦å€¼è½¬æ¢ä¸ºå³å€¼ï¼Œä»è€Œä½¿ç”¨ç§»åŠ¨æ„é€ ã€‚\n1 2 3 4 5 demo get_demo() { demo temp; // åˆ›å»ºä¸€ä¸ªå±€éƒ¨å¯¹è±¡ return std::move(temp); // ä½¿ç”¨ std::move è§¦å‘ç§»åŠ¨æ„é€ å‡½æ•° } è¾“å‡ºæ˜¯ä¸€æ ·çš„\nmoveå‡½æ•° å‚è€ƒæ–‡ç«  csdnï¼šC++11ä¸­çš„moveå‡½æ•°\næ™ºèƒ½æŒ‡é’ˆ å‚è€ƒæ–‡ç«  csdnï¼šC++æ™ºèƒ½æŒ‡é’ˆ\næ™ºèƒ½æŒ‡é’ˆæ¦‚è¿° æ˜¯åŸå§‹æŒ‡é’ˆçš„å°è£…ï¼Œä¼šè‡ªåŠ¨åˆ†é…å†…å­˜ï¼Œä¸éœ€è¦æ‹…å¿ƒæ½œåœ¨çš„å†…å­˜æ³„éœ²ã€‚\nä¸ºä»€ä¹ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ ä¸€å¥è¯å¸¦è¿‡ï¼šæ™ºèƒ½æŒ‡é’ˆå°±æ˜¯å¸®æˆ‘ä»¬C++ç¨‹åºå‘˜ç®¡ç†åŠ¨æ€åˆ†é…çš„å†…å­˜çš„ï¼Œå®ƒä¼šå¸®åŠ©æˆ‘ä»¬è‡ªåŠ¨é‡Šæ”¾newå‡ºæ¥çš„å†…å­˜ï¼Œä»è€Œé¿å…å†…å­˜æ³„æ¼ã€‚\nä¸‹é¢çš„å†…å­˜æ³„éœ²çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; // åŠ¨æ€åˆ†é…å†…å­˜ï¼Œæ²¡æœ‰é‡Šæ”¾å°±return void memoryLeak1() { string *str = new string(\u0026#34;åŠ¨æ€åˆ†é…å†…å­˜ï¼\u0026#34;); return; } // åŠ¨æ€åˆ†é…å†…å­˜ï¼Œè™½ç„¶æœ‰äº›é‡Šæ”¾å†…å­˜çš„ä»£ç ï¼Œä½†æ˜¯è¢«åŠè·¯æˆªèƒ¡returnäº† int memoryLeak2() { string *str = new string(\u0026#34;å†…å­˜æ³„éœ²ï¼\u0026#34;); // ...æ­¤å¤„çœç•¥ä¸€ä¸‡è¡Œä»£ç  // å‘ç”ŸæŸäº›å¼‚å¸¸ï¼Œéœ€è¦ç»“æŸå‡½æ•° if (1) { return -1; } / // å¦å¤–ï¼Œä½¿ç”¨tryã€catchç»“æŸå‡½æ•°ï¼Œä¹Ÿä¼šé€ æˆå†…å­˜æ³„æ¼ï¼ / delete str;\t// è™½ç„¶å†™äº†é‡Šæ”¾å†…å­˜çš„ä»£ç ï¼Œä½†æ˜¯é­åˆ°å‡½æ•°ä¸­æ®µè¿”å›ï¼Œä½¿å¾—æŒ‡é’ˆæ²¡æœ‰å¾—åˆ°é‡Šæ”¾ return 1; } int main(void) { memoryLeak1(); memoryLeak2(); return 0; } memoryLeak1å‡½æ•°ä¸­ï¼Œnewäº†ä¸€ä¸ªå­—ç¬¦ä¸²æŒ‡é’ˆï¼Œä½†æ˜¯æ²¡æœ‰deleteå°±å·²ç»returnç»“æŸå‡½æ•°äº†ï¼Œå¯¼è‡´å†…å­˜æ²¡æœ‰è¢«é‡Šæ”¾ï¼Œå†…å­˜æ³„éœ²ï¼ memoryLeak2å‡½æ•°ä¸­ï¼Œnewäº†ä¸€ä¸ªå­—ç¬¦ä¸²æŒ‡é’ˆï¼Œè™½ç„¶åœ¨å‡½æ•°æœ«å°¾æœ‰äº›é‡Šæ”¾å†…å­˜çš„ä»£ç delete strï¼Œä½†æ˜¯åœ¨deleteä¹‹å‰å°±å·²ç»returnäº†ï¼Œæ‰€ä»¥å†…å­˜ä¹Ÿæ²¡æœ‰è¢«é‡Šæ”¾ï¼Œå†…å­˜æ³„éœ²ï¼\nä½¿ç”¨æŒ‡é’ˆï¼Œæˆ‘ä»¬æ²¡æœ‰é‡Šæ”¾ï¼Œå°±ä¼šé€ æˆå†…å­˜æ³„éœ²ã€‚ä½†æ˜¯æˆ‘ä»¬ä½¿ç”¨æ™®é€šå¯¹è±¡å´ä¸ä¼šã€‚\nè€Œæ™ºèƒ½æŒ‡é’ˆæœ¬è´¨æ˜¯å¯¹ä¸€ä¸ªæ™®é€šæŒ‡é’ˆçš„å°è£…ï¼Œåˆ©ç”¨æœ‰ç”Ÿå‘½å‘¨æœŸçš„å¯¹è±¡è‡ªåŠ¨é‡Šæ”¾çš„ç‰¹æ€§ï¼Œæ¥å®ç°å†…å­˜çš„è‡ªåŠ¨ç®¡ç†ã€‚\nauto_ptr auto_ptr æ˜¯c++ 98å®šä¹‰çš„æ™ºèƒ½æŒ‡é’ˆæ¨¡æ¿ï¼Œå…¶å®šä¹‰äº†ç®¡ç†æŒ‡é’ˆçš„å¯¹è±¡ï¼Œå¯ä»¥å°†newè·å¾—ï¼ˆç›´æ¥æˆ–é—´æ¥ï¼‰çš„åœ°å€èµ‹ç»™è¿™ç§å¯¹è±¡ã€‚å½“å¯¹è±¡è¿‡æœŸæ—¶ï¼Œå…¶ææ„å‡½æ•°å°†ä½¿ç”¨deleteæ¥é‡Šæ”¾å†…å­˜ï¼\nç”¨æ³•ï¼š å¤´æ–‡ä»¶ï¼š#include \u0026lt;memory\u0026gt; ç”¨æ³•ï¼š auto_ptr\u0026lt;ç±»å‹\u0026gt; å˜é‡å(new ç±»å‹)\nä¾‹å¦‚ï¼š\n1 2 3 auto_ptr\u0026lt; string \u0026gt; str(new string(â€œæˆ‘è¦æˆä¸ºå¤§ç‰›~ å˜å¾—å¾ˆç‰›é€¼ï¼â€)); auto_ptr\u0026lt;vector\u0026lt; int \u0026gt;\u0026gt; av(new vector\u0026lt; int \u0026gt;()); auto_ptr\u0026lt; int \u0026gt; array(new int[10]); ä¸‹é¢çš„ä»£ç ä½¿ç”¨newåˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œä½†æ˜¯ä¸ä½¿ç”¨deleteï¼Œå°±ä¼šå‘ç”Ÿå†…å­˜æ³„éœ²ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026#34;iostream\u0026#34; using namespace std; class Test { public: Test() { cout \u0026lt;\u0026lt; \u0026#34;Testçš„æ„é€ å‡½æ•°...\u0026#34; \u0026lt;\u0026lt; endl; } ~Test() { cout \u0026lt;\u0026lt; \u0026#34;Testçš„ææ„å‡½æ•°...\u0026#34; \u0026lt;\u0026lt; endl; } int getDebug() { return this-\u0026gt;debug; } private: int debug = 20; }; int main(void) { Test *test = new Test; cout \u0026lt;\u0026lt; test-\u0026gt;getDebug() \u0026lt;\u0026lt; endl; // delete test; return 0; } è¾“å‡ºï¼š\nTestçš„æ„é€ å‡½æ•°... è¦é‡Šæ”¾å†…å­˜ï¼Œå°±å¾—æ‰‹åŠ¨deleteï¼Œæˆ–è€…ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ\nä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 int main(void) { // Test *test = new Test; auto_ptr\u0026lt;Test\u0026gt; test(new Test); cout \u0026lt;\u0026lt; \u0026#34;test-\u0026gt;debugï¼š\u0026#34; \u0026lt;\u0026lt; test-\u0026gt;getDebug() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;(*test).debugï¼š\u0026#34; \u0026lt;\u0026lt; (*test).getDebug() \u0026lt;\u0026lt; endl; return 0; } è¾“å‡ºï¼š\nTestçš„æ„é€ å‡½æ•°... test-\u0026gt;debugï¼š20 (*test).debugï¼š20 Testçš„ææ„å‡½æ•°... æ™ºèƒ½æŒ‡é’ˆå¯ä»¥åƒæ™®é€šæŒ‡é’ˆä¸€æ ·ä½¿ç”¨ï¼Œå¹¶ä¸”ä¼šè‡ªåŠ¨é‡Šæ”¾å†…å­˜\næ™ºèƒ½æŒ‡é’ˆæœ‰ä¸‰ä¸ªå¸¸ç”¨å‡½æ•°ï¼š\nget()ï¼šè·å–æ™ºèƒ½æŒ‡é’ˆç®¡ç†çš„æŒ‡é’ˆ\n1 2 3 4 5 // å®šä¹‰æ™ºèƒ½æŒ‡é’ˆ auto_ptr\u0026lt;Test\u0026gt; test(new Test); Test *tmp = test.get();\t// è·å–æŒ‡é’ˆè¿”å› cout \u0026lt;\u0026lt; \u0026#34;tmp-\u0026gt;debugï¼š\u0026#34; \u0026lt;\u0026lt; tmp-\u0026gt;getDebug() \u0026lt;\u0026lt; endl; ä½†ä¸€èˆ¬ä¸è¿™ä¹ˆä½¿ç”¨ï¼Œå› ä¸ºå¯ä»¥ç›´æ¥ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæ“ä½œ\nrelease()ï¼šé‡Šæ”¾æ™ºèƒ½æŒ‡é’ˆç®¡ç†çš„æŒ‡é’ˆ\n1 2 3 4 5 // å®šä¹‰æ™ºèƒ½æŒ‡é’ˆ auto_ptr\u0026lt;Test\u0026gt; test(new Test); Test *tmp2 = test.release();\t// å–æ¶ˆæ™ºèƒ½æŒ‡é’ˆå¯¹åŠ¨æ€å†…å­˜çš„æ‰˜ç®¡ delete tmp2;\t// ä¹‹å‰åˆ†é…çš„å†…å­˜éœ€è¦è‡ªå·±æ‰‹åŠ¨é‡Šæ”¾ reset()ï¼šé‡ç½®æ™ºèƒ½æŒ‡é’ˆç®¡ç†çš„æŒ‡é’ˆ\n1 2 3 4 5 6 // å®šä¹‰æ™ºèƒ½æŒ‡é’ˆ auto_ptr\u0026lt;Test\u0026gt; test(new Test); test.reset();\t// é‡Šæ”¾æ‰æ™ºèƒ½æŒ‡é’ˆæ‰˜ç®¡çš„æŒ‡é’ˆå†…å­˜ï¼Œå¹¶å°†å…¶ç½®NULL test.reset(new Test());\t// é‡Šæ”¾æ‰æ™ºèƒ½æŒ‡é’ˆæ‰˜ç®¡çš„æŒ‡é’ˆå†…å­˜ï¼Œå¹¶å°†å‚æ•°æŒ‡é’ˆå–ä»£ä¹‹ unique_ptr c++11ä½¿ç”¨unique_ptræ›¿ä»£auto_ptr\nunique_ptrç‰¹æ€§ï¼š\nåŸºäºæ’ä»–æ‰€æœ‰æƒæ¨¡å¼ï¼šä¸¤ä¸ªæŒ‡é’ˆä¸èƒ½æŒ‡å‘åŒä¸€ä¸ªèµ„æº æ— æ³•è¿›è¡Œå·¦å€¼unique_ptrå¤åˆ¶æ„é€ ï¼Œä¹Ÿæ— æ³•è¿›è¡Œå·¦å€¼å¤åˆ¶èµ‹å€¼æ“ä½œï¼Œä½†å…è®¸ä¸´æ—¶å³å€¼èµ‹å€¼æ„é€ å’Œèµ‹å€¼ ä¿å­˜æŒ‡å‘æŸä¸ªå¯¹è±¡çš„æŒ‡é’ˆï¼Œå½“å®ƒæœ¬èº«ç¦»å¼€ä½œç”¨åŸŸæ—¶ä¼šè‡ªåŠ¨é‡Šæ”¾å®ƒæŒ‡å‘çš„å¯¹è±¡ã€‚ åœ¨å®¹å™¨ä¸­ä¿å­˜æŒ‡é’ˆæ˜¯å®‰å…¨çš„ ","date":"2024-12-30T00:00:00Z","image":"https://example.com/post/cpp_study/cpp.jpg","permalink":"https://example.com/post/cpp_study/","title":"C++è¯­æ³•"},{"content":"yamlå‚æ•° ä¸»æ¡†æ¶ 1 2 3 4 5 6 baseurl: https://example.com/ languageCode: en-us theme: hugo-theme-stack paginate: 10 title: ä¸ªäººåšå®¢ copyright: serenNan baseurl: ç›®å‰æ˜¯github pagesçš„åœ°å€ my-blog\nlanguageCode: è¯­è¨€ä»£ç \ntheme: ä¸»é¢˜åç§°\npaginate: æ¯é¡µæ˜¾ç¤ºçš„æ–‡ç« æ•°é‡\ntitle: ç½‘ç«™æ ‡é¢˜ï¼ˆç›®å‰æ²¡ä½¿ç”¨ï¼‰\ncopyright: ç½‘é¡µæœ€ä¸‹æ–¹æ˜¾ç¤º\nè¯­è¨€ 1 2 3 # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw DefaultContentLanguage: zh-cn DefaultContentLanguage: é»˜è®¤è¯­è¨€\nç½‘é¡µå›¾æ ‡ 1 favicon: # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) favicon: ç½‘ç«™å›¾æ ‡(å°† favicon æ”¾ç½®åœ¨ç«™ç‚¹æ–‡ä»¶å¤¹çš„ static/favicon.ico ä¸­ï¼Œç„¶åå°†æ­¤å­—æ®µè®¾ç½®ä¸º /favicon.icoï¼ˆ/ æ˜¯å¿…éœ€çš„ï¼‰ã€‚)\né¡µè„š 1 2 3 footer: since: 2024 customText: footer: é¡µè„š\nsince: å¹´ä»½\ncustomText: è‡ªå®šä¹‰æ–‡æœ¬\nå¤´åƒ 1 2 3 4 5 6 7 sidebar: emoji: ğŸˆâ€â¬› subtitle: æ¬¢è¿æ¥åˆ°æˆ‘çš„ä¸ªäººåšå®¢ avatar: enabled: true local: true src: img/avatar.png sidebar: ä¾§è¾¹æ \navatar: å¤´åƒ\nsrc: å¤´åƒè·¯å¾„\nå¤´åƒæ˜¯åœ¨ assets/img/avatar.png ä¸­\næ–‡ç« ä¿¡æ¯ 1 2 3 4 5 6 7 article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 article: æ–‡ç« \nmath: æ•°å­¦å…¬å¼\ntoc: ç›®å½•\nreadingTime: é˜…è¯»æ—¶é—´\nlicense: è®¸å¯è¯\nenabled: æ˜¯å¦å¯ç”¨\ndefault: é»˜è®¤è®¸å¯è¯\nå³ä¾§ä¾§è¾¹æ  1 2 3 4 5 6 7 8 9 10 11 12 13 14 widgets: homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc widgets: å°å·¥å…· (å³è¾¹ä¾§è¾¹æ )\nsearch: æœç´¢\narchives: å½’æ¡£\ncategories: åˆ†ç±»\ntag-cloud: æ ‡ç­¾äº‘\ntoc: ç›®å½•\nå¤´åƒä¸‹æ–¹å›¾æ ‡ 1 2 3 4 5 6 7 8 9 10 11 12 social: - identifier: github name: GitHub url: https://github.com/CaiJimmy/hugo-theme-stack params: icon: github-2 - identifier: bilibili name: Bilibili url: https://space.bilibili.com/450940909 params: icon: bilibili å¤´åƒä¸‹æ–¹çš„é“¾æ¥ï¼Œiconå›¾æ ‡æ”¾åœ¨assets/iconsæ–‡ä»¶å¤¹ä¸‹ï¼Œsvgåç¼€ã€‚\nå·¦ä¾§ä¾§è¾¹æ å¯¼èˆª åœ¨content/pageæ–‡ä»¶å¤¹ä¸‹\nlinké“¾æ¥ åœ¨content/page/links.mdä¸‹ æ ¼å¼:\n1 2 3 4 5 6 7 8 9 links: - title: GitHub description: GitHub is the world\u0026#39;s largest software development platform. website: https://github.com image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png - title: TypeScript description: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. website: https://www.typescriptlang.org image: ts-logo-128.jpg è‡ªå®šä¹‰åˆ†ç±»é¡µé¢ æˆ‘è¿™é‡Œæ˜¯è‡ªå®šä¹‰çš„åˆ†ç±»é¡µé¢ï¼Œå°†å½’æ¡£å’Œåˆ†ç±»åˆ†å¼€\nåœ¨content/categories.mdä¸‹ï¼Œæ¯æœ‰ä¸€ä¸ªåˆ†ç±»å°±åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œæ–‡ä»¶å¤¹ä¸‹æ”¾_index.mdæ–‡ä»¶ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\næ³¨æ„ï¼šæ˜¯_index.mdè¦åŠ ä¸ª_\n1 2 3 4 5 6 7 8 title: \u0026#34;æ–‡æ¡£\u0026#34; date: 2020-03-14T15:40:24+06:00 description : \u0026#34;æ–‡æ¡£åˆ†ç±»\u0026#34; slug: \u0026#34;document\u0026#34; image: çŒ«.png style: background: \u0026#34;#2a9d8f\u0026#34; color: \u0026#34;#fff\u0026#34; å¦‚æœæƒ³å®Œå–„é¡µé¢ï¼Œå¯ä»¥åœ¨layouts/page/categories.htmlæ·»åŠ ä¸‹é¢çš„å†…å®¹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 {{ define \u0026#34;body-class\u0026#34; }}template-categories{{ end }} {{ define \u0026#34;main\u0026#34; }} \u0026lt;header\u0026gt; {{- $taxonomy := $.Site.GetPage \u0026#34;taxonomyTerm\u0026#34; \u0026#34;categories\u0026#34; -}} {{- $terms := $taxonomy.Pages -}} {{ if $terms }} \u0026lt;h1 class=\u0026#34;section-title\u0026#34;\u0026gt;åˆ†ç±»\u0026lt;/h1\u0026gt; \u0026lt;!-- è¿™é‡Œæ˜¯æ ‡é¢˜ --\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;article-list--tile\u0026#34; style=\u0026#34;display: flex; flex-direction: column;\u0026#34;\u0026gt; {{ range $terms }} \u0026lt;div class=\u0026#34;category-group\u0026#34; style=\u0026#34;flex: 1 1 auto; margin: 10px;\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;category-title\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;article-list--horizontal\u0026#34; style=\u0026#34;display: flex; overflow-x: auto;\u0026#34;\u0026gt; {{ $articles := where .Site.RegularPages \u0026#34;Params.categories\u0026#34; \u0026#34;intersect\u0026#34; (slice .Title) }} {{ range $articles }} \u0026lt;div class=\u0026#34;article-tile\u0026#34; style=\u0026#34;flex: 0 0 auto; margin: 5px;\u0026#34;\u0026gt; {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;size\u0026#34; \u0026#34;250x150\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;taxonomy\u0026#34;) }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/header\u0026gt; {{ partialCached \u0026#34;footer/footer\u0026#34; . }} {{ end }} æ–‡ç«  åœ¨content/postæ–‡ä»¶å¤¹ä¸‹ï¼Œæ­£æ–‡å°±ç”¨markdownæ ¼å¼\nä¸»é¡µblogæ˜¾ç¤º 1 2 3 4 5 6 7 8 title: Chinese Test description: è¿™æ˜¯ä¸€ä¸ªå‰¯æ ‡é¢˜ date: 2020-09-09 slug: test-chinese # urlæ˜¾ç¤º image: helena-hertz-wWZzXlDpMog-unsplash.jpg categories: - Test - æµ‹è¯• åˆ›å»ºæ—¶é—´\u0026amp;æ›´æ–°æ—¶é—´ 1 2 3 4 5 6 7 8 # æ›´æ–°æ—¶é—´ï¼šä¼˜å…ˆè¯»å–gitæ—¶é—´ -\u0026gt; gitæ—¶é—´ä¸å­˜åœ¨ï¼Œå°±è¯»å–æœ¬åœ°æ–‡ä»¶ä¿®æ”¹æ—¶é—´ frontmatter: lastmod: - :git - :fileModTime # å…è®¸è·å–Gitä¿¡æ¯\tenableGitInfo: true åœ¨éƒ¨ç½²æ–‡ä»¶.github/workflows/deploy.yaml æ·»åŠ ï¼š\n1 2 3 4 5 6 - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false æ³¨æ„ç¼©è¿›è¦å¯¹\nstacké»˜è®¤æ˜¾ç¤ºåœ¨æ–‡ç« æœ€åé¢ï¼Œå¦‚æœæƒ³åœ¨ä¸»é¡µé¢çš„åšå®¢æ–‡ç« æ˜¾ç¤ºï¼Œåœ¨layouts/partials/article/components/details.htmlæ·»åŠ ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!-- åˆ›å»ºæ—¶é—´\u0026amp;é˜…è¯»æ—¶é•¿ --\u0026gt; \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; {{ if $showDate }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;date\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--published\u0026#34;\u0026gt; {{- .Date | time.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{ if $showReadingTime }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; {{ T \u0026#34;article.readingTime\u0026#34; .ReadingTime }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{ if and $showDate (ne .Lastmod .Date) }} \u0026lt;span class=\u0026#34;time-divider\u0026#34;\u0026gt;|\u0026lt;/span\u0026gt; {{ end }} {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-time--lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} è‡ªå¸¦çš„æœ‰é˜…è¯»æ—¶é•¿ï¼Œæˆ‘æ²¡å¼€å¯\næ–‡ç« æœ«å°¾ä¹Ÿä¼šæ˜¾ç¤ºæœ€åä¿®æ”¹æ—¶é—´ï¼Œæƒ³åˆ é™¤å°±å»layouts/partials/article/components/footer.htmlåˆ æ‰ï¼š\n1 2 3 4 5 6 7 8 {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;span\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod | time.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{- end -}} ","date":"2024-12-29T00:00:00Z","image":"https://example.com/post/hugo-config/blog1.jpg","permalink":"https://example.com/post/hugo-config/","title":"Hugoé…ç½®(stackä¸»é¢˜)"},{"content":"åŸºç¡€å‘½ä»¤ CSDNåšä¸»æ€»ç»“å¸¸ç”¨å‘½ä»¤\nè·å¾—åŸºç¡€ä¿¡æ¯ï¼Œè¾“å‡ºMetadata æ‰“å¼€åª’ä½“æ–‡ä»¶ï¼Œè·å–Metaä¿¡æ¯ï¼Œå…³é—­åª’ä½“æ–‡ä»¶\nä»£ç  dumpMetaData.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026#34;libavutil/log.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; // ä¼ å…¥å‘½ä»¤è¡Œå‚æ•°ä¸ªæ•° int main(int argc, char **argv) { // è®¾ç½®æ—¥å¿—çº§åˆ« av_log_set_level(AV_LOG_DEBUG); // è®¾ç½®æ—¥å¿—è¾“å‡ºå‡½æ•° // æ£€æŸ¥å‚æ•°ä¸ªæ•° if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_DEBUG, \u0026#34;Usage:%s infileName.\\n\u0026#34;, argv[0]); return -1; } // è·å–è¾“å…¥æ–‡ä»¶å const char *infileName = argv[1]; // åˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶ AVFormatContext *pFormatCtx = NULL; // æ‰“å¼€åª’ä½“æ–‡ä»¶ int ret = avformat_open_input(\u0026amp;pFormatCtx, infileName, NULL, NULL); // av_err2str()å‡½æ•°è¿”å›é”™è¯¯ä¿¡æ¯ if (ret != 0) { // av_err2str()å‡½æ•°è¿”å›é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_DEBUG, \u0026#34;open input file:%s failed: %s\\n\u0026#34;, infileName, av_err2str(ret)); return -1; } // è·å–åª’ä½“æ–‡ä»¶ä¿¡æ¯ av_dump_format(pFormatCtx, 0, infileName, 0); // å…³é—­åª’ä½“æ–‡ä»¶ avformat_close_input(\u0026amp;pFormatCtx); return 0; } å®¹å™¨/æ–‡ä»¶ (Container/File) å®šä¹‰: ç‰¹å®šæ ¼å¼çš„å¤šåª’ä½“æ–‡ä»¶ï¼Œå¦‚Â .mp4,Â .flv,Â .movÂ ç­‰ã€‚ ä½œç”¨: å­˜å‚¨å’Œç»„ç»‡å¤šåª’ä½“æ•°æ®ï¼ŒåŒ…æ‹¬éŸ³é¢‘ã€è§†é¢‘ã€å­—å¹•ç­‰ã€‚ å¸¸è§æ ¼å¼: MP4: å¹¿æ³›ç”¨äºè§†é¢‘å­˜å‚¨å’Œæµåª’ä½“ã€‚ FLV: ä¸»è¦ç”¨äºFlashè§†é¢‘ã€‚ MOV: è‹¹æœå…¬å¸å¼€å‘çš„è§†é¢‘æ ¼å¼ã€‚ åª’ä½“æµ (Stream) å®šä¹‰: ä¸€æ®µè¿ç»­çš„æ•°æ®ï¼Œå¦‚ä¸€æ®µå£°éŸ³æ•°æ®ã€ä¸€æ®µè§†é¢‘æˆ–è€…ä¸€æ®µå­—å¹•æ•°æ®ã€‚ ç‰¹ç‚¹: ç”±ä¸åŒç¼–ç å™¨ç¼–ç ã€‚ ç±»å‹: éŸ³é¢‘æµ: å­˜å‚¨éŸ³é¢‘æ•°æ®ã€‚ è§†é¢‘æµ: å­˜å‚¨è§†é¢‘æ•°æ®ã€‚ å­—å¹•æµ: å­˜å‚¨å­—å¹•æ•°æ®ã€‚ æ•°æ®åŒ… (Packet) å®šä¹‰: ä¸€ä¸ªåª’ä½“æµç”±å¤§é‡çš„æ•°æ®åŒ…ç»„æˆï¼Œæ˜¯å‹ç¼©åçš„æ•°æ®ã€‚ ä½œç”¨: ä¼ è¾“å’Œå­˜å‚¨åª’ä½“æ•°æ®çš„åŸºæœ¬å•ä½ã€‚ ç‰¹ç‚¹: æ•°æ®åŒ…æ˜¯å‹ç¼©åçš„æ•°æ®ï¼Œä¾¿äºä¼ è¾“å’Œå­˜å‚¨ã€‚ æ•°æ®å¸§ (Frame) å®šä¹‰: ä¸€ä¸ªæ•°æ®åŒ…ç”±ä¸€ä¸ªæˆ–å¤šä¸ªæ•°æ®å¸§ç»„æˆï¼Œæ˜¯éå‹ç¼©æ•°æ®ã€‚ ä½œç”¨: åŸå§‹çš„ã€æœªå‹ç¼©çš„åª’ä½“æ•°æ®ã€‚ ç±»å‹: Iå¸§ (Intra Frame): ç‹¬ç«‹å¸§ï¼Œä¸ä¾èµ–å…¶ä»–å¸§ã€‚ På¸§ (Predictive Frame): ä¾èµ–å‰ä¸€å¸§è¿›è¡Œé¢„æµ‹ã€‚ Bå¸§ (Bidirectional Frame): ä¾èµ–å‰åå¸§è¿›è¡Œé¢„æµ‹ã€‚ ç¼–è§£ç å™¨ (Codec) å®šä¹‰: ç¼–è§£ç å™¨æ˜¯ä»¥å¸§ä¸ºå•ä½å®ç°å‹ç¼©æ•°æ®å’ŒåŸå§‹æ•°æ®ä¹‹é—´ç›¸äº’è½¬æ¢çš„å·¥å…·ã€‚ ä½œç”¨: ç”¨äºå‹ç¼©å’Œè§£å‹ç¼©åª’ä½“æ•°æ®ã€‚ å¸¸è§ç¼–è§£ç å™¨: è§†é¢‘ç¼–è§£ç å™¨: H.264, H.265, VP9 ç­‰ã€‚ éŸ³é¢‘ç¼–è§£ç å™¨: AAC, MP3, Vorbis ç­‰ã€‚ é‡è¦ç»“æ„ä½“ AVFormatContext: ç®¡ç†æ•´ä¸ªå¤šåª’ä½“æ–‡ä»¶çš„æ ¼å¼å’Œç»“æ„ã€‚ AVStream: è¡¨ç¤ºåª’ä½“æ–‡ä»¶ä¸­çš„ä¸€ä¸ªå•ç‹¬çš„åª’ä½“æµã€‚ AVCodecContext ä¸ AVCodec: ç®¡ç†åª’ä½“æ•°æ®çš„ç¼–ç å’Œè§£ç è¿‡ç¨‹ã€‚ AVPacket: è¡¨ç¤ºå‹ç¼©åçš„åª’ä½“æ•°æ®ã€‚ AVFrame: è¡¨ç¤ºæœªå‹ç¼©çš„åŸå§‹åª’ä½“æ•°æ®ã€‚ è§£å°è£…-æå–aacæ•°æ® AACï¼ˆAdvanced Audio Codingï¼‰æ˜¯ä¸€ç§é«˜çº§éŸ³é¢‘ç¼–ç æŠ€æœ¯ï¼Œå¹¿æ³›ç”¨äºæ•°å­—éŸ³é¢‘å‹ç¼©å’Œä¼ è¾“ã€‚å®ƒæ˜¯ç”±MPEGï¼ˆMoving Picture Experts Groupï¼‰å¼€å‘çš„ï¼Œæ—¨åœ¨æä¾›æ¯”MP3æ›´é«˜çš„éŸ³è´¨å’Œæ›´é«˜çš„å‹ç¼©æ•ˆç‡ã€‚AACé€šå¸¸ç”¨äºå„ç§éŸ³é¢‘åº”ç”¨ï¼ŒåŒ…æ‹¬éŸ³ä¹ã€è§†é¢‘ã€å¹¿æ’­å’Œæµåª’ä½“æœåŠ¡ã€‚\nAACçš„ä¸»è¦ç‰¹ç‚¹ï¼š\né«˜éŸ³è´¨ï¼šAACèƒ½å¤Ÿåœ¨è¾ƒä½çš„æ¯”ç‰¹ç‡ä¸‹æä¾›æ¯”MP3æ›´é«˜çš„éŸ³è´¨ã€‚ å¤šé€šé“æ”¯æŒï¼šAACæ”¯æŒå¤šé€šé“éŸ³é¢‘ï¼ŒåŒ…æ‹¬ç«‹ä½“å£°ã€5.1ç¯ç»•å£°å’Œ7.1ç¯ç»•å£°ã€‚ ä½å»¶è¿Ÿï¼šAACè®¾è®¡ç”¨äºä½å»¶è¿Ÿåº”ç”¨ï¼Œé€‚åˆå®æ—¶éŸ³é¢‘ä¼ è¾“ã€‚ çµæ´»æ€§ï¼šAACæ”¯æŒå¤šç§æ¯”ç‰¹ç‡å’Œé‡‡æ ·ç‡ï¼Œé€‚ç”¨äºä¸åŒçš„åº”ç”¨åœºæ™¯ã€‚ 1 2 ffmpeg -y -i out.mp4 -vn -acodec copy out.aac ffplay out.aac æµç¨‹ æ“ä½œæ­¥éª¤ å‡½æ•°å æ‰“å¼€åª’ä½“æ–‡ä»¶ avformat_open_input è·å–ç æµä¿¡æ¯ avformat_find_stream_info è·å–éŸ³é¢‘æµ av_find_best_stream åˆå§‹åŒ– packet av_packet_alloc è¯»å– packet æ•°æ® av_read_frame é‡Šæ”¾ packet æ•°æ® av_packet_unref å…³é—­åª’ä½“æ–‡ä»¶ avformat_close_input ä»£ç  demuxing_audio.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; int main(int argc, char *argv[]) { // è®¾ç½®æ—¥å¿—çº§åˆ« av_log_set_level(AV_LOG_DEBUG); // å¦‚æœå‚æ•°å°äº3ï¼Œè¾“å‡ºä½¿ç”¨æ–¹æ³• if (argc \u0026lt; 3) { // argv[0]æ˜¯ç¨‹åºå av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input file\u0026gt; \u0026lt;output file\u0026gt;\\n\u0026#34;, argv[0]); return -1; } // è·å–å‘½ä»¤è¡Œçš„è¾“å…¥éŸ³é¢‘ const char *inputName = argv[1]; // è·å–å‘½ä»¤è¡Œçš„è¾“å‡ºéŸ³é¢‘ const char *outputName = argv[2]; av_sdp_create; // æ‰“å¼€è¾“å…¥éŸ³é¢‘æ–‡ä»¶ AVFormatContext *inFormatCtx = NULL; // æ‰“å¼€åª’ä½“æ–‡ä»¶ï¼Œå¹¶è·å–æµä¿¡æ¯ int ret = avformat_open_input(\u0026amp;inFormatCtx, inputName, NULL, NULL); // å¦‚æœæ‰“å¼€è¾“å…¥æ–‡ä»¶å¤±è´¥ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯ if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open input file \u0026#39;%s\u0026#39;\\n\u0026#34;, inputName); return -1; } // è·å–ç æµä¿¡æ¯ ret = avformat_find_stream_info(inFormatCtx, NULL); // å¦‚æœretå°äº0ï¼Œåˆ™æ‰“å°é”™è¯¯ä¿¡æ¯ if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); // å°±ç®—è·å–å¤±è´¥ï¼Œä¹Ÿè¦å…³é—­è¾“å…¥æ–‡ä»¶ avformat_close_input(\u0026amp;inFormatCtx); return -1; } // å¦‚æœè·å–æˆåŠŸï¼Œåˆ™æ‰“å°ä¿¡æ¯ int audioIndex = av_find_best_stream(inFormatCtx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (audioIndex \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find audio stream in the input file\\n\u0026#34;); avformat_close_input(\u0026amp;inFormatCtx); return -1; } if (audioIndex \u0026lt; 0) { // è¾“å‡ºé”™è¯¯ä¿¡æ¯ï¼Œè¡¨ç¤ºæ‰¾ä¸åˆ°æœ€ä½³éŸ³é¢‘æµ av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream failed, index is %d\\n\u0026#34;, audioIndex); avformat_close_input(\u0026amp;inFormatCtx); return -1; } // æ‰“å°éŸ³é¢‘ä¿¡æ¯ av_log(NULL, AV_LOG_INFO, \u0026#34;the audio index is %d\\n\u0026#34;, audioIndex); // åˆå§‹åŒ–AVPacketç»“æ„ä½“ AVPacket *packet = av_packet_alloc(); if (!packet) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate packet\\n\u0026#34;); avformat_close_input(\u0026amp;inFormatCtx); return -1; } // å­˜å‚¨éŸ³é¢‘æµä¿¡æ¯ è¾“å‡ºæ–‡ä»¶ FILE *dest_fp = fopen(outputName, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open %s file failed\\n\u0026#34;, outputName); // å°±ç®—æ‰“ä¸å¼€æ–‡ä»¶ä¹Ÿå¾—å…³é—­éŸ³é¢‘æ–‡ä»¶ avformat_close_input(\u0026amp;inFormatCtx); // é‡Šæ”¾åˆ†é…çš„AVPacket av_packet_free(\u0026amp;packet); return -1; } // æœ‰è®¸å¤šPCæ•°æ®ï¼Œæ‰€ä»¥éœ€è¦å¾ªç¯è¯»å– while (av_read_frame(inFormatCtx, packet) == 0) { // æ£€æŸ¥å½“å‰åŒ…æ˜¯å¦å±äºéŸ³é¢‘æµ if (packet-\u0026gt;stream_index == audioIndex) { // å°†éŸ³é¢‘æ•°æ®å†™å…¥è¾“å‡ºæ–‡ä»¶ fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); // æ£€æŸ¥å†™å…¥æ˜¯å¦æˆåŠŸ if (ret != packet-\u0026gt;size) { // å¦‚æœå†™å…¥çš„æ•°æ®å¤§å°ä¸ç­‰äºåŒ…çš„å¤§å°ï¼Œåˆ™è¾“å‡ºé”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;write data failed\\n\u0026#34;); // å…³é—­è¾“å‡ºæ–‡ä»¶ fclose(dest_fp); // å…³é—­è¾“å…¥æ–‡ä»¶ avformat_close_input(\u0026amp;inFormatCtx); // é‡Šæ”¾æ•´ä¸ªç»“æ„ä½“ av_packet_free(\u0026amp;packet); return -1; } } // é‡Šæ”¾å½“å‰åŒ…çš„å¼•ç”¨ av_packet_unref(packet); } // æ£€æŸ¥è¾“å…¥æ ¼å¼ä¸Šä¸‹æ–‡æ˜¯å¦å·²åˆå§‹åŒ– if (inFormatCtx != NULL) { // å…³é—­è¾“å…¥æ–‡ä»¶ avformat_close_input(\u0026amp;inFormatCtx); } // æ£€æŸ¥è¾“å‡ºæ–‡ä»¶æŒ‡é’ˆæ˜¯å¦å·²åˆå§‹åŒ– if (dest_fp != NULL) { // å…³é—­è¾“å‡ºæ–‡ä»¶ fclose(dest_fp); } if (packet != NULL) { // é‡Šæ”¾AVPacketç»“æ„ä½“ av_packet_free(\u0026amp;packet); } return 0; } aacéŸ³é¢‘æ ¼å¼åˆ†æ ADTSï¼ˆAudio Data Transport Streamï¼‰å’ŒADIFï¼ˆAudio Data Interchange Formatï¼‰æ˜¯ä¸¤ç§ç”¨äºéŸ³é¢‘ç¼–ç çš„å®¹å™¨æ ¼å¼ï¼Œä¸»è¦ç”¨äºAACï¼ˆAdvanced Audio Codecï¼‰éŸ³é¢‘ç¼–ç ã€‚å®ƒä»¬çš„ä¸»è¦åŒºåˆ«åœ¨äºæ•°æ®æµçš„ç»„ç»‡æ–¹å¼å’Œä½¿ç”¨åœºæ™¯ã€‚\nADTSï¼ˆAudio Data Transport Streamï¼‰ å®šä¹‰: ADTSæ˜¯ä¸€ç§æµå¼ä¼ è¾“æ ¼å¼ï¼Œé€‚ç”¨äºéŸ³é¢‘æ•°æ®çš„å®æ—¶ä¼ è¾“ï¼Œå¦‚å¹¿æ’­ã€æµåª’ä½“ç­‰ã€‚ ç»“æ„: æ¯ä¸ªADTSå¸§éƒ½åŒ…å«ä¸€ä¸ªå¤´ä¿¡æ¯ï¼Œåé¢è·Ÿç€éŸ³é¢‘æ•°æ®ã€‚å¤´ä¿¡æ¯ä¸­åŒ…å«äº†å¸§çš„é•¿åº¦ã€é‡‡æ ·ç‡ã€å£°é“æ•°ç­‰ä¿¡æ¯ã€‚ ç‰¹ç‚¹: è‡ªåŒ…å«: æ¯ä¸ªADTSå¸§éƒ½æ˜¯è‡ªåŒ…å«çš„ï¼Œå¯ä»¥ç‹¬ç«‹è§£ç ã€‚ æµå¼ä¼ è¾“: é€‚åˆæµå¼ä¼ è¾“ï¼Œå› ä¸ºæ¯ä¸ªå¸§éƒ½å¯ä»¥ç‹¬ç«‹å¤„ç†ã€‚ å¤´éƒ¨ä¿¡æ¯: æ¯ä¸ªå¸§çš„å¤´éƒ¨ä¿¡æ¯è¾ƒå¤§ï¼Œå¯èƒ½ä¼šå¢åŠ ä¸€äº›å¼€é”€ã€‚ ADIFï¼ˆAudio Data Interchange Formatï¼‰ å®šä¹‰: ADIFæ˜¯ä¸€ç§æ–‡ä»¶æ ¼å¼ï¼Œé€‚ç”¨äºéŸ³é¢‘æ•°æ®çš„å­˜å‚¨å’Œäº¤æ¢ï¼Œå¦‚éŸ³é¢‘æ–‡ä»¶çš„å­˜å‚¨ã€‚ ç»“æ„: ADIFæ–‡ä»¶åŒ…å«ä¸€ä¸ªå”¯ä¸€çš„å¤´ä¿¡æ¯ï¼Œåé¢è·Ÿç€æ‰€æœ‰çš„éŸ³é¢‘æ•°æ®ã€‚å¤´ä¿¡æ¯ä¸­åŒ…å«äº†ç¼–ç å‚æ•°ã€é‡‡æ ·ç‡ã€å£°é“æ•°ç­‰ä¿¡æ¯ã€‚ ç‰¹ç‚¹: å•ä¸€å¤´éƒ¨: æ•´ä¸ªæ–‡ä»¶åªæœ‰ä¸€ä¸ªå¤´éƒ¨ä¿¡æ¯ï¼Œå‡å°‘äº†å†—ä½™ã€‚ éæµå¼: ä¸é€‚åˆæµå¼ä¼ è¾“ï¼Œå› ä¸ºéœ€è¦æ•´ä¸ªæ–‡ä»¶çš„å¤´ä¿¡æ¯æ‰èƒ½å¼€å§‹è§£ç ã€‚ å­˜å‚¨å’Œäº¤æ¢: é€‚åˆå­˜å‚¨å’Œäº¤æ¢éŸ³é¢‘æ•°æ®ï¼Œå› ä¸ºå¤´éƒ¨ä¿¡æ¯åªå‡ºç°ä¸€æ¬¡ï¼Œå‡å°‘äº†æ–‡ä»¶å¤§å°ã€‚ æ€»ç»“ ADTS: é€‚ç”¨äºæµå¼ä¼ è¾“ï¼Œæ¯ä¸ªå¸§è‡ªåŒ…å«ï¼Œé€‚åˆå®æ—¶ä¼ è¾“ã€‚ ADIF: é€‚ç”¨äºæ–‡ä»¶å­˜å‚¨å’Œäº¤æ¢ï¼Œæ•´ä¸ªæ–‡ä»¶åªæœ‰ä¸€ä¸ªå¤´éƒ¨ä¿¡æ¯ï¼Œé€‚åˆå­˜å‚¨å’Œäº¤æ¢éŸ³é¢‘æ•°æ®ã€‚ é€‰æ‹©å“ªç§æ ¼å¼å–å†³äºå…·ä½“çš„åº”ç”¨åœºæ™¯ï¼šå¦‚æœéœ€è¦å®æ—¶ä¼ è¾“éŸ³é¢‘æ•°æ®ï¼ŒADTSæ˜¯æ›´å¥½çš„é€‰æ‹©ï¼›å¦‚æœéœ€è¦å­˜å‚¨æˆ–äº¤æ¢éŸ³é¢‘æ–‡ä»¶ï¼ŒADIFæ›´ä¸ºåˆé€‚ã€‚\næå–H264è§†é¢‘æ•°æ® æµç¨‹ æµç¨‹å’Œæå–aacæ–‡ä»¶ä¸€æ ·\næ“ä½œæ­¥éª¤ å‡½æ•°å æ‰“å¼€åª’ä½“æ–‡ä»¶ avformat_open_input è·å–ç æµä¿¡æ¯ avformat_find_stream_info è·å–éŸ³é¢‘æµ av_find_best_stream åˆå§‹åŒ– packet av_packet_alloc è¯»å– packet æ•°æ® av_read_frame é‡Šæ”¾ packet æ•°æ® av_packet_unref å…³é—­åª’ä½“æ–‡ä»¶ avformat_close_input ä»£ç  demuxing_video.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFilename = argv[1]; const char *outFilename = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFilename, NULL, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } int videoIndex = ret; FILE *dest_fp = fopen(outFilename, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open output file failed:%s\\n\u0026#34;, outFilename); ret = -1; goto fail; } AVPacket *packet = av_packet_alloc(); while (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == videoIndex) { int writeSize = fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); if (writeSize != packet-\u0026gt;size) { // è¿™é‡Œä¸èƒ½é‡Šæ”¾æ•´ä¸ªpacketï¼Œåªèƒ½é‡Šæ”¾packetä¸­çš„dataï¼Œå› ä¸ºå¾ªç¯ä¹‹åè¿˜ä¼šç”¨åˆ°packet av_packet_unref(packet); ret = -1; break; } } av_packet_free(\u0026amp;packet); } fclose(dest_fp); fail: if(inFmtCtx != NULL) { avformat_close_input(\u0026amp;inFmtCtx); } if(dest_fp != NULL) { fclose(dest_fp); } return ret; } æˆåŠŸè¿è¡Œï¼Œè¦ç”¨aviæ ¼å¼çš„è§†é¢‘æ–‡ä»¶\nå¦‚æœæƒ³æå–mp4æ ¼å¼çš„æ–‡ä»¶ï¼Œéœ€è¦è¿›è¡Œä»¥ä¸‹æ­¥éª¤\nmp4â†’h264 æµç¨‹ å‡½æ•°å æè¿° av_bsf_get_by_name æ ¹æ®åç§°è·å–æ¯”ç‰¹æµè¿‡æ»¤å™¨ av_bsf_alloc åˆ†é…æ¯”ç‰¹æµè¿‡æ»¤å™¨ä¸Šä¸‹æ–‡ avcodec_parameters_copy å¤åˆ¶ç¼–è§£ç å™¨å‚æ•° av_bsf_init åˆå§‹åŒ–æ¯”ç‰¹æµè¿‡æ»¤å™¨ av_bsf_send_packet å‘é€æ•°æ®åŒ…åˆ°æ¯”ç‰¹æµè¿‡æ»¤å™¨ av_bsf_receive_packet ä»æ¯”ç‰¹æµè¿‡æ»¤å™¨æ¥æ”¶å¤„ç†åçš„æ•°æ®åŒ… av_bsf_free é‡Šæ”¾æ¯”ç‰¹æµè¿‡æ»¤å™¨ä¸Šä¸‹æ–‡åŠç›¸å…³èµ„æº ä»£ç  mp4toh264.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavcodec/bsf.h\u0026gt; int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFilename = argv[1]; const char *outFilename = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFilename, NULL, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } int videoIndex = ret; FILE *dest_fp = fopen(outFilename, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open output file failed:%s\\n\u0026#34;, outFilename); ret = -1; goto fail; } AVPacket *packet = av_packet_alloc(); const AVBitStreamFilter *bsf = av_bsf_get_by_name(\u0026#34;h264_mp4toannexb\u0026#34;); if(bsf == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;get h264_mp4toannexb bsf failed\\n\u0026#34;); ret = -1; goto fail; } AVBSFContext *bsfCtx = NULL; av_bsf_alloc(bsf, \u0026amp;bsfCtx); avcodec_parameters_copy(bsfCtx-\u0026gt;par_in, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); av_bsf_init(bsfCtx); while (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == videoIndex) { if(av_bsf_send_packet(bsfCtx, packet) == 0) { while(av_bsf_receive_packet(bsfCtx, packet) == 0) { int writeSize = fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); if (writeSize != packet-\u0026gt;size) { // è¿™é‡Œä¸èƒ½é‡Šæ”¾æ•´ä¸ªpacketï¼Œåªèƒ½é‡Šæ”¾packetä¸­çš„dataï¼Œå› ä¸ºå¾ªç¯ä¹‹åè¿˜ä¼šç”¨åˆ°packet av_packet_unref(packet); ret = -1; break; } } } } av_packet_free(\u0026amp;packet); } fclose(dest_fp); fail: if(inFmtCtx != NULL) { avformat_close_input(\u0026amp;inFmtCtx); } if(bsfCtx != NULL) { av_bsf_free(\u0026amp;bsfCtx); } if(dest_fp != NULL) { fclose(dest_fp); } return ret; } è½¬å°è£…-mp4è½¬flv Iå¸§ï¼ŒPå¸§ï¼ŒBå¸§ Iå¸§ï¼šå¸§å†…ç¼–ç å¸§ï¼ˆIntra pictureï¼‰ï¼ŒIå¸§é€šå¸¸æ˜¯ä¸€ä¸ªGOPçš„ç¬¬ä¸€å¸§ï¼Œç»è¿‡è½»åº¦åœ°å‹ç¼©ï¼Œä½œä¸ºéšæœºè®¿é—®çš„å‚è€ƒç‚¹ï¼Œå¯ä»¥å½“æˆé™æ€å›¾åƒï¼ŒIå¸§å‹ç¼©å¯å»æ‰è§†é¢‘çš„ç©ºé—´å†—ä½™ä¿¡æ¯ã€‚\nPå¸§ï¼šå‰å‘é¢„æµ‹ç¼–ç å¸§ï¼ˆpredictive frameï¼‰ï¼Œé€šè¿‡å°†å›¾åƒåºåˆ—ä¸­å‰é¢å·²ç¼–ç å¸§çš„æ—¶é—´å†—ä½™ä¿¡æ¯å……åˆ†å»é™¤æ¥å‹ç¼©ä¼ è¾“æ•°æ®é‡çš„ç¼–ç å›¾åƒï¼Œä¹Ÿç§°ä¸ºé¢„æµ‹å¸§ã€‚\nBå¸§ï¼šåŒå‘é¢„æµ‹å†…æ’ç¼–ç å¸§ï¼Œæ—¢è€ƒè™‘æºå›¾åƒåºåˆ—å‰é¢çš„å·²ç¼–ç å¸§ï¼Œåˆé¡¾åŠæºå›¾åƒåºåˆ—åé¢çš„å·²ç¼–ç å¸§ä¹‹é—´çš„æ—¶é—´å†—ä½™ä¿¡æ¯ï¼Œæ¥å‹ç¼©ä¼ è¾“æ•°æ®é‡çš„ç¼–ç å›¾åƒï¼Œä¹Ÿç§°ä¸ºåŒå‘é¢„æµ‹å¸§\nPTS-æ˜¾ç¤ºæ—¶é—´æˆ³\nDTS-è§£ç æ—¶é—´æˆ³\næµç¨‹ æ­¥éª¤ å¯¹åº”å‡½æ•° æ‰“å¼€è¾“å…¥åª’ä½“æ–‡ä»¶ avformat_open_input è·å–è¾“å…¥æµä¿¡æ¯ avformat_find_stream_info åˆ›å»ºè¾“å‡ºæµä¸Šä¸‹æ–‡ avformat_alloc_output_context2 åˆ›å»ºè¾“å‡ºç æµçš„AVStream avformat_new_stream æ‹·è´ç¼–ç å‚æ•° avcodec_parameters_copy å†™å…¥è§†é¢‘æ–‡ä»¶å¤´ avformat_write_header è¯»å–è¾“å…¥è§†é¢‘æµ av_read_frame è®¡ç®—pts/dts/duration av_rescale_q_rnd/av_rescale_q å†™å…¥è§†é¢‘æµæ•°æ® av_interleaved_write_frame å†™å…¥è§†é¢‘æ–‡ä»¶æœ«å°¾ av_write_trailer ä»£ç  mp4toflv.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;infileName\u0026gt; \u0026lt;outfileName\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFileName = argv[1]; const char *outFileName = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find input stream failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } AVFormatContext *outFmtCtx = NULL; // åˆ†é…è¾“å‡ºæ ¼å¼ä¸Šä¸‹æ–‡ ret = avformat_alloc_output_context2(\u0026amp;outFmtCtx, NULL, NULL, outFileName); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc output format failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // è¾“å…¥æ–‡ä»¶çš„æµæ•°é‡ int streamCount = inFmtCtx-\u0026gt;nb_streams; // åˆ†é…ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œç”¨äºå­˜å‚¨è¾“å…¥æµç´¢å¼•åˆ°è¾“å‡ºæµç´¢å¼•çš„æ˜ å°„å…³ç³»ï¼Œå¹¶å°†å…¶åˆå§‹åŒ–ä¸ºé›¶ int *handleStreamIndexArray = av_malloc_array(streamCount, sizeof(int)); if (handleStreamIndexArray == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;malloc handle stream index array failed\\n\u0026#34;); goto fail; } int streamIndex = 0; // ç”¨äºå¤šåª’ä½“å¤„ç†çš„å¾ªç¯ï¼Œä¸»è¦åŠŸèƒ½æ˜¯å°†è¾“å…¥æ–‡ä»¶ä¸­çš„éŸ³è§†é¢‘æµå¤åˆ¶åˆ°è¾“å‡ºæ–‡ä»¶ä¸­ for (int i = 0; i \u0026lt; streamCount; i++) { // è·å–è¾“å…¥æ–‡ä»¶çš„æµ AVStream *inStream = inFmtCtx-\u0026gt;streams[i]; // åˆ¤æ–­æµçš„ç±»å‹ï¼ˆè§†é¢‘ï¼ŒéŸ³é¢‘æˆ–å­—å¹•ï¼‰ if (inStream-\u0026gt;codecpar-\u0026gt;codec_type != AVMEDIA_TYPE_VIDEO \u0026amp;\u0026amp; inStream-\u0026gt;codecpar-\u0026gt;codec_type != AVMEDIA_TYPE_AUDIO \u0026amp;\u0026amp; inStream-\u0026gt;codecpar-\u0026gt;codec_type != AVMEDIA_TYPE_SUBTITLE) { // ä¸å¤„ç†è¯¥æµ handleStreamIndexArray[i] = -1; continue; } handleStreamIndexArray[i] = streamIndex++; // åˆ›å»ºæ–°çš„è¾“å‡ºæµ AVStream *outStream = NULL; // åœ¨è¾“å‡ºæ–‡ä»¶ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„æµ outStream = avformat_new_stream(outFmtCtx, NULL); if (outStream == NULL) { ret = -1; av_log(NULL, AV_LOG_ERROR, \u0026#34;new output stream failed\\n\u0026#34;); goto fail; } // å¤åˆ¶ç¼–è§£ç å™¨å‚æ•° avcodec_parameters_copy(outStream-\u0026gt;codecpar, inStream-\u0026gt;codecpar); // è®¾ç½®è¾“å‡ºæµçš„ç¼–è§£ç å™¨æ ‡ç­¾ä¸º0 outStream-\u0026gt;codecpar-\u0026gt;codec_tag = 0; } // åˆ¤æ–­outFmtCtx-\u0026gt;oformat-\u0026gt;flagsæ˜¯å¦åŒ…å«AVFMT_NOFILEæ ‡å¿— [\u0026amp;è§£é‡Šï¼ˆç‚¹å‡»è·³è½¬ï¼‰](https://www.notion.so/if-outFmtCtx-oformat-flags-AVFMT_NOFILE-1187c25c79d08036bde1c286d0b3c943?pvs=21) if (!(outFmtCtx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { // ä»¥å†™å…¥æ¨¡å¼æ‰“å¼€ ret = avio_open(\u0026amp;outFmtCtx-\u0026gt;pb, outFileName, AVIO_FLAG_WRITE); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open output file failed:%s\\n\u0026#34;, outFileName); goto fail; } } // å°†è¾“å‡ºæ–‡ä»¶çš„å¤´éƒ¨ä¿¡æ¯å†™å…¥åˆ°è¾“å‡ºæ–‡ä»¶ä¸­ ret = avformat_write_header(outFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;write header failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } AVPacket *packet = av_packet_alloc(); // è¯»å–è¾“å…¥æ–‡ä»¶çš„æ•°æ®åŒ… while (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index \u0026gt;= streamCount || handleStreamIndexArray[packet-\u0026gt;stream_index == -1]) { av_packet_unref(packet); } // è·å–è¾“å…¥è¾“å‡ºæ–‡ä»¶ä¸­å¯¹åº”æµç´¢å¼•çš„æµ AVStream *inStream = inFmtCtx-\u0026gt;streams[packet-\u0026gt;stream_index]; AVStream *outStream = outFmtCtx-\u0026gt;streams[packet-\u0026gt;stream_index]; packet-\u0026gt;stream_index = handleStreamIndexArray[packet-\u0026gt;stream_index]; packet-\u0026gt;pts = av_rescale_q(packet-\u0026gt;pts, inStream-\u0026gt;time_base, outStream-\u0026gt;time_base); packet-\u0026gt;dts = av_rescale_q(packet-\u0026gt;dts, inStream-\u0026gt;time_base, outStream-\u0026gt;time_base); packet-\u0026gt;duration = av_rescale_q(packet-\u0026gt;duration, inStream-\u0026gt;time_base, outStream-\u0026gt;time_base); // å°†æ•°æ®åŒ…çš„ä½ç½®è®¾ç½®ä¸º-1 packet-\u0026gt;pos = -1; ret = av_interleaved_write_frame(outFmtCtx, packet); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;write interleaved failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } av_packet_unref(packet); } ret = av_write_trailer(outFmtCtx); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;write trailer failed :%s\\n\u0026#34;, av_err2str(ret)); } fail: if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } if (outFmtCtx \u0026amp;\u0026amp; !(outFmtCtx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { avio_closep(\u0026amp;outFmtCtx-\u0026gt;pb); } if (outFmtCtx) { avformat_free_context(outFmtCtx); } if (handleStreamIndexArray) { av_freep(\u0026amp;handleStreamIndexArray); } return ret; } æˆªå–å°è£…æ–‡ä»¶ æ—¶é—´åŸºä¸æ—¶é—´æˆ³ æ—¶é—´åŸºï¼šæ—¶é—´åˆ»åº¦ï¼Œè¡¨ç¤ºæ¯ä¸ªåˆ»åº¦å¤šå°‘ç§’ï¼ˆå°±åƒä¸€æŠŠå°ºå­çš„åˆ»åº¦ï¼‰\næ—¶é—´æˆ³ï¼šè¡¨ç¤ºå å¤šå°‘ä¸ªæ—¶é—´åˆ»åº¦ï¼Œå•ä½ä¸æ˜¯ç§’ï¼Œè€Œæ˜¯æ—¶é—´åˆ»åº¦ï¼ˆå¤šå°‘å¤šå°‘cmï¼‰\næ—¶é—´åŸºå’Œæ—¶é—´æˆ³ç›¸ä¹˜å°±æ˜¯æ—¶é—´\nPTSï¼šæ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œåœ¨ä»€ä¹ˆæ—¶å€™å¼€å§‹æ˜¾ç¤ºè¿™ä¸€å¸§æ•°æ®ï¼Œè½¬æˆæ—¶é—´ï¼šPTS * æ—¶é—´åŸº\nDTSï¼šè§£ç æ—¶é—´æˆ³ï¼Œåœ¨ä»€ä¹ˆæ—¶å€™å¼€å§‹è§£ç è¿™ä¸€å¸§æ•°æ®ï¼Œè½¬æˆæ—¶é—´ï¼šDTS * æ—¶é—´åŸº\næµç¨‹ æˆªå–å°è£…æ–‡ä»¶å¤„ç†æµç¨‹å’Œè½¬å°è£…æµç¨‹å‡ ä¹ä¸€æ ·ï¼Œåªæ˜¯å¤šäº†ä¸€ä¸ªè·³è½¬æŒ‡å®šæ—¶é—´æˆ³çš„æ­¥éª¤ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†æµç¨‹ï¼š\næ­¥éª¤ å¯¹åº”å‡½æ•° 1. æ‰“å¼€è¾“å…¥åª’ä½“æ–‡ä»¶ avformat_open_input 2. è·å–è¾“å…¥æµä¿¡æ¯ avformat_find_stream_info 3. åˆ›å»ºè¾“å‡ºæµä¸Šä¸‹æ–‡ avformat_alloc_output_context2 4. åˆ›å»ºè¾“å‡ºç æµçš„AVStream avformat_new_stream 5. æ‹·è´ç¼–ç å‚æ•° avcodec_parameters_copy 6. å†™å…¥è§†é¢‘æ–‡ä»¶å¤´ avformat_write_header 7. è¯»å–è¾“å…¥è§†é¢‘æµ av_read_frame 8. è·³è½¬æŒ‡å®šæ—¶é—´æˆ³ av_seek_frame 9. è®¡ç®—pts/dts/duration av_rescale_q_rnd/av_rescale_q 10. å†™å…¥è§†é¢‘æµæ•°æ® av_interleaved_write_frame 11. å†™å…¥è§†é¢‘æ–‡ä»¶æœ«å°¾ av_write_trailer ä»£ç  demuxing_dir.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; int main(int argc, char **argv) { // è®¾ç½®æ—¥å¿—çº§åˆ« av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage:%s \u0026lt;infileName\u0026gt;\\n\u0026#34;, argv[0]); } const char *inFileName = argv[1]; // æ‰“å¼€è¾“å…¥æ–‡ä»¶ AVFormatContext *inFmtCtx = NULL; // ç”¨äºå­˜å‚¨è¾“å…¥æ–‡ä»¶çš„æ ¼å¼ä¿¡æ¯ avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); // æ‰“å¼€è¾“å…¥æ–‡ä»¶inFileNameï¼Œå¹¶å°†æ ¼å¼ä¿¡æ¯å­˜å‚¨åœ¨inFmtCtxä¸­ avformat_find_stream_info(inFmtCtx, NULL); // æŸ¥æ‰¾è¾“å…¥æ–‡ä»¶çš„æµä¿¡æ¯ï¼Œå¹¶å°†æµä¿¡æ¯å­˜å‚¨åœ¨inFmtCtxä¸­ av_dump_format(inFmtCtx, 0, inFileName, 0); // æ‰“å°è¾“å…¥æ–‡ä»¶inFileNameçš„æ ¼å¼ä¿¡æ¯ av_log(NULL, AV_LOG_INFO, \u0026#34;input file duration:%ld us, %lf s \\n\u0026#34;, inFmtCtx-\u0026gt;duration, inFmtCtx-\u0026gt;duration * av_q2d(AV_TIME_BASE_Q)); // æ‰“å°è¾“å…¥æ–‡ä»¶çš„æ€»æ—¶é•¿ï¼Œå•ä½ä¸ºå¾®ç§’å’Œç§’ AV_TIME_BASE_Qæ˜¯ffmpegå†…éƒ¨çš„æ—¶é—´åŸºï¼Œå€¼ä¸º{1, AV_TIME_BASE}ï¼ŒAV_TIME_BASEçš„å€¼ä¸º1000000ï¼Œå³1ç§’ // AVRationalæ˜¯ffmpegå†…éƒ¨çš„æ—¶é—´åŸºï¼Œå€¼ä¸º{num, den}ï¼Œnumä¸ºåˆ†å­ï¼Œdenä¸ºåˆ†æ¯ AVRational videoTimeBase; AVRational audioTimeBase; for (int i = 0; i \u0026lt; inFmtCtx-\u0026gt;nb_streams; i++) // éå†è¾“å…¥æ–‡ä»¶ä¸­çš„æ‰€æœ‰æµ { AVStream *inStream = inFmtCtx-\u0026gt;streams[i]; // è·å–è¾“å…¥æ–‡ä»¶ä¸­çš„ç¬¬iä¸ªæµ // åˆ†åˆ«åˆ¤æ–­æ˜¯å¦ä¸ºéŸ³é¢‘æˆ–è§†é¢‘æµ if (inStream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { videoTimeBase = inStream-\u0026gt;time_base; av_log(NULL, AV_LOG_INFO, \u0026#34;video timebase:num = %d,den = %d\\n\u0026#34;, videoTimeBase.num, videoTimeBase.den); } else if (inStream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_AUDIO) { audioTimeBase = inStream-\u0026gt;time_base; av_log(NULL, AV_LOG_INFO, \u0026#34;audio timebase:num = %d,den = %d\\n\u0026#34;, audioTimeBase.num, audioTimeBase.den); } } AVPacket *packet = av_packet_alloc(); // åˆ†é…ä¸€ä¸ªAVPacketç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç åçš„æ•°æ® while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) // å¾ªç¯è¯»å–è¾“å…¥æ–‡ä»¶ä¸­çš„æ¯ä¸ªæ•°æ®åŒ…ï¼Œå¹¶å°†æ•°æ®åŒ…å­˜å‚¨åœ¨packetä¸­ { AVStream *inStream = inFmtCtx-\u0026gt;streams[packet-\u0026gt;stream_index]; // è·å–å½“å‰æ•°æ®åŒ…æ‰€å±çš„æµ av_log(NULL, AV_LOG_INFO, \u0026#34;streamIndex = %d,pts = %ld,ptsTime = %lf,dts = %ld,dtsTime = %lf\\n\u0026#34;, packet-\u0026gt;stream_index, packet-\u0026gt;pts, packet-\u0026gt;pts * av_q2d(inStream-\u0026gt;time_base), packet-\u0026gt;dts, packet-\u0026gt;dts * av_q2d(inStream-\u0026gt;time_base)); // æ‰“å°å½“å‰æ•°æ®åŒ…çš„æµç´¢å¼•ã€ptsã€ptsæ—¶é—´ã€dtsã€dtsæ—¶é—´ } return 0; } è§†é¢‘è§£ç  å¦‚ä½•ä½¿ç”¨ffmpegæ¥å£å¯¹è§†é¢‘è§£ç \nRGBä»‹ç» ä¸‰åŸè‰²ï¼šRGBè‰²å½©æ¨¡å¼æ˜¯å·¥ä¸šç•Œçš„ä¸€ç§é¢œè‰²æ ‡å‡†ï¼Œæ˜¯é€šè¿‡å¯¹çº¢(R)ã€ç»¿(G)ã€è“(B)ä¸‰ä¸ªé¢œè‰²é€šé“çš„å˜åŒ–ä»¥åŠå®ƒä»¬ç›¸äº’ä¹‹é—´çš„å åŠ æ¥å¾—åˆ°å„å¼å„æ ·çš„é¢œè‰²çš„ï¼ŒRGBå³æ˜¯ä»£è¡¨çº¢ã€ç»¿ã€è“ä¸‰ä¸ªé€šé“çš„é¢œè‰²ï¼Œè¿™ä¸ªæ ‡å‡†å‡ ä¹åŒ…æ‹¬äº†äººç±»è§†åŠ›æ‰€èƒ½æ„ŸçŸ¥çš„æ‰€æœ‰é¢œè‰²ï¼Œæ˜¯ç›®å‰è¿ç”¨æœ€å¹¿çš„é¢œè‰²ç³»ç»Ÿä¹‹ä¸€ã€‚\næ˜¾ç¤ºå™¨ï¼šä½¿ç”¨RGBä¸‰ç§é¢œè‰²çš„å‘å…‰ä½“ä½œä¸ºåŸºæœ¬å‘å…‰å•å…ƒ\nåˆ†è¾¨ç‡ï¼šæ‰‹æœºå±å¹•åˆ†è¾¨ç‡æ˜¯1280*720ï¼Œè¡¨ç¤ºå±å¹•ä¸Šæœ‰1280*720ä¸ªåƒç´ ç‚¹ï¼Œæ¯ä¸ªåƒç´ ç‚¹ç”±RGBä¸‰ç§é¢œè‰²ç»„æˆ\nRGBæ ¼å¼ è°ƒè‰²ç‰ˆï¼šé€šè¿‡ç¼–å·æ˜ å°„åˆ°é¢œè‰²çš„ä¸€å¼ äºŒç»´è¡¨ï¼Œå¦‚01ç´¢å¼•ï¼Œè¡¨ç¤ºçº¢è‰² ç´¢å¼•æ ¼å¼ï¼š RGB1ã€RGB4ã€RGB8 æ˜¯è®¡ç®—æœºå›¾å½¢å­¦ä¸­å¸¸è§çš„é¢œè‰²ç¼–ç æ ¼å¼ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸åŒçš„é¢œè‰²æ·±åº¦å’Œå­˜å‚¨æ–¹å¼ã€‚ä»¥ä¸‹æ˜¯å¯¹è¿™äº›æ ¼å¼çš„è§£é‡Šï¼š\nRGB1ï¼š\né¢œè‰²æ·±åº¦ï¼š1ä½ï¼ˆbitï¼‰ã€‚ é¢œè‰²æ•°é‡ï¼š2ç§é¢œè‰²ï¼ˆé€šå¸¸æ˜¯é»‘è‰²å’Œç™½è‰²ï¼‰ã€‚ åº”ç”¨åœºæ™¯ï¼šå¸¸ç”¨äºæ—©æœŸçš„å•è‰²æ˜¾ç¤ºå™¨æˆ–ç®€å•çš„å›¾å½¢ç•Œé¢ï¼Œå¦‚æ–‡æœ¬æ¨¡å¼ä¸‹çš„æ˜¾ç¤ºã€‚ RGB4ï¼š\né¢œè‰²æ·±åº¦ï¼š4ä½ï¼ˆbitï¼‰ã€‚ é¢œè‰²æ•°é‡ï¼š16ç§é¢œè‰²ã€‚ åº”ç”¨åœºæ™¯ï¼šå¸¸ç”¨äºæ—©æœŸçš„å½©è‰²æ˜¾ç¤ºå™¨æˆ–ä½åˆ†è¾¨ç‡å›¾å½¢ç•Œé¢ï¼Œå¦‚æ—©æœŸçš„è®¡ç®—æœºæ¸¸æˆæˆ–ç®€å•çš„å›¾å½¢åº”ç”¨ç¨‹åºã€‚ RGB8ï¼š\né¢œè‰²æ·±åº¦ï¼š8ä½ï¼ˆbitï¼‰ã€‚ é¢œè‰²æ•°é‡ï¼š256ç§é¢œè‰²ã€‚ åº”ç”¨åœºæ™¯ï¼šå¸¸ç”¨äºæ—©æœŸçš„å½©è‰²æ˜¾ç¤ºå™¨æˆ–ä½åˆ†è¾¨ç‡å›¾å½¢ç•Œé¢ï¼Œå¦‚æ—©æœŸçš„è®¡ç®—æœºæ¸¸æˆã€ç½‘é¡µè®¾è®¡ä¸­çš„è°ƒè‰²æ¿æ¨¡å¼ç­‰ã€‚ è¿™äº›æ ¼å¼åœ¨ç°ä»£è®¡ç®—æœºå›¾å½¢å¤„ç†ä¸­å·²ç»è¾ƒå°‘ä½¿ç”¨ï¼Œä½†åœ¨æŸäº›ç‰¹å®šçš„åº”ç”¨åœºæ™¯æˆ–å†å²ç ”ç©¶ä¸­ä»ç„¶å…·æœ‰å‚è€ƒä»·å€¼ã€‚ åƒç´ æ ¼å¼ï¼šã€‚ã€‚ã€‚ï¼ˆåç»­è§‰å¾—æœ‰å¿…è¦å†è¡¥ä¸Šï¼‰\nå‘½ä»¤\nffmpegå‘½ä»¤å°†å›¾ç‰‡è½¬RGBæ•°æ®\n1 ffmpeg -i input.png -pix_fmt rgb24 output.rgb æ³¨æ„è¾“å‡ºä¿¡æ¯ä¸­ä¼šè¾“å‡ºå›¾ç‰‡å¤§å°ï¼Œä¸‹é¢çš„ffplayéœ€è¦ç”¨\n1 Stream #0:0: Video: png, rgba(pc, gbr/bt709/iec61966-2-1), 1920x1200 [SAR 5669:5669 DAR 8:5], 25 fps, 25 tbr, 25 tbn ffplayå‘½ä»¤æ’­æ”¾RGBæ•°æ®\n1 ffplay -f output.rgb -pix_fmt rgb24 -s widthxheight output.rgb å…¶ä¸­ï¼Œwidth å’Œ height æ˜¯å›¾ç‰‡çš„å®½åº¦å’Œé«˜åº¦ï¼Œæ˜¯å¿…è¦çš„ä¿¡æ¯ã€‚\né€šè¿‡è§£ç ï¼Œä¼šå‘ç°ç…§ç‰‡å†…å­˜æ˜æ˜¾å˜å¤§ï¼Œå› ä¸ºRGBæ ¼å¼å­˜å‚¨äº†æ›´å¤šçš„é¢œè‰²ä¿¡æ¯ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹ç…§ç‰‡è¿›è¡Œç¼–ç \nTODOå®Œå–„\nYUVä»‹ç» YUV æ˜¯ä¸€ç§é¢œè‰²ç¼–ç ç³»ç»Ÿï¼Œå¸¸ç”¨äºè§†é¢‘å’Œå›¾åƒå¤„ç†ä¸­ã€‚Y ä»£è¡¨äº®åº¦ï¼ˆLuminanceï¼‰ï¼ŒU å’Œ V ä»£è¡¨è‰²åº¦ï¼ˆChrominanceï¼‰ã€‚YUV æ ¼å¼æœ‰å¤šç§å˜ä½“ï¼Œå¦‚ YUV420ã€YUV422ã€YUV444 ç­‰ã€‚\næµç¨‹ å‡½æ•°å æè¿° av_find_best_stream åœ¨åª’ä½“æ–‡ä»¶ä¸­æŸ¥æ‰¾æœ€ä½³æµ avcodec_alloc_context3 åˆ†é…ä¸€ä¸ªç¼–è§£ç å™¨ä¸Šä¸‹æ–‡ avcodec_parameters_to_context å¤åˆ¶ç¼–è§£ç å™¨å‚æ•° avcodec_find_decoder æŸ¥æ‰¾å¹¶è·å–è§†é¢‘è§£ç å™¨ avcodec_open2 æ‰“å¼€è§£ç å™¨ä¸Šä¸‹æ–‡ï¼Œå¹¶ä¸æŒ‡å®šçš„è§£ç å™¨å…³è” av_read_frame è¯»å–å¸§ avcodec_send_packet å‘é€æ•°æ®åŒ…åˆ°è§£ç å™¨ avcodec_receive_frame ä»è§£ç å™¨æ¥æ”¶å¸§ è¾“å…¥æŒ‡ä»¤\n1 2 ./demoBin ../video/test.mp4 test.yuv ffplay test.yuv -video_size 720x1280 -pixel_format yuv420p å¦‚æœæ’­æ”¾çš„è§†é¢‘ä¹±ç ï¼Œä¸»è¦æ˜¯ç”±äºwidthå’Œlinesizeå¤§å°ä¸ä¸€æ · åç»­çš„æ›´æ”¹è§†é¢‘æ ¼å¼çš„æ—¶å€™ä¼šè§£å†³è¿™ä¸ªé—®é¢˜\nä»£ç  decodeVideo.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavcodec/avcodec.h\u0026#34; // å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œç”¨äºè®°å½•è§£ç çš„å¸§æ•° int frameCount = 0; // è§£ç è§†é¢‘å¸§çš„å‡½æ•° int decodeVideo(AVCodecContext *codecCtx, AVPacket *packet, FILE *dest_fp) { // å°†æ•°æ®åŒ…å‘é€åˆ°è§£ç å™¨ int ret = avcodec_send_packet(codecCtx, packet); if (ret != 0) { // å¦‚æœå‘é€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not send packet:%s\\n\u0026#34;, av_err2str(ret)); return -1; } // åˆ†é…ä¸€ä¸ªAVFrameç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç åçš„å¸§æ•°æ® AVFrame *frame = av_frame_alloc(); // å¾ªç¯æ¥æ”¶è§£ç åçš„å¸§æ•°æ® while (avcodec_receive_frame(codecCtx, frame) == 0) { // å°†å¸§æ•°æ®å†™å…¥è¾“å‡ºæ–‡ä»¶ fwrite(frame-\u0026gt;data[0], 1, codecCtx-\u0026gt;width * codecCtx-\u0026gt;height, dest_fp); fwrite(frame-\u0026gt;data[1], 1, codecCtx-\u0026gt;width * codecCtx-\u0026gt;height / 4, dest_fp); fwrite(frame-\u0026gt;data[2], 1, codecCtx-\u0026gt;width * codecCtx-\u0026gt;height / 4, dest_fp); // å¢åŠ å¸§è®¡æ•° frameCount++; // è®°å½•å½“å‰å¸§æ•° av_log(NULL, AV_LOG_INFO, \u0026#34;frameCount:%d\\n\u0026#34;, frameCount); } // å¦‚æœå¸§æ•°æ®ä¸ä¸ºç©ºï¼Œé‡Šæ”¾å¸§å†…å­˜ if (frame) { av_frame_free(\u0026amp;frame); } return 0; } int main(int argc, char **argv) { // è®¾ç½®æ—¥å¿—çº§åˆ«ä¸ºè°ƒè¯•æ¨¡å¼ av_log_set_level(AV_LOG_DEBUG); // æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°æ˜¯å¦æ­£ç¡® if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); return -1; } // è·å–è¾“å…¥å’Œè¾“å‡ºæ–‡ä»¶å const char *inFileName = argv[1]; const char *outFileName = argv[2]; // å®šä¹‰ä¸€ä¸ªAVFormatContextç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è¾“å…¥æ–‡ä»¶çš„æ ¼å¼ä¿¡æ¯ AVFormatContext *inFmtCtx = NULL; // æ‰“å¼€è¾“å…¥æ–‡ä»¶ int ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret != 0) { // å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open input file %s\\n\u0026#34;, inFileName); return -1; } // è·å–è¾“å…¥æ–‡ä»¶çš„æµä¿¡æ¯ ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { // å¦‚æœè·å–å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find stream information:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // æŸ¥æ‰¾æœ€ä½³çš„è§†é¢‘æµç´¢å¼• ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find best stream index:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // è·å–è§†é¢‘æµçš„ç´¢å¼• int videoIndex = ret; // åˆ†é…ä¸€ä¸ªAVCodecContextç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç å™¨ä¸Šä¸‹æ–‡ä¿¡æ¯ AVCodecContext *codecCtx = avcodec_alloc_context3(NULL); if (codecCtx == NULL) { // å¦‚æœåˆ†é…å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate codec context\\n\u0026#34;); ret = -1; goto fail; } // å°†æµå‚æ•°å¤åˆ¶åˆ°è§£ç å™¨ä¸Šä¸‹æ–‡ avcodec_parameters_to_context(codecCtx, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); // æŸ¥æ‰¾è§£ç å™¨ const AVCodec *decoder = avcodec_find_decoder(codecCtx-\u0026gt;codec_id); if (decoder == NULL) { // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find codec\\n\u0026#34;); ret = -1; goto fail; } // æ‰“å¼€è§£ç å™¨ ret = avcodec_open2(codecCtx, decoder, NULL); if (ret != 0) { // å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open codec:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // æ‰“å¼€è¾“å‡ºæ–‡ä»¶ FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { // å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open output file %s\\n\u0026#34;, outFileName); ret = -1; goto fail; } // åˆ†é…ä¸€ä¸ªAVPacketç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨æ•°æ®åŒ… AVPacket *packet = av_packet_alloc(); // åˆ†é…ä¸€ä¸ªAVFrameç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç åçš„å¸§æ•°æ® AVFrame *frame = av_frame_alloc(); // å¾ªç¯è¯»å–è¾“å…¥æ–‡ä»¶ä¸­çš„æ•°æ®åŒ… while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) { // å¦‚æœæ•°æ®åŒ…å±äºè§†é¢‘æµff if (packet-\u0026gt;stream_index == videoIndex) { // è§£ç è§†é¢‘å¸§ if (decodeVideo(codecCtx, packet, dest_fp) == -1) { ret = -1; av_packet_unref(packet); goto fail; } // é‡Šæ”¾æ•°æ®åŒ…å¼•ç”¨ av_packet_unref(packet); } } // åˆ·æ–°è§£ç å™¨ï¼Œç¡®ä¿æ‰€æœ‰å¸§éƒ½è¢«è§£ç  decodeVideo(codecCtx, NULL, dest_fp); fail: // å¦‚æœè¾“å…¥æ–‡ä»¶æ ¼å¼ä¸Šä¸‹æ–‡ä¸ä¸ºç©ºï¼Œå…³é—­è¾“å…¥æ–‡ä»¶ if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } // å¦‚æœè§£ç å™¨ä¸Šä¸‹æ–‡ä¸ä¸ºç©ºï¼Œé‡Šæ”¾è§£ç å™¨ä¸Šä¸‹æ–‡ if (codecCtx) { avcodec_free_context(\u0026amp;codecCtx); } // å¦‚æœè¾“å‡ºæ–‡ä»¶æŒ‡é’ˆä¸ä¸ºç©ºï¼Œå…³é—­è¾“å‡ºæ–‡ä»¶ if (dest_fp) { fclose(dest_fp); } return ret; } æ›´æ”¹è§†é¢‘æ ¼å¼ æµç¨‹ å‡½æ•°å æè¿° av_parse_video_size è§£æè§†é¢‘å°ºå¯¸å­—ç¬¦ä¸²ï¼ˆå¦‚ \u0026ldquo;1920x1080\u0026rdquo;ï¼‰å¹¶è¿”å›å®½åº¦å’Œé«˜åº¦ã€‚ sws_getContext åˆ›å»ºä¸€ä¸ª SwsContextï¼Œç”¨äºå›¾åƒç¼©æ”¾å’Œæ ¼å¼è½¬æ¢ã€‚ av_frame_alloc åˆ†é…ä¸€ä¸ª AVFrame ç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç åçš„è§†é¢‘å¸§ã€‚ av_image_get_buffer_size è®¡ç®—ç»™å®šå›¾åƒæ ¼å¼å’Œå°ºå¯¸æ‰€éœ€çš„ç¼“å†²åŒºå¤§å°ã€‚ av_malloc åˆ†é…å†…å­˜ï¼Œç”¨äºå­˜å‚¨å›¾åƒæ•°æ®ã€‚ av_image_fill_arrays å°†å›¾åƒæ•°æ®å¡«å……åˆ° AVFrame çš„ç¼“å†²åŒºä¸­ï¼Œå¹¶è®¾ç½®ç›¸å…³çš„è¡Œå¤§å°å’Œæ•°æ®æŒ‡é’ˆã€‚ sws_scale ä½¿ç”¨ SwsContext å¯¹å›¾åƒè¿›è¡Œç¼©æ”¾æˆ–æ ¼å¼è½¬æ¢ã€‚ ä»£ç  decodeVideoChange.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026#34;libavutil/parseutils.h\u0026#34; #include \u0026#34;libavutil/imgutils.h\u0026#34; // å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œç”¨äºè®°å½•è§£ç çš„å¸§æ•° int frameCount = 0; // è§£ç è§†é¢‘å¸§çš„å‡½æ•° int decodeVideo(AVCodecContext *codecCtx, AVPacket *packet, struct SwsContext *swsCtx, int destWidth, int destHeight, AVFrame *destFrame, FILE *dest_fp) { // å°†æ•°æ®åŒ…å‘é€åˆ°è§£ç å™¨ int ret = avcodec_send_packet(codecCtx, packet); if (ret != 0) { // å¦‚æœå‘é€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not send packet:%s\\n\u0026#34;, av_err2str(ret)); return -1; } // åˆ†é…ä¸€ä¸ªAVFrameç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç åçš„å¸§æ•°æ® AVFrame *frame = av_frame_alloc(); // å¾ªç¯æ¥æ”¶è§£ç åçš„å¸§æ•°æ® while (avcodec_receive_frame(codecCtx, frame) == 0) { sws_scale(swsCtx, (const uint8_t *const*)frame-\u0026gt;data, frame-\u0026gt;linesize, 0, codecCtx-\u0026gt;height, destFrame-\u0026gt;data, destFrame-\u0026gt;linesize); // å°†å¸§æ•°æ®å†™å…¥è¾“å‡ºæ–‡ä»¶ fwrite(destFrame-\u0026gt;data[0], 1, destWidth * destHeight, dest_fp); fwrite(destFrame-\u0026gt;data[1], 1, destWidth * destHeight / 4, dest_fp); fwrite(destFrame-\u0026gt;data[2], 1, destWidth * destHeight / 4, dest_fp); // å¢åŠ å¸§è®¡æ•° frameCount++; // è®°å½•å½“å‰å¸§æ•° av_log(NULL, AV_LOG_INFO, \u0026#34;frameCount:%d\\n\u0026#34;, frameCount); // è¾“å‡ºå®½é«˜ä¿¡æ¯,linesize0 1 2 av_log(NULL, AV_LOG_INFO, \u0026#34;width:%d,height:%d,linesize0:%d,linesize1:%d,linesize2:%d\\n\u0026#34;, destWidth, destHeight, destFrame-\u0026gt;linesize[0], destFrame-\u0026gt;linesize[1], destFrame-\u0026gt;linesize[2]); } // å¦‚æœå¸§æ•°æ®ä¸ä¸ºç©ºï¼Œé‡Šæ”¾å¸§å†…å­˜ if (frame) { av_frame_free(\u0026amp;frame); } return 0; } int main(int argc, char **argv) { // è®¾ç½®æ—¥å¿—çº§åˆ«ä¸ºè°ƒè¯•æ¨¡å¼ av_log_set_level(AV_LOG_DEBUG); // æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°æ˜¯å¦æ­£ç¡® if (argc \u0026lt; 4) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt; \u0026lt;width*height\u0026gt;\\n\u0026#34;, argv[0]); return -1; } // è·å–è¾“å…¥å’Œè¾“å‡ºæ–‡ä»¶å const char *inFileName = argv[1]; const char *outFileName = argv[2]; const char *destVideoSizeString = argv[3]; int destWidth = 0, destHeight = 0; int ret = av_parse_video_size(\u0026amp;destWidth, \u0026amp;destHeight, destVideoSizeString); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;invalid video size:%s\\n\u0026#34;, destVideoSizeString); return -1; } av_log(NULL, AV_LOG_INFO, \u0026#34;destWith:%d,destHeight:%d\\n\u0026#34;, destWidth, destHeight); // å®šä¹‰ä¸€ä¸ªAVFormatContextç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è¾“å…¥æ–‡ä»¶çš„æ ¼å¼ä¿¡æ¯ AVFormatContext *inFmtCtx = NULL; // æ‰“å¼€è¾“å…¥æ–‡ä»¶ ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret != 0) { // å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open input file %s\\n\u0026#34;, inFileName); return -1; } // è·å–è¾“å…¥æ–‡ä»¶çš„æµä¿¡æ¯ ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { // å¦‚æœè·å–å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find stream information:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // æŸ¥æ‰¾æœ€ä½³çš„è§†é¢‘æµç´¢å¼• ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find best stream index:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // è·å–è§†é¢‘æµçš„ç´¢å¼• int videoIndex = ret; // åˆ†é…ä¸€ä¸ªAVCodecContextç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç å™¨ä¸Šä¸‹æ–‡ä¿¡æ¯ AVCodecContext *codecCtx = avcodec_alloc_context3(NULL); if (codecCtx == NULL) { // å¦‚æœåˆ†é…å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate codec context\\n\u0026#34;); ret = -1; goto fail; } // å°†æµå‚æ•°å¤åˆ¶åˆ°è§£ç å™¨ä¸Šä¸‹æ–‡ avcodec_parameters_to_context(codecCtx, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); // æŸ¥æ‰¾è§£ç å™¨ const AVCodec *decoder = avcodec_find_decoder(codecCtx-\u0026gt;codec_id); if (decoder == NULL) { // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find codec\\n\u0026#34;); ret = -1; goto fail; } // æ‰“å¼€è§£ç å™¨ ret = avcodec_open2(codecCtx, decoder, NULL); if (ret != 0) { // å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open codec:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } enum AVPixelFormat destPixfmt = codecCtx-\u0026gt;pix_fmt; struct SwsContext *swsCtx = sws_getContext(codecCtx-\u0026gt;width, codecCtx-\u0026gt;height, codecCtx-\u0026gt;pix_fmt, destWidth, destHeight, destPixfmt, SWS_BICUBIC, NULL, NULL, NULL); if (swsCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not create SwsContext\\n\u0026#34;); ret = -1; goto fail; } AVFrame *destFrame = av_frame_alloc(); uint8_t *outBuffer = av_malloc(av_image_get_buffer_size(destPixfmt, destWidth, destHeight, 1)); av_image_fill_arrays(destFrame-\u0026gt;data, destFrame-\u0026gt;linesize, outBuffer, destPixfmt, destWidth, destHeight, 1); // æ‰“å¼€è¾“å‡ºæ–‡ä»¶ FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { // å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open output file %s\\n\u0026#34;, outFileName); ret = -1; goto fail; } // åˆ†é…ä¸€ä¸ªAVPacketç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨æ•°æ®åŒ… AVPacket *packet = av_packet_alloc(); // åˆ†é…ä¸€ä¸ªAVFrameç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨è§£ç åçš„å¸§æ•°æ® AVFrame *frame = av_frame_alloc(); // å¾ªç¯è¯»å–è¾“å…¥æ–‡ä»¶ä¸­çš„æ•°æ®åŒ… while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) { // å¦‚æœæ•°æ®åŒ…å±äºè§†é¢‘æµ if (packet-\u0026gt;stream_index == videoIndex) { // è§£ç è§†é¢‘å¸§ // if (decodeVideo(codecCtx, packet, dest_fp) == -1) if (decodeVideo(codecCtx, packet, swsCtx, destWidth, destHeight, destFrame, dest_fp) == -1) { ret = -1; av_packet_unref(packet); goto fail; } // é‡Šæ”¾æ•°æ®åŒ…å¼•ç”¨ av_packet_unref(packet); } } // åˆ·æ–°è§£ç å™¨ï¼Œç¡®ä¿æ‰€æœ‰å¸§éƒ½è¢«è§£ç  // decodeVideo(codecCtx, NULL, dest_fp); decodeVideo(codecCtx, NULL, swsCtx, destWidth, destHeight, destFrame, dest_fp); fail: // å¦‚æœè¾“å…¥æ–‡ä»¶æ ¼å¼ä¸Šä¸‹æ–‡ä¸ä¸ºç©ºï¼Œå…³é—­è¾“å…¥æ–‡ä»¶ if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } // å¦‚æœè§£ç å™¨ä¸Šä¸‹æ–‡ä¸ä¸ºç©ºï¼Œé‡Šæ”¾è§£ç å™¨ä¸Šä¸‹æ–‡ if (codecCtx) { avcodec_free_context(\u0026amp;codecCtx); } // å¦‚æœè¾“å‡ºæ–‡ä»¶æŒ‡é’ˆä¸ä¸ºç©ºï¼Œå…³é—­è¾“å‡ºæ–‡ä»¶ if (dest_fp) { fclose(dest_fp); } if (destFrame) { av_frame_free(\u0026amp;destFrame); } if (outBuffer) { av_free(outBuffer); } return ret; } è§£ç åçš„æ•°æ®å­˜å‚¨ è§£ç åçš„è§†é¢‘æ•°æ®é€šå¸¸å­˜å‚¨åœ¨ data[0]ã€data[1]ã€data[2] ç­‰æ•°ç»„ä¸­ã€‚å…·ä½“æ¥è¯´ï¼š\ndata[0]: å­˜å‚¨äº† linesize[0] * height ä¸ªæ•°æ®ã€‚ data[1] å’Œ data[2]: å­˜å‚¨äº†å…¶ä»–å¹³é¢çš„æ•°æ®ï¼ˆå¦‚YUVæ ¼å¼ä¸­çš„Uå’ŒVå¹³é¢ï¼‰ã€‚ å†…å­˜å¯¹é½å’Œ linesize linesize[0]: å®é™…ä¸Šå¹¶ä¸ç­‰äºå›¾åƒçš„å®½åº¦ widthï¼Œè€Œæ˜¯æ¯”å®½åº¦å¤§ã€‚ è¿™ç§å·®å¼‚æ˜¯ç”±äºå†…å­˜å¯¹é½çš„éœ€æ±‚ï¼Œä»¥åŠè§£ç å™¨çš„CPUå’Œå…¶ä»–ä¼˜åŒ–åŸå› å¯¼è‡´çš„ã€‚ sws_scale å‡½æ•°åŠŸèƒ½ sws_scale å‡½æ•°æ˜¯ FFmpeg ä¸­ç”¨äºå›¾åƒç¼©æ”¾å’Œæ ¼å¼è½¬æ¢çš„æ ¸å¿ƒå‡½æ•°ã€‚å®ƒä¸»è¦å®Œæˆä»¥ä¸‹åŠŸèƒ½ï¼š\nå›¾åƒè‰²å½©ç©ºé—´è½¬æ¢ï¼š\nå°†å›¾åƒä»ä¸€ç§è‰²å½©ç©ºé—´è½¬æ¢ä¸ºå¦ä¸€ç§è‰²å½©ç©ºé—´ï¼Œä¾‹å¦‚ä» RGB è½¬æ¢ä¸º YUVï¼Œæˆ–è€…ä» YUV420P è½¬æ¢ä¸º YUV444Pã€‚ åˆ†è¾¨ç‡ç¼©æ”¾ï¼š\nè°ƒæ•´å›¾åƒçš„åˆ†è¾¨ç‡ï¼Œä¾‹å¦‚å°† 1920x1080 çš„å›¾åƒç¼©æ”¾åˆ° 1280x720ã€‚ å‰åå›¾åƒæ»¤æ³¢å¤„ç†ï¼š\nåœ¨è¿›è¡Œç¼©æ”¾å’Œè‰²å½©ç©ºé—´è½¬æ¢æ—¶ï¼Œåº”ç”¨æ»¤æ³¢å™¨ä»¥å¹³æ»‘å›¾åƒï¼Œå‡å°‘é”¯é½¿å’Œä¼ªå½±ã€‚ BMPæ–‡ä»¶æ ¼å¼ æ¦‚å¿µï¼šBMPæ–‡ä»¶æ ¼å¼ï¼Œåˆç§°ä¸ºBitmapï¼ˆä½å›¾ï¼‰æˆ–æ˜¯DIBï¼ˆDevice-Independent Deviceï¼Œè®¾å¤‡æ— å…‰ä½å›¾ï¼‰ï¼Œæ˜¯Windowsæ“ä½œç³»ç»Ÿä¸­çš„æ ‡å‡†å›¾åƒæ–‡ä»¶æ ¼å¼ã€‚ç”±äºå®ƒå¯ä»¥ä¸ä½œä»»ä½•å˜æ¢åœ°ä¿å­˜å›¾åƒåƒç´ åŸŸçš„æ•°æ®ï¼Œå› æ­¤æˆä¸ºæˆ‘ä»¬å–å¾—RAWæ•°æ®çš„å¥½æ¥æºã€‚\næ‰«ææ–¹å¼ï¼šä»å·¦åˆ°å³ï¼Œä»ä¸‹åˆ°ä¸Š\næ–‡ä»¶ç»„æˆï¼š\nä½å›¾æ–‡ä»¶å¤´ï¼ˆBitmap File Headerï¼‰ï¼šæä¾›æ–‡ä»¶çš„æ ¼å¼ï¼Œå¤§å°ç­‰ä¿¡æ¯ ä½å›¾ä¿¡æ¯å¤´ï¼ˆBitmap Informationï¼‰ï¼šæä¾›å›¾åƒçš„å°ºå¯¸ï¼Œä½å¹³é¢æ•°ï¼Œå‹ç¼©æ–¹å¼ï¼Œé¢œè‰²ç´¢å¼•ç­‰ä¿¡æ¯ã€‚ è°ƒè‰²æ¿ï¼ˆColor Paletteï¼‰ï¼šå¯é€‰ï¼Œæœ‰äº›ä½å›¾éœ€è¦è°ƒè‰²æ¿ï¼Œæœ‰äº›ä½å›¾ï¼Œæ¯”å¦‚çœŸå½©è‰²å›¾ï¼ˆ24ä½çš„BMPï¼‰å°±ä¸éœ€è¦è°ƒè‰²æ¿ã€‚ ä½å›¾æ•°æ®ï¼ˆBitmap Dataï¼‰ï¼šå›¾åƒæ•°æ®åŒº æ–‡ä»¶å¤´ç»“æ„ä½“ï¼š\n1 2 3 4 5 6 7 typedef struct tagBITMAPFILEHEADER { WORD bfType; // æ–‡ä»¶ç±»å‹ï¼Œå¿…é¡»æ˜¯0x424Dï¼Œå³å­—ç¬¦â€œBMâ€ DWORD bfSize; // bmpæ–‡ä»¶å¤§å° WORD bfReserved1; // ä¿ç•™å­— WORD bfReserved2; // ä¿ç•™å­— DWORD bfOffBits; // å®é™…ä½å›¾æ•°æ®çš„åç§»å­—èŠ‚æ•°ï¼Œå³å‰ä¸‰ä¸ªéƒ¨åˆ†é•¿åº¦ä¹‹å’Œ } BITMAPFILEHEADER; ä¿¡æ¯å¤´ç»“æ„ä½“ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct tagBITMAPINFOHEADER { DWORD biSize; //è¡¨ç¤ºstruct tagBITMAPINFOHEADERçš„é•¿åº¦ï¼Œè®¾ä¸º40 LONG biWidth; //bmpå›¾ç‰‡å®½åº¦ LONG biHeight; //bmpå›¾ç‰‡é«˜åº¦ WORD biPlanes; //bmpå›¾ç‰‡å¹³é¢æ ‘ï¼Œè®¾ä¸º1 WORD biBitCount; //bmpå›¾ç‰‡ä½æ•°ï¼Œå³1ä½å›¾ï¼Œ4ä½å›¾ï¼Œ8ä½å›¾ï¼Œ24ä½å›¾ç­‰ DWORD biCompression; //bmpå›¾ç‰‡å‹ç¼©ç±»å‹ï¼Œ0è¡¨ç¤ºä¸å‹ç¼© DWORD biSizeImage; //bmpå›¾ç‰‡æ•°æ®å¤§å°ï¼Œå¿…é¡»æ˜¯4çš„æ•´æ•°å€ LONG biXPelsPerMeter; //bmpå›¾ç‰‡æ°´å¹³åˆ†è¾¨ç‡ LONG biYPelsPerMeter; //bmpå›¾ç‰‡å‚ç›´åˆ†è¾¨ç‡ DWORD biClrUsed; //bmpå›¾ç‰‡å®é™…ä½¿ç”¨çš„é¢œè‰²è¡¨ä¸­çš„é¢œè‰²æ•° DWORD biClrImportant; //bmpå›¾ç‰‡å¯¹æ˜¾ç¤ºæœ‰é‡è¦å½±å“çš„é¢œè‰²ç´¢å¼•çš„æ•°ç›® } BITMAPINFOHEADER; è§†é¢‘ç¼–ç ï¼ˆyuvåˆ°h264ï¼‰ æµç¨‹ å‡½æ•°å æè¿° avcodec_find_encoder æŸ¥æ‰¾ç¼–ç å™¨ avcodec_alloc_context3 åˆ›å»ºç¼–ç å™¨ä¸Šä¸‹æ–‡ avcodec_open2 æ‰“å¼€ç¼–ç å™¨ av_frame_alloc åˆ†é…å¸§å†…å­˜ av_image_get_buffer_size è·å–å›¾åƒç¼“å†²åŒºå¤§å° av_image_fill_arrays å¡«å……å›¾åƒæ•°æ®æ•°ç»„ avcodec_send_frame å‘é€å¸§åˆ°ç¼–ç å™¨ avcodec_receive_packet ä»ç¼–ç å™¨æ¥æ”¶æ•°æ®åŒ… ä»£ç  encodeVideoDemo.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavutil/parseutils.h\u0026#34; #include \u0026lt;libavcodec/codec.h\u0026gt; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/imgutils.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;libavutil/rational.h\u0026gt; #include \u0026lt;time.h\u0026gt; int writePacketCount = 0; int encodeVideo(AVCodecContext *encoderCtx, AVFrame *frame, AVPacket *packet, FILE *dest_fp) { int ret = avcodec_send_frame(encoderCtx, frame); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;send frame error:%s\\n\u0026#34;, av_err2str(ret)); return -1; } while (ret \u0026gt;= 0) { avcodec_receive_packet(encoderCtx, packet); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { return 0; } else if (ret \u0026lt; 0) { av_log(NULL,AV_LOG_ERROR,\u0026#34;encoder frrame failed:%s\\n\u0026#34;,av_err2str(ret)); return -1; } fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); writePacketCount++; av_log(NULL,AV_LOG_INFO,\u0026#34;writePacketCount : %d\\n\u0026#34;,writePacketCount); av_packet_unref(packet); } } int main(int argc, char **argv) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 5) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;inFile\u0026gt; \u0026lt;outFile\u0026gt; \u0026lt;encodeName\u0026gt; \u0026lt;width x height\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFileName = argv[1]; const char *outFileName = argv[2]; const char *encoderName = argv[3]; int width = 0, height = 0; int ret = av_parse_video_size(\u0026amp;width, \u0026amp;height, argv[4]); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Invalid size \u0026#39;%s\u0026#39;, must be in the form WxH or a valid size abbreviation\\n\u0026#34;, argv[4]); return -1; } enum AVPixelFormat pixFmt = AV_PIX_FMT_YUV420P; int fps = 30; const AVCodec *encoder = avcodec_find_encoder_by_name(encoderName); if (encoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find encoder %s failed\\n\u0026#34;, encoderName); return -1; } AVCodecContext *encoderCtx = avcodec_alloc_context3(encoder); if (encoderCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc encoder context failed!\\n\u0026#34;); return -1; } encoderCtx-\u0026gt;codec_type = AVMEDIA_TYPE_VIDEO; encoderCtx-\u0026gt;pix_fmt = pixFmt; encoderCtx-\u0026gt;width = width; encoderCtx-\u0026gt;height = height; encoderCtx-\u0026gt;time_base = (AVRational){1, fps}; encoderCtx-\u0026gt;bit_rate = 4096000; encoderCtx-\u0026gt;max_b_frames = 0; encoderCtx-\u0026gt;gop_size = 10; ret = avcodec_open2(encoderCtx, encoder, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open encoder failed! %s\\n\u0026#34;, av_err2str(ret)); goto end; } FILE *src_fp = fopen(inFileName, \u0026#34;rb\u0026#34;); if (src_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open infilename error\u0026#34;); ret = -1; goto end; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open outfilename error\u0026#34;); ret = -1; goto end; } AVFrame *frame = av_frame_alloc(); int frameSize = av_image_get_buffer_size(pixFmt, width, height, 1); uint8_t *frameBuffer = av_malloc(frameSize); av_image_fill_arrays(frame-\u0026gt;data, frame-\u0026gt;linesize, frameBuffer, pixFmt, width, height, 1); int pictureSize = width * height; AVPacket *packet = av_packet_alloc(); int readFrameCount = 0; while (fread(frameBuffer, 1, pictureSize * 3 / 2, src_fp) == pictureSize * 3 / 2) { // Y 1 U 1/4 V 1/4 frame-\u0026gt;data[0] = frameBuffer; frame-\u0026gt;data[1] = frameBuffer + pictureSize; frame-\u0026gt;data[2] = frameBuffer + pictureSize + pictureSize / 4; readFrameCount++; av_log(NULL, AV_LOG_INFO, \u0026#34;readFrameCount: %d\\n\u0026#34;, readFrameCount); encodeVideo(encoderCtx, frame, packet, dest_fp); } end: if (encoderCtx) { avcodec_free_context(\u0026amp;encoderCtx); } if (src_fp) { fclose(src_fp); } if (dest_fp) { fclose(dest_fp); } if (frameBuffer) { av_freep(\u0026amp;frameBuffer); } return ret; } éŸ³é¢‘è§£ç  PCMä»‹ç» PCMï¼ˆPulse Code Modulationï¼‰æ˜¯ä¸€ç§ç”¨äºæ•°å­—éŸ³é¢‘çš„æ ‡å‡†ç¼–ç æ ¼å¼ã€‚å®ƒé€šè¿‡å°†æ¨¡æ‹ŸéŸ³é¢‘ä¿¡å·è½¬æ¢ä¸ºæ•°å­—ä¿¡å·æ¥è¡¨ç¤ºéŸ³é¢‘æ•°æ®ã€‚PCM ç¼–ç çš„åŸºæœ¬åŸç†æ˜¯å°†æ¨¡æ‹ŸéŸ³é¢‘ä¿¡å·åœ¨æ—¶é—´ä¸Šè¿›è¡Œé‡‡æ ·ï¼Œå¹¶å°†æ¯ä¸ªé‡‡æ ·ç‚¹çš„å¹…åº¦å€¼é‡åŒ–ä¸ºç¦»æ•£çš„æ•°å­—å€¼ã€‚\næ ¸å¿ƒè¿‡ç¨‹ï¼šé‡‡æ ·-\u0026gt;é‡åŒ–-\u0026gt;ç¼–ç \nPCMå…³é”®è¦ç´  é‡‡æ ·ç‡ï¼ˆSample Rateï¼‰ï¼šæ¯ç§’é‡‡æ ·çš„æ¬¡æ•°ï¼Œå¸¸è§çš„é‡‡æ ·ç‡æœ‰ 44.1 kHzã€48 kHz ç­‰ã€‚ é‡åŒ–æ ¼å¼ï¼ˆSample Formatï¼‰ï¼šæ¯ä¸ªé‡‡æ ·ç‚¹çš„ä½æ•°ï¼Œå¸¸è§çš„é‡åŒ–æ ¼å¼æœ‰ 16 ä½ã€24 ä½ç­‰ã€‚ å£°é“æ•°ï¼ˆChannelsï¼‰ï¼šéŸ³é¢‘ä¿¡å·çš„å£°é“æ•°ï¼Œå¦‚å•å£°é“ã€ç«‹ä½“å£°ç­‰ã€‚ PCMæ•°æ®æ ¼å¼ å­˜å‚¨æ ¼å¼\nåŒå£°é“ï¼šé‡‡æ ·æ•°æ®æŒ‰LRLRæ–¹å¼å­˜å‚¨ï¼Œå³å·¦å£°é“å’Œå³å£°é“äº¤æ›¿å­˜å‚¨ï¼Œå­˜å‚¨çš„æ—¶å€™ä¸å­—èŠ‚åºæœ‰å…³ã€‚ å•å£°é“ï¼šé‡‡æ ·æ•°æ®æŒ‰æ—¶é—´é¡ºåºå­˜å‚¨ï¼ˆæœ‰æ—¶ä¹Ÿä¼šé‡‡ç”¨LRLRæ–¹å¼ï¼Œä½†å¦ä¸€ä¸ªå£°é“æ•°æ®ä¸º0ï¼‰ã€‚ å­˜å‚¨æ ¼å¼åˆ†ä¸ºPackedå’ŒPlannerä¸¤ç§ï¼Œå¯¹äºåŒé€šé“éŸ³é¢‘ï¼ŒPackedä¸ºä¸¤ä¸ªå£°é“çš„æ•°æ®äº¤é”™å­˜å‚¨;Plannerä¸ºä¸¤ä¸ªå£°é“çš„æ•°æ®åˆ†å¼€å­˜å‚¨ã€‚\nPackedï¼šLRLRLR Plannerï¼šLLLRRR ffmpegéŸ³é¢‘è§£ç åçš„æ•°æ®å­˜æ”¾åœ¨AVFrameç»“æ„ä½“ä¸­ï¼š\nPackedæ ¼å¼ä¸‹ï¼Œframe.data[0]å­˜æ”¾æ‰€æœ‰å£°é“çš„æ•°æ®ã€‚ Planneræ ¼å¼ä¸‹ï¼Œframe.data[i]å­˜æ”¾ç¬¬iä¸ªå£°é“çš„æ•°æ®ã€‚ å·¦å£°é“data[0]:LLLL\u0026hellip; å³å£°é“data[1]:RRRR\u0026hellip; Planneræ¨¡å¼æ˜¯ffmpegå†…éƒ¨å­˜å‚¨æ¨¡å¼ï¼Œå®é™…ä½¿ç”¨çš„éŸ³é¢‘æ–‡ä»¶éƒ½æ˜¯Packedæ¨¡å¼ã€‚\nPCMè®¡ç®— å¤§å°è®¡ç®—ï¼šä»¥CDçš„éŸ³è´¨ä¸ºä¾‹ï¼šé‡åŒ–æ ¼å¼ä¸º16æ¯”ç‰¹ï¼ˆ2å­—èŠ‚ï¼‰ï¼Œé‡‡æ ·ç‡ä¸º44100ï¼Œå£°é“æ•°ä¸º2ã€‚ æ¯”ç‰¹ç‡ä¸ºï¼š16 * 44100 * 2 = 1378.125 kbps æ¯ç§’å­˜å‚¨ç©ºé—´ï¼š1378.125 * 60/8/1024 = 10.09MB ffmpegæå–pcmæ•°æ®å‘½ä»¤ï¼š 1 ffmpeg -i input.aac -ar 48000 -ac 2 -f s16le output.pcm ffplayæ’­æ”¾pcmæ•°æ®å‘½ä»¤ï¼š 1 ffplay -ar 48000 -ac 2 -f s16le output.pcm é€šè¿‡ä¸Šè¿°æŒ‡ä»¤æ’­æ”¾ä¸æˆåŠŸçš„è¯ï¼Œå¯ä»¥å°è¯•è½¬æ¢PCMæ–‡ä»¶\n1 2 ffmpeg -f s16le -ar 48000 -ac 2 -i output.pcm output_stereo.wav ffplay output_stereo.wav æµç¨‹ å‡½æ•°å æè¿° avformat_open_input() æ‰“å¼€è¾“å…¥æ–‡ä»¶æˆ–æµå¹¶è¯»å–å¤´éƒ¨ä¿¡æ¯ã€‚ avformat_find_stream_info() è¯»å–ä¸€äº›æ•°æ®åŒ…ä»¥è·å–æµä¿¡æ¯ã€‚ av_find_best_stream() æŸ¥æ‰¾æœ€ä½³æµï¼ˆéŸ³é¢‘ã€è§†é¢‘æˆ–å­—å¹•ï¼‰ã€‚ avcodec_alloc_context3() åˆ†é…è§£ç å™¨ä¸Šä¸‹æ–‡ã€‚ avcodec_parameters_to_context() å°†æµå‚æ•°å¤åˆ¶åˆ°è§£ç å™¨ä¸Šä¸‹æ–‡ä¸­ã€‚ avcodec_find_decoder() æŸ¥æ‰¾åˆé€‚çš„è§£ç å™¨ã€‚ avcodec_open2() æ‰“å¼€è§£ç å™¨ã€‚ av_frame_alloc() åˆ†é…AVFrameç»“æ„ä½“ã€‚ av_samples_get_buffer_size() è®¡ç®—éŸ³é¢‘ç¼“å†²åŒºçš„å¤§å°ã€‚ avcodec_fill_audio_frame() å¡«å……éŸ³é¢‘å¸§çš„ç¼“å†²åŒºã€‚ av_read_frame() ä»è¾“å…¥æ–‡ä»¶æˆ–æµä¸­è¯»å–æ•°æ®åŒ…ã€‚ avcodec_send_packet() å°†æ•°æ®åŒ…å‘é€åˆ°è§£ç å™¨è¿›è¡Œè§£ç ã€‚ avcodec_receive_frame() ä»è§£ç å™¨æ¥æ”¶è§£ç åçš„å¸§ã€‚ ä»£ç  decodeAudio.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026lt;libavcodec/codec.h\u0026gt; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;time.h\u0026gt; int decodeAudio(AVCodecContext *decoderCtx, AVPacket *packet, AVFrame *frame, FILE *dest_fp) { int ret = avcodec_send_packet(decoderCtx, packet); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;send packet to decoder failed: %s\\n\u0026#34;, av_err2str(ret)); return -1; } int channel = 0; while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(decoderCtx, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { return 0; } else if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;decode packet failed: %s\\n\u0026#34;, av_err2str(ret)); return -1; } int dataSize = av_get_bytes_per_sample(decoderCtx-\u0026gt;sample_fmt); if (dataSize \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;get bytes per sample failed\\n\u0026#34;); return -1; } // frame fltp 2 /* data[0] L L L L data[1] R R R R --\u0026gt; L R L R L R L R */ for (int i = 0; i \u0026lt; frame-\u0026gt;nb_samples; i++) { for (channel = 0; channel \u0026lt; decoderCtx-\u0026gt;ch_layout.nb_channels; channel++) { fwrite(frame-\u0026gt;data[channel] + dataSize * i, 1, dataSize, dest_fp); } } } return 0; } int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); } const char *inFileName = argv[1]; const char *outFileName = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open %s failed\\n\u0026#34;, inFileName); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream error:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream error:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } int audioStreamIndex = ret; AVCodecContext *decoderCtx = avcodec_alloc_context3(NULL); if (decoderCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc codec context failed\\n\u0026#34;); goto fail; } ret = avcodec_parameters_to_context(decoderCtx, inFmtCtx-\u0026gt;streams[audioStreamIndex]-\u0026gt;codecpar); const AVCodec *decoder = avcodec_find_decoder(decoderCtx-\u0026gt;codec_id); if (decoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find decoder %d failed\\n\u0026#34;, decoderCtx-\u0026gt;codec_id); ret = -1; goto fail; } ret = avcodec_open2(decoderCtx, decoder, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open decoder error:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open %s failed\\n\u0026#34;, outFileName); ret = -1; goto fail; } AVFrame *frame = av_frame_alloc(); int frameSize = av_samples_get_buffer_size(NULL, decoderCtx-\u0026gt;ch_layout.nb_channels, frame-\u0026gt;nb_samples, decoderCtx-\u0026gt;sample_fmt, 1); uint8_t *frameBuffer = av_malloc(frameSize); avcodec_fill_audio_frame(frame, decoderCtx-\u0026gt;ch_layout.nb_channels, decoderCtx-\u0026gt;sample_fmt, frameBuffer, frameSize, 1); AVPacket *packet = av_packet_alloc(); while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) { if (packet-\u0026gt;stream_index == audioStreamIndex) { decodeAudio(decoderCtx, packet, frame, dest_fp); } av_packet_unref(packet); } decodeAudio(decoderCtx, NULL, frame, dest_fp); fail: if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } if (decoderCtx) { avcodec_free_context(\u0026amp;decoderCtx); } if (frame) { av_frame_free(\u0026amp;frame); } if (frameBuffer) { av_freep(frameBuffer); } if (dest_fp) { fclose(dest_fp); } return ret; } è¿è¡ŒæŒ‡ä»¤\n1 2 3 4 5 ./demoBin ../video/test.aac ../video/test_decode_by_code.pcm ffmpeg -f f32le -ar 44100 -ac 2 -i ../video/test_decode_by_code.pcm ../video/test_decode_by_code_stereo.wav ffplay ../video/test_decode_by_code_stereo.wav éŸ³é¢‘ç¼–ç  æµç¨‹ å‡½æ•°å æè¿° av_frame_alloc åˆ†é…ä¸€ä¸ªAVFrameç»“æ„ä½“ av_frame_get_buffer ä¸ºAVFrameåˆ†é…ç¼“å†²åŒº avcodec_find_encoder_by_name æ ¹æ®åç§°æŸ¥æ‰¾ç¼–ç å™¨ avcodec_alloc_context3 åˆ†é…ç¼–ç å™¨ä¸Šä¸‹æ–‡ avcodec_open2 æ‰“å¼€ç¼–ç å™¨ avcodec_send_frame å‘é€å¸§åˆ°ç¼–ç å™¨ avcodec_receive_packet ä»ç¼–ç å™¨æ¥æ”¶ç¼–ç åçš„æ•°æ®åŒ… è¿è¡ŒæŒ‡ä»¤\n1 2 3 ffmpeg -ac 2 -ar 44100 -f s16le -i test.pcm -acodec libfdk_aac test1.aac ffplay test1.aac ä»£ç  encodeAudioDemo.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026lt;libavcodec/codec.h\u0026gt; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/channel_layout.h\u0026gt; #include \u0026lt;libavutil/error.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/samplefmt.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; int encodeAudio(AVCodecContext *encoderCtx, AVFrame *frame, AVPacket *packet, FILE *dest_fp) { int ret = avcodec_send_frame(encoderCtx, frame); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;send frame to encoder failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } while (ret \u0026gt;= 0) { ret = avcodec_receive_packet(encoderCtx, packet); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { return 0; } else if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;receive packet from encoder failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); av_packet_unref(packet); } return 0; } int main(int argc, char **argv) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input file\u0026gt; \u0026lt;output file\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFileName = argv[1]; const char *outFileName = argv[2]; AVFrame *frame = av_frame_alloc(); if (!frame) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate video frame\\n\u0026#34;); return -1; } frame-\u0026gt;sample_rate = 44100; // è¿™é‡Œä»£ç æœ‰äº›ä¸åŒ frame-\u0026gt;ch_layout.nb_channels = 2; av_channel_layout_from_mask(\u0026amp;frame-\u0026gt;ch_layout, AV_CH_LAYOUT_STEREO); frame-\u0026gt;format = AV_SAMPLE_FMT_S16; frame-\u0026gt;nb_samples = 1024; av_frame_get_buffer(frame, 0); int ret = 0; const AVCodec *encoder = avcodec_find_encoder_by_name(\u0026#34;libfdk_aac\u0026#34;); if (!encoder) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find encoder failed\\n\u0026#34;); ret = -1; goto end; } AVCodecContext *encoderCtx = avcodec_alloc_context3(encoder); if (!encoderCtx) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc encoder context failed\\n\u0026#34;); ret = -1; goto end; } encoderCtx-\u0026gt;sample_fmt = frame-\u0026gt;format; encoderCtx-\u0026gt;sample_rate = frame-\u0026gt;sample_rate; encoderCtx-\u0026gt;ch_layout.nb_channels = frame-\u0026gt;ch_layout.nb_channels; encoderCtx-\u0026gt;ch_layout = frame-\u0026gt;ch_layout; ret = avcodec_open2(encoderCtx, encoder, NULL); if (ret \u0026lt; 0) { av_log(NULL,AV_LOG_ERROR,\u0026#34;open encoder failed:%s\\n\u0026#34;,av_err2str(ret)); ret = -1; goto end; } FILE *src_fp = fopen(inFileName, \u0026#34;rb\u0026#34;); if (src_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input file failed\\n\u0026#34;); ret = -1; goto end; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (src_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open output file failed\\n\u0026#34;); ret = -1; goto end; } AVPacket *packet = av_packet_alloc(); while (1) { int readSize = fread(frame-\u0026gt;data[0], 1, frame-\u0026gt;linesize[0], src_fp); if (readSize == 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;finish read infile\\n\u0026#34;); break; } encodeAudio(encoderCtx, frame, packet, dest_fp); } encodeAudio(encoderCtx, NULL, packet, dest_fp); end: if (frame) { av_frame_free(\u0026amp;frame); } if (encoderCtx) { avcodec_free_context(\u0026amp;encoderCtx); } if (src_fp) { fclose(src_fp); } if (dest_fp) { fclose(dest_fp); } return ret; } æŒ‡ä»¤\n1 2 3 ./demoBin test.pcm aac_by_code.aac ffplay aac_by_code.aac è§†é¢‘é‡‡é›† è§†é¢‘é‡‡é›†å‘½ä»¤ æŸ¥çœ‹è®¾å¤‡åˆ—è¡¨ï¼š 1 ffmpeg -hide_banner -devices æŸ¥çœ‹dshowæ”¯æŒçš„å‚æ•°ï¼š 1 ffmpeg -h demuxer=dshow æŸ¥çœ‹dshowæ”¯æŒçš„è®¾å¤‡ï¼š 1 ffmpeg -f dshow -list_devices true -i dummy ä¸€èˆ¬æ˜¯Integrated Cameraï¼Œè¿™æ˜¯æœ¬åœ°æ‘„åƒå¤´\né‡‡é›†æ‘„åƒå¤´ç”»é¢ï¼š 1 ffmpeg -f dshow -i video=\u0026#34;Integrated Camera\u0026#34; ./video/output.mp4 æ’­æ”¾æ‘„åƒå¤´é‡‡é›†ç”»é¢ï¼š\n1 ffplay output.mp4 æµç¨‹ å‡½æ•°å æè¿° avdevice_register_all æ³¨å†Œæ‰€æœ‰å¯ç”¨çš„è®¾å¤‡ avformat_alloc_context åˆ†é…æ ¼å¼ä¸Šä¸‹æ–‡ av_dict_set è®¾ç½®å­—å…¸é€‰é¡¹ av_find_input_format æŸ¥æ‰¾è¾“å…¥æ ¼å¼ avformat_open_input æ‰“å¼€è¾“å…¥æ–‡ä»¶ avformat_find_stream_info æŸ¥æ‰¾æµä¿¡æ¯ av_find_best_stream æŸ¥æ‰¾æœ€ä½³æµ avcodec_alloc_context3 åˆ†é…ç¼–è§£ç å™¨ä¸Šä¸‹æ–‡ avcode_parameters_to_context å°†å‚æ•°å¤åˆ¶åˆ°ä¸Šä¸‹æ–‡ avcodec_find_decoder æŸ¥æ‰¾è§£ç å™¨ avcodec_open2 æ‰“å¼€ç¼–è§£ç å™¨ av_read_frame è¯»å–å¸§ avcode_send_packet å‘é€æ•°æ®åŒ… avcodec_receive_frame æ¥æ”¶å¸§ é¢œè‰²ç©ºé—´æ ¼å¼è½¬æ¢ï¼š\nå‡½æ•°å æè¿° sws_getContext è·å–ç¼©æ”¾ä¸Šä¸‹æ–‡ av_frame_alloc åˆ†é…å¸§ av_image_get_buffer_size è·å–å›¾åƒç¼“å†²åŒºå¤§å° av_malloc åˆ†é…å†…å­˜ av_image_fill_arrays å¡«å……å›¾åƒæ•°ç»„ sws_scale ç¼©æ”¾å›¾åƒ å…ˆç”¨ffmpegæŒ‡ä»¤è¯•ä¸€ä¸‹è§†é¢‘é‡‡é›†æ ¼å¼ï¼Œåç»­ä»£ç å†™çš„æ—¶å€™è¦ç”¨å¯¹åº”é‡‡é›†çš„æ ¼å¼ã€‚\nä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavdevice/avdevice.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavutil/imgutils.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/dict.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; // æ˜¾ç¤ºå¯ç”¨çš„æ‘„åƒå¤´è®¾å¤‡ // ffmpeg -f dshow -list_devices true -i dummy void dshowListDevices() { const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find dshow failed!\\n\u0026#34;); } // è®¾ç½®å‚æ•° AVDictionary *options = NULL; av_dict_set(\u0026amp;options, \u0026#34;list_devices\u0026#34;, \u0026#34;true\u0026#34;, 0); AVFormatContext *inFmtCtx = avformat_alloc_context(); // ç¬¬äºŒä¸ªå‚æ•°æ˜¯URL int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;video=Integrated Camera\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return; } if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); avformat_free_context(inFmtCtx); } } void decodeVideo(struct SwsContext *swsCtx, AVCodecContext *decoderCtx, AVFrame *destFrame, AVPacket *packet, FILE *dest_fp) { if (avcodec_send_packet(decoderCtx, packet) == 0) { AVFrame *frame = av_frame_alloc(); while (avcodec_receive_frame(decoderCtx, frame) \u0026gt;= 0) { sws_scale(swsCtx, (const uint8_t *const *)frame-\u0026gt;data, frame-\u0026gt;linesize, 0, decoderCtx-\u0026gt;height, destFrame-\u0026gt;data, destFrame-\u0026gt;linesize); fwrite(destFrame-\u0026gt;data[0], 1, decoderCtx-\u0026gt;width * decoderCtx-\u0026gt;height, dest_fp); fwrite(destFrame-\u0026gt;data[1], 1, decoderCtx-\u0026gt;width * decoderCtx-\u0026gt;height / 4, dest_fp); fwrite(destFrame-\u0026gt;data[2], 1, decoderCtx-\u0026gt;width * decoderCtx-\u0026gt;height / 4, dest_fp); } av_frame_free(\u0026amp;frame); } } int main(int argc, char *argv[]) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage:%s \u0026lt;outFileName\u0026gt; \\n\u0026#34;, argv[0]); return -1; } const char *outFileName = argv[1]; avdevice_register_all(); dshowListDevices(); AVFormatContext *inFmtCtx = avformat_alloc_context(); const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed!\\n\u0026#34;); goto end; } AVDictionary *options = NULL; av_dict_set(\u0026amp;options, \u0026#34;framerate\u0026#34;, \u0026#34;30\u0026#34;, 0); int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;video=Integrated Camera\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } int videoIndex = ret; // åˆ›å»ºè§£ç å™¨ä¸Šä¸‹æ–‡ AVCodecContext *decoderCtx = avcodec_alloc_context3(NULL); ret = avcodec_parameters_to_context(decoderCtx, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;copy parameters to context failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } const AVCodec *decoder = avcodec_find_decoder(decoderCtx-\u0026gt;codec_id); if (decoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find decoder failed!\\n\u0026#34;); ret = -1; goto end; } ret = avcodec_open2(decoderCtx, decoder, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open decoder failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } AVFrame *destFrame = av_frame_alloc(); enum AVPixelFormat destPixFmt = AV_PIX_FMT_YUV420P; uint8_t *outBuffer = av_malloc(av_image_get_buffer_size(destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1)); av_image_fill_arrays(destFrame-\u0026gt;data, destFrame-\u0026gt;linesize, outBuffer, destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1); struct SwsContext *swsCtx = sws_getContext(decoderCtx-\u0026gt;coded_width, decoderCtx-\u0026gt;coded_height, decoderCtx-\u0026gt;pix_fmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, destPixFmt, 0, NULL, NULL, NULL); if (swsCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;create sws context failed!\\n\u0026#34;); ret = -1; goto end; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open out put file %s failed!\\n\u0026#34;, outFileName); ret = -1; goto end; } AVPacket *packet = av_packet_alloc(); while (1) { if (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == videoIndex) { decodeVideo(swsCtx, decoderCtx, destFrame, packet, dest_fp); } } av_packet_unref(packet); } decodeVideo(swsCtx,decoderCtx, destFrame,NULL, dest_fp); end: if (inFmtCtx) { avformat_free_context(inFmtCtx); } if (decoderCtx) { avcodec_free_context(\u0026amp;decoderCtx); } if (dest_fp) { fclose(dest_fp); } if (outBuffer) { av_freep(\u0026amp;outBuffer); } return ret; } éŸ³é¢‘é‡‡é›† éŸ³é¢‘é‡‡é›†å‘½ä»¤ é‡‡é›†éº¦å…‹é£å£°éŸ³ï¼š\n1 ffmpeg -f dshow -i audio=\u0026#34;é˜µåˆ—éº¦å…‹é£ (AMD Audio Device)\u0026#34; -ar 44100 -f f32le output.pcm æ’­æ”¾éº¦å…‹é£é‡‡é›†ï¼š\n1 ffplay -ar 44100 -f f32le output.pcm æµç¨‹ å‡½æ•°å æè¿° avdevice_register_all æ³¨å†Œæ‰€æœ‰å¯ç”¨çš„è®¾å¤‡ avformat_alloc_context åˆ†é…æ ¼å¼ä¸Šä¸‹æ–‡ av_dict_set è®¾ç½®å­—å…¸é€‰é¡¹ av_find_input_format æŸ¥æ‰¾è¾“å…¥æ ¼å¼ avformat_open_input æ‰“å¼€è¾“å…¥æ–‡ä»¶ avformat_find_stream_info æŸ¥æ‰¾æµä¿¡æ¯ av_find_best_stream æŸ¥æ‰¾æœ€ä½³æµ avcodec_alloc_context3 åˆ†é…ç¼–è§£ç å™¨ä¸Šä¸‹æ–‡ avcode_parameters_to_context å°†å‚æ•°å¤åˆ¶åˆ°ä¸Šä¸‹æ–‡ avcodec_find_decoder æŸ¥æ‰¾è§£ç å™¨ avcodec_open2 æ‰“å¼€ç¼–è§£ç å™¨ av_read_frame è¯»å–å¸§ avcode_send_packet å‘é€æ•°æ®åŒ… avcodec_receive_frame æ¥æ”¶å¸§ ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavdevice/avdevice.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavutil/imgutils.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/dict.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; // æ˜¾ç¤ºå¯ç”¨çš„æ‘„åƒå¤´è®¾å¤‡ // ffmpeg -f dshow -list_devices true -i dummy void dshowListDevices() { const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find dshow failed!\\n\u0026#34;); } // è®¾ç½®å‚æ•° AVDictionary *options = NULL; av_dict_set(\u0026amp;options, \u0026#34;list_devices\u0026#34;, \u0026#34;true\u0026#34;, 0); AVFormatContext *inFmtCtx = avformat_alloc_context(); // ç¬¬äºŒä¸ªå‚æ•°æ˜¯URL int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;video=Integrated Camera\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return; } if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); avformat_free_context(inFmtCtx); } } void decodeAudio(AVCodecContext *decoderCtx, AVPacket *packet, FILE *dest_fp) { if (avcodec_send_packet(decoderCtx, packet) == 0) { AVFrame *frame = av_frame_alloc(); while (avcodec_receive_frame(decoderCtx, frame) \u0026gt;= 0) { fwrite(frame-\u0026gt;data[0], 1, frame-\u0026gt;linesize[0], dest_fp); } av_frame_free(\u0026amp;frame); } } int main(int argc, char *argv[]) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage:%s \u0026lt;outFileName\u0026gt; \\n\u0026#34;, argv[0]); return -1; } const char *outFileName = argv[1]; avdevice_register_all(); dshowListDevices(); AVFormatContext *inFmtCtx = avformat_alloc_context(); const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed!\\n\u0026#34;); goto end; } AVDictionary *options = NULL; // av_dict_set(\u0026amp;options, \u0026#34;framerate\u0026#34;, \u0026#34;30\u0026#34;, 0); int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;audio=é˜µåˆ—éº¦å…‹é£ (AMD Audio Device)\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } int audioIndex = ret; // åˆ›å»ºè§£ç å™¨ä¸Šä¸‹æ–‡ AVCodecContext *decoderCtx = avcodec_alloc_context3(NULL); ret = avcodec_parameters_to_context(decoderCtx, inFmtCtx-\u0026gt;streams[audioIndex]-\u0026gt;codecpar); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;copy parameters to context failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } const AVCodec *decoder = avcodec_find_decoder(decoderCtx-\u0026gt;codec_id); if (decoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find decoder failed!\\n\u0026#34;); ret = -1; goto end; } ret = avcodec_open2(decoderCtx, decoder, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open decoder failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } #if 0 AVFrame *destFrame = av_frame_alloc(); enum AVPixelFormat destPixFmt = AV_PIX_FMT_YUV420P; uint8_t *outBuffer = av_malloc(av_image_get_buffer_size(destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1)); av_image_fill_arrays(destFrame-\u0026gt;data, destFrame-\u0026gt;linesize, outBuffer, destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1); struct SwsContext *swsCtx = sws_getContext(decoderCtx-\u0026gt;coded_width, decoderCtx-\u0026gt;coded_height, decoderCtx-\u0026gt;pix_fmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, destPixFmt, 0, NULL, NULL, NULL); if (swsCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;create sws context failed!\\n\u0026#34;); ret = -1; goto end; } #endif FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open out put file %s failed!\\n\u0026#34;, outFileName); ret = -1; goto end; } AVPacket *packet = av_packet_alloc(); while (1) { if (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == audioIndex) { // decodeVideo(swsCtx, decoderCtx, destFrame, packet, dest_fp); decodeAudio(decoderCtx, packet, dest_fp); } } av_packet_unref(packet); } // decodeVideo(swsCtx, decoderCtx, destFrame, NULL, dest_fp); decodeAudio(decoderCtx, NULL, dest_fp); end: if (inFmtCtx) { avformat_free_context(inFmtCtx); } if (decoderCtx) { avcodec_free_context(\u0026amp;decoderCtx); } if (dest_fp) { fclose(dest_fp); } return ret; } é‡‡é›†å®Œåè¦ç”¨æŒ‡ä»¤\n1 ffplay -f s16le -ar 44100 code.pcm æ‰å¯ä»¥æ’­æ”¾ï¼Œå¯èƒ½æ˜¯å‚æ•°çš„ä¸åŒ\n","date":"2024-12-29T00:00:00Z","image":"https://example.com/post/video_base/player1.jpg","permalink":"https://example.com/post/video_base/","title":"éŸ³è§†é¢‘åŸºç¡€"}]