[{"content":"操作系统知识点 线程 线程上下文 线程上下文涉及下面三个部分：\nCPU寄存器：如程序计数器（PC）、栈指针（SP）、通用寄存器等，这些值被保存，以便下次切换回当前线程时能够恢复。 程序状态字（PSW）：包括CPU的状态信息，比如中断使能、优先级等。 线程的内核栈和用户栈：这两个栈分别用于存储内核和用户空间的函数调用信息。 TCB（线程控制块） TCB（Thread Control Block）是操作系统用来管理线程的一个数据结构，它包含了与线程执行相关的所有必要信息，确保线程能够在系统中被正确调度和执行。每个线程都有一个对应的TCB，操作系统通过TCB来管理和调度线程的执行。\nTCB中的关键内容：\n线程状态：就绪、运行、阻塞、终止等。操作系统通过线程状态来判断是否可以被执行或需要被挂起。 程序计数器：程序计数器保留线程当前执行指令的地址，标识线程的执行位置。线程切换时，程序计数器的值需要被保存和恢复。 寄存器内容：线程的寄存器值（如通用寄存器、栈指针等）需要在上下文切换时保存和恢复。它们包含了线程执行期间的局部变量、函数调用的返回地址等信息。 线程栈指针（Stack Pointer，SP）：每个线程都有一个栈，用于存储函数调用信息（如局部变量、返回地址等）。栈指针指向当前栈顶，线程切换时，栈指针需要被保存和恢复 线程优先级：操作系统通常根据线程的优先级来决定哪个线程应该被调度执行。 线程标识符：每个线程都有一个唯一的标识符（线程ID），操作系统通过它来区分不同的线程。 线程的调度信息：包括线程的调度策略、时间片（如果采用时间片轮转调度）、期望的调度器等。这个信息帮助操作系统决定何时将线程调度到CPU上执行。 管道 什么是进程间通信？\n每个进程各自有不同的地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。\n管道定义 管道是一种最基本的进程间的通信机制。把一个进程连接到另一个进程的一个数据流称为一个\u0026quot;管道\u0026quot;，通常是用作把一个进程的输出通过管道连接到另一个进程的输入。 管道本质上是内核的一块缓存，内核维护了一块缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区内存的操作。 举例：\n在shell中执行命令，经常会将上一个命令的输出组为下一个命令的输入，由多个命令配合完成一件事情。而这就是通过管道来实现。|这个竖线就是管道符号\n1 ls -l | grep string ls命令（其实也是一个进程）会把当前目录中的文件都列出来 但它不会直接输出，而是把要输出到屏幕上的数据通过管道输出到grep这个进程中，作为**grep这个进程的输入** 然后这个进程对输入的信息进行筛选（grep的作用），把存在string的信息的字符串（以行为单位）打印在屏幕上。 参考：一文让你明白，什么是管道\n进程 进程的状态 就绪状态：进程已经分配到必要的资源，具备执行条件，等待CPU调度程序分配处理器时间。一旦CPU空闲并选择该进程，就会从就绪状态进入运行状态。 运行状态：进程正在使用CPU执行指令。 阻塞状态：进程因为等待某种事件（如I/O操作完成、等待某个信号等）而暂时停止运行。处于阻塞状态的进程不能被CPU调度，必须等到所需事件发生后，才能转为就绪状态。 新建状态：进程正在创建但尚未进入就绪队列。操作系统为新进程分配资源（如内存），当装备就绪后，进程会进入就绪状态。 终止状态：进程执行完毕或因某种原因被终止，进入终止状态。操作系统会回收该进程所占用的资源。 进程状态转换的流程 进程在其生命周期中可能经历多次状态转换，常见的状态转换包括：\n就绪-\u0026gt;运行：当CPU调度到某个就绪进程时，该进程从就绪状态转变为运行状态。 运行-\u0026gt;阻塞：如果进程需要等待I/O操作或某个事件（如等待文件输入），会从运行状态转为阻塞状态，放弃CPU的使用。 运行-\u0026gt;就绪：操作系统采用时间片轮转调度时，如果进程的时间片用完但未完成任务，会回到就绪状态，等待下次调度。 阻塞-\u0026gt;就绪：当阻塞进程等待的事件（如I/O完成）发生后，会从阻塞状态回到就绪状态。 僵尸进程与孤儿进程 僵尸进程(Zombie Process)：进程已经终止，但其父进程未对其进行回收（调用wait函数）。僵尸进程占用系统的进程表项，但不再消耗其他资源。操作系统会等待其父进程来获取它的终止状态信息，清除僵尸进程。 孤儿进程(Orphan Process)：父进程提前终止，子进程继续运行，成为孤儿进程。操作系统会将孤儿进程托管给init进程(Linux系统中的PID为1的进程)，由init进程来收养并清理这些孤儿进程。 面试题 线程切换 操作系统在进行线程切换时需要进行哪些动作？\n主要动作如下：\n保存当前线程的上下文（如CPU寄存器、栈指针）到线程控制块（TCB）中。 更新当前线程的状态（如就绪、阻塞等）。 选择下一个要执行的线程，更新调度信息。 恢复下一个线程的上下文，恢复CPU寄存器、栈指针、程序计数器等信息，确保线程能够从上次中断的地方继续执行，开始执行其任务。 在操作系统中，线程切换是指将CPU的控制权从一个线程转移到另一个线程的过程。与进程切换相比，线程切换开销较小，因为同一个进程内的线程共享相同的地址空间和资源。\n进程间的通信 进程之间的通信方式有哪些？\n管道：管道是一种单向通信方式，用于在父进程和子进程之间或者同一主机上的不同进程之间传递数据。它可以是匿名的，也可以是命名的。 命名管道：与匿名管道类似，但具有一个在文件系统中有名的路径，运行不相关的进程之间进行通信。 消息队列：消息队列允许一个进程向另一个进程发送信息，消息在队列中按顺序存储，并且接收方可以按需接收。 共享内存：共享内存允许多个进程访问同一块内存区域，从而实现快速的数据交换。但需要注意同步问题，以避免竞态条件和数据一致性问题。 信号量：信号量是一种同步原语，用于管理对共享资源的访问。它可以用于实现进程间的互斥访问和同步操作。 信号：信号是一种异步的通信方式，用于通知目标进程发生了某个事件。信号常用于进程之间发送终端或终止命令。 套接字：套接字允许在网络上的不同主机上的进程进行通信，是实现网络通信的基础。 文件：进程可以通过读写文件来进行通信，这种方式常用于进程之间的间接通信，例如使用临时文件或者共享文件。 参考：面试鸭\n","date":"2025-05-05T00:00:00Z","permalink":"https://serennan.github.io/post/operating_system/","title":"操作系统知识点"},{"content":"socket 套接字 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n1. 概念 局域网和广域网\n局域网：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。 广域网：又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程公共网络。 IP（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。IP协议版本有两个：IPv4和IPv6\nIPv4（Internet Protocol version4）： 使用一个32位的整形数描述一个IP地址，4个字节，int型 也可以使用一个点分十进制字符串描述这个IP地址： 192.168.247.135 分成了4份，每份1字节，8bit（char），最大值为 255 0.0.0.0 是最小的IP地址 255.255.255.255是最大的IP地址 按照IPv4协议计算，可以使用的IP地址共有 2^32 个 IPv6（Internet Protocol version6）： 使用一个128位的整形数描述一个IP地址，16个字节 也可以使用一个字符串描述这个IP地址：2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b 分成了8份，每份2字节，每一部分以16进制的方式表示 按照IPv6协议计算，可以使用的IP地址共有 2^128 个 查看IP地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # linux $ ifconfig # windows $ ipconfig # 测试网络是否畅通 # 主机a: 192.168.1.11 # 当前主机: 192.168.1.12 $ ping 192.168.1.11 $ ping www.baidu.com # 特殊的IP地址: 127.0.0.1 ==\u0026gt; 和本地的IP地址是等价的 # 假设当前电脑没有联网, 就没有IP地址, 又要做网络测试, 可用使用 127.0.0.1 进行本地测试 端口 端口的作用是定位到主机上的某一个进程，通过这个端口进程就可以接受到对应的网络数据了。\n比如: 在电脑上运行了微信和QQ, 小明通过客户端给我的的微信发消息, 电脑上的微信就收到了消息, 为什么?\n运行在电脑上的微信和QQ都绑定了不同的端口 通过IP地址可以定位到某一台主机，通过端口就可以定位到主机上的某一个进程 通过指定的IP和端口，发送数据的时候对端就能接受到数据了 端口也是一个整形数 unsigned short ，一个16位整形数，有效端口的取值范围是：0 ~ 65535(0 ~ 2^16-1)\n提问：计算机中所有的进程都需要关联一个端口吗，一个端口可以被重复使用吗?\n不需要，如果这个进程不需要网络通信，那么这个进程就不需要绑定端口的\n一个端口只能给某一个进程使用，多个进程不能同时使用同一个端口\nOSI/ISO 网络分层模型 OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织组织）在1985年研究的网络互联模型。\n物理层：负责最后将信息编码成电流脉冲或其它信号用于网上传输 数据链路层: 数据链路层通过物理网络链路供数据传输 规定了0和1的分包形式，确定了网络数据包的形式 网络层: 网络层负责在源和终点之间建立连接 此处需要确定计算机的位置，通过IPv4，IPv6格式的IP地址来找到对应的主机 传输层: 传输层向高层提供可靠的端到端的网络数据流服务 每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信 会话层: 会话层建立、管理和终止表示层与实体之间的通信会话 建立一个连接（自动的手机信息、自动的网络寻址） 表示层: 对应用层数据编码和转化 确保以一个系统应用层发送的信息可以被另一个系统应用层识别 应用层: 为应用程序提供网络服务 定义了应用程序之间交互的协议和方法 2. 网络协议 网络协议指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合。一般系统网络协议包括五个部分：通信环境，传输服务，词汇表，信息的编码格式，时序、规则和过程。先来通过下面几幅图了解一下常用的网络协议的格式：\nTCP协议 -\u0026gt; 传输层协议 UDP协议 -\u0026gt; 传输层协议 IP协议 -\u0026gt; 网络层协议 以太网帧协议 -\u0026gt; 网络接口层协议 数据的封装 在网络通信的时候, 程序猿需要负责的应用层数据的处理(最上层)\n应用层的数据可以使用某些协议进行封装, 也可以不封装 程序猿需要调用发送数据的接口函数，将数据发送出去 程序猿调用的API做底层数据处理 传输层使用传输层协议打包数据 网络层使用网络层协议打包数据 网络接口层使用网络接口层协议打包数据 数据被发送到internet 接收端接收到发送端的数据 程序猿调用接收数据的函数接收数据 调用的API做相关的底层处理: 网络接口层拆包 ==\u0026gt; 网络层的包 网络层拆包 ==\u0026gt; 网络层的包 传输层拆包 ==\u0026gt; 传输层数据 如果应用层也使用了协议对数据进行了封装，数据的包的解析需要程序猿做 3. socket编程 Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。其目的是将TCP/IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。与套接字相关的函数被包含在头文件sys/socket.h中。\n通过上面的描述可以得知，套接字对应程序猿来说就是一套网络通信的接口，使用这套接口就可以完成网络通信。网络通信的主体主要分为两部分：客户端和服务器端。在客户端和服务器通信的时候需要频繁提到三个概念：IP、端口、通信数据，下面介绍一下需要注意的一些细节问题。\n3.1 字节序 在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编/译码从而导致通信失败。\n字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。\n目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian 和 Little-Endian，下面先从字节序说起。\n大小端的这个名词最早出现在《格列佛游记》中，里边记载了两个征战的强国，你不会想到的是，他们打仗竟然和剥鸡蛋的顺序有关。很多人认为，剥鸡蛋时应该打破鸡蛋较大的一端，这群人被称作\u0026quot;大端（Big endian）派\u0026quot;。可是那时皇帝儿子小时候吃鸡蛋的时候碰巧将一个手指弄破了。所以，当时的皇帝就下令剥鸡蛋必须打破鸡蛋较小的一端，违令者重罚，由此产生了\u0026quot;小端（Little endian）派\u0026quot;。\n老百姓们对这项命令极其反感，由此引发了6次叛乱，其中一个皇帝送了命，另一个丢了王位。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端！\nLittle-Endian -\u0026gt; 主机字节序 (小端)\n数据的低位字节存储到内存的低地址位, 数据的高位字节存储到内存的高地址位 我们使用的PC机，数据的存储默认使用的是小端 Big-Endian -\u0026gt; 网络字节序 (大端)\n据的低位字节存储到内存的高地址位, 数据的高位字节存储到内存的低地址位 套接字通信过程中操作的数据都是大端存储的，包括：接收/发送的数据、IP地址、端口。 字节序举例\n1 2 3 4 内存低地址位 内存的高地址位 ---------------------------------------------------------------------------\u0026gt; 小端: 0xff 0x01 0x5c 0xab 大端: 0xab 0x5c 0x01 0xff 函数 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;arpa/inet.h\u0026gt; // 主机字节序 -\u0026gt; 网络字节序 uint16_t htons(uint16_t hostshort); // 转换端口 uint32_t htonl(uint32_t hostlong); // 转换IP // 网络字节序 -\u0026gt; 主机字节序 uint16_t ntohs(uint16_t netshort); // 转换端口 uint32_t ntohl(uint32_t netlong); // 转换IP 3.2 IP地址转换 虽然IP地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述，下面的函数描述了如何将一个字符串类型的IP地址进行大小端转换：\n1 int inet_pton(int af, const char *src, void *dst); 参数: af: 地址族(IP地址的家族包括ipv4和ipv6)协议 AF_INET: ipv4格式的ip地址 AF_INET6: ipv6格式的ip地址 src: 传入参数, 对应要转换的点分十进制的ip地址: 192.168.1.100 dst: 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中 返回值：成功返回1，失败返回0或者-1 1 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); 参数: af: 地址族协议 AF_INET: ipv4格式的ip地址 AF_INET6: ipv6格式的ip地址 src: 传入参数, 这个指针指向的内存中存储了大端的整形IP地址 dst: 传出参数, 存储转换得到的小端的点分十进制的IP地址 size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节 返回值: 成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串 失败: NULL 还有一组函数也能进程IP地址大小端的转换，但是只能处理ipv4的ip地址：\n1 2 in_addr_t inet_addr (const char *cp); char* inet_ntoa(struct in_addr in); 3.3 sockaddr 数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 struct sockaddr { sa_family_t sa_family; char sa_data[14]; }; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef uint16_t in_port_t; typedef uint32_t in_addr_t; typedef unsigned short int sa_family_t; #define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)) struct in_addr { in_addr_t s_addr; }; struct sockaddr_in { sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; unsigned char sin_zero[sizeof (struct sockaddr) - sizeof(sin_family) - sizeof (in_port_t) - sizeof (struct in_addr)]; }; 3.4 套接字函数 使用套接字通信函数需要包含头文件\u0026lt;arpa/inet.h\u0026gt;，包含了这个头文件\u0026lt;sys/socket.h\u0026gt;就不用在包含了。\n1 int socket(int domain, int type, int protocol); 参数: domain: 使用的地址族协议 AF_INET: 使用IPv4格式的ip地址 AF_INET6: 使用IPv6格式的ip地址 type: SOCK_STREAM: 使用流式的传输协议 SOCK_DGRAM: 使用报式(报文)的传输协议 protocol: 一般写0即可, 使用默认的协议 SOCK_STREAM: 流式传输默认使用的是tcp SOCK_DGRAM: 报式传输默认使用的udp 返回值: 成功: 可用于套接字通信的文件描述符 失败: -1 函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。\n1 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 参数: sockfd: 监听的文件描述符, 通过socket()调用得到的返回值 addr: 传入参数, 要绑定的IP和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序 addrlen: 参数addr指向的内存大小, sizeof(struct sockaddr) 返回值：成功返回0，失败返回-1 1 int listen(int sockfd, int backlog); 参数: sockfd: 文件描述符, 可以通过调用socket()得到，在监听之前必须要绑定 bind() backlog: 同时能处理的最大连接要求，最大值为128 返回值：函数调用成功返回0，调用失败返回 -1 1 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 参数: sockfd: 监听的文件描述符 addr: 传出参数, 里边存储了建立连接的客户端的地址信息 addrlen: 传入传出参数，用于存储addr指向的内存大小 返回值：函数调用成功，得到一个文件描述符, 用于和建立连接的这个客户端通信，调用失败返回 -1 这个函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。\n1 2 ssize_t read(int sockfd, void *buf, size_t size); ssize_t recv(int sockfd, void *buf, size_t size, int flags); 参数: sockfd: 用于通信的文件描述符, accept() 函数的返回值 buf: 指向一块有效内存, 用于存储接收是数据 size: 参数buf指向的内存的容量 flags: 特殊的属性, 一般不使用, 指定为 0 返回值: 大于0：实际接收的字节数 等于0：对方断开了连接 -1：接收数据失败了 如果连接没有断开，接收端接收不到数据，接收数据的函数会阻塞等待数据到达，数据到达后函数解除阻塞，开始接收数据，当发送端断开连接，接收端无法接收到任何数据，但是这时候就不会阻塞了，函数直接返回0。\n1 2 ssize_t write(int fd, const void *buf, size_t len); ssize_t send(int fd, const void *buf, size_t len, int flags); 参数: fd: 通信的文件描述符, accept() 函数的返回值 buf: 传入参数, 要发送的字符串 len: 要发送的字符串的长度 flags: 特殊的属性, 一般不使用, 指定为 0 返回值： 大于0：实际发送的字节数，和参数len是相等的 -1：发送数据失败了 1 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 参数: sockfd: 通信的文件描述符, 通过调用socket()函数就得到了 addr: 存储了要连接的服务器端的地址信息: iP 和 端口，这个IP和端口也需要转换为大端然后再赋值 addrlen: addr指针指向的内存的大小 sizeof(struct sockaddr) 返回值：连接成功返回0，连接失败返回-1 4. TCP通信流程 TCP是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。\n面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。 安全：tcp通信过程中，会对发送的每一数据包都会进行校验, 如果发现数据丢失, 会自动重传 流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致 4.1 服务器端通信流程 创建用于监听的套接字, 这个套接字是一个文件描述符 1 int lfd = socket(); 将得到的监听的文件描述符和本地的IP 端口进行绑定 1 bind(); 设置监听(成功之后开始监听, 监听的是客户端的连接) 1 listen(); 等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的) 没有新连接请求就阻塞\n1 int cfd = accept(); 通信，读写操作默认都是阻塞的 1 2 read(); / recv(); write(); / send(); 断开连接, 关闭套接字 1 close(); 在tcp的服务器端, 有两类文件描述符:\n监听的文件描述符 只需要有一个 不负责和客户端通信, 负责检测客户端的连接请求, 检测到之后调用accept就可以建立新的连接 通信的文件描述符 负责和建立连接的客户端通信 如果有N个客户端和服务器建立了新的连接, 通信的文件描述符就有N个，每个客户端和服务器都对应一个通信的文件描述符 文件描述符对应的内存结构：\n一个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区 读数据: 通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区 写数据: 通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区 监听的文件描述符:\n客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中 读缓冲区中有数据, 说明有新的客户端连接 调用accept()函数, 这个函数会检测监听文件描述符的读缓冲区 检测不到数据, 该函数阻塞 如果检测到数据, 解除阻塞, 新的连接建立 通信的文件描述符:\n客户端和服务器端都有通信的文件描述符 发送数据：调用函数 write() / send()，数据进入到内核中 数据并没有被发送出去, 而是将数据写入到了通信的文件描述符对应的写缓冲区中 内核检测到通信的文件描述符写缓冲区中有数据, 内核会将数据发送到网络中 接收数据: 调用的函数 read() / recv(), 从内核读数据 数据如何进入到内核程序猿不需要处理, 数据进入到通信的文件描述符的读缓冲区中 数据进入到内核, 必须使用通信的文件描述符, 将数据从读缓冲区中读出即可 4.2 客户端的通信流程 在单线程的情况下客户端通信的文件描述符有一个, 没有监听的文件描述符\n创建一个通信的套接字 1 int cfd = socket(); 连接服务器, 需要知道服务器绑定的IP和端口 1 connect(); 通信 1 2 read(); / recv(); write(); / send(); 断开连接, 关闭文件描述符(套接字) 1 close(); ","date":"2025-04-26T00:00:00Z","image":"https://serennan.github.io/post/linux-socket/cover.png","permalink":"https://serennan.github.io/post/linux-socket/","title":"【Linux】socket 套接字"},{"content":"Linux 网络编程入门 个人学习笔记，参考：江小康\n网络通信基础 思考一下，如果计算机想要\u0026quot;交朋友\u0026quot;，它们需要怎样互相沟通？正如人们交流需要使用语言一样，计算机通信也必须遵守一套规则 — 这就是网络协议。\n协议确保信息可以在不同的设备和平台之间清晰、准确地传递。要深入理解协议，我们首先要熟悉两个基础的通信模型：OSI 和 TCP/IP 模型。\nOSI 模型和 TCP/IP 模型 在网络通信的世界里，OSI（开放式系统互联通信参考模型）和 TCP/IP（传输控制协议/网际协议）模型扮演着基础框架的角色。它们各自描述了网络通信的多个层次和阶段，但以不同的方式来分类和处理数据传输的细节。\nOSI模型\nOSI（Open Systems Interconnection）模型是一个概念性框架，用于描述网络中不同操作层次的功能。由七层组成，从物理硬件的电气信号（物理层），到应用层（如网页浏览器），每一层都有其独特的功能和协议。\nTCP/IP模型\nTCP/IP 模型，则更加贴近实际网络中的运作。Linux 的网络协议栈就是基于该模型实现的。它是基于四层架构，将网络通信过程简化并集中在协议族上，如传输控制协议（TCP）和互联网协议（IP），这两种协议是现代网络通信中最为核心的部分。\n简单图示：\n基本概念 地址簿：IP地址和MAC地址 想象一下，互联网是一个巨大的数字城市，而每台计算机或网络设备就像是住在这个城市里的居民。\nIP地址：数字世界的\u0026quot;家庭住址\u0026quot;\n每台设备的 IP 地址就像是它在这个数字城市里的家庭住址。当计算机需要发送信息或访问网络资源时，它会使用目的地设备的 IP 地址来确保信息正确地送达。这个地址有点像是我们现实世界中的邮寄地址，可以根据网络环境的变化而变化（例如，当设备从家庭网络移动到办公室网络时）。\nMAC地址：网络中的\u0026quot;身份证\u0026quot;\n然后，我们有 MAC 地址，这是网络设备的另一个关键标识。每台设备的 MAC 地址都是独一无二的，类似于每个人的身份证号码。它是在设备制造时就被分配的，并且在大多数情况下，这个地址是固定不变的。MAC 地址在本地网络（如家庭或办公室网络）内起着重要作用，它帮助确保信息被准确地送达到特定设备，就像邮递员需要知道收件人的详细身份信息才能将包裹准确递交。\n总结一下：ip 地址可以让数据包找到目的主机所在的网络，而 MAC 地址确保数据包能准确送到目的主机上。\n导航路线：子网掩码和网关 子网掩码：定位网络的\u0026quot;区域地图\u0026quot;\n子网掩码可以被视为定位网络内部和外部地址的\u0026quot;区域地图\u0026quot;。就像在一个大城市中，你需要知道哪些街道属于你的社区，哪些通往城市的其他部分。子网掩码帮助计算机确定一个 IP 地址是属于本地网络（即同一个子网）还是位于外部网络。\n内部导航：如果目的地IP地址与计算机所在的子网相匹配（根据子网掩码判断），则数据包在本地网络内传送。 外部导航：如果目的地不在本地子网内，计算机知道它需要将数据发送到更远的目的地。 网关：网络间的\u0026quot;中转站\u0026quot;\n网关在网络通信中扮演中转站的角色。当你的数据包需要从一个网络（比如你的家庭网络）发送到另一个网络（比如你的工作地点的网络）时，网关是这个旅程的第一站。\n路由决策：网关检查数据包的目的 IP 地址，然后使用它的路由表来决定最佳的路径将数据包发送到目标网络。 总结： 子网掩码和网关共同协作，帮助数据包在复杂的网络结构中找到最有效的路径。子网掩码确定数据包是否在本地网络内，而网关指导跨网络的数据传输。\n端口 ：确保数据到达正确的\u0026quot;应用程序门牌号\u0026quot; 好了，现在我们的数据包已经知道了去哪里，但它如何确保被正确的程序接收呢？这就是端口登场的时候了。端口号就像是收件人的门牌号，确保数据不只是送到了正确的地址，而且被正确的应用程序接收。\nLinux 套接字编程 套接字是什么 在网络编程中，套接字就像是网络世界的通信端口。每一个联网的应用程序，为了能够互发消息，都会使用到这样一个端口。这个端口允许数据从一个程序流向另一个程序。简而言之，套接字是应用程序用来在网络上交流的桥梁。\n想象一下，你要用手机给朋友发一条信息。你只需要知道他们的手机号码，这样信息就可以直接发送到他们的手机上。在网络编程中，套接字的作用类似。它使用IP地址 （类似于手机号码） 来确定数据发送的目标位置，而端口号则像是确定信息应该送达到对方手机中的哪个应用程序。这样，套接字（使用 ip 地址和端口）确保了数据能够准确地发送给正在监听那个特定端口的程序。\n套接字的工作原理：\n套接字的工作原理就像是电话通话的过程。首先，你需要拨打一个号码（即IP地址+端口号）来建立连接。一旦连接建立，电话线（网络连接）就激活了，你的声音（数据）就可以通过它传送。\n在这个过程中：\n拨号对应于网络编程中的连接建立，这是通过调用套接字API来完成的，比如 connect( )函数。\n通话对应于数据传输，你可以通过套接字发送 send( ) 和接收 recv( )数据。\n挂断对应于结束连接，完成通信后，你需要关闭套接字 close( )函数，以结束会话并清理资源。\n在整个通信过程中，套接字保证了数据从一个程序准确地传送到另一个程序，无论这两个程序是在同一台计算机上还是跨越了广阔的互联网。\n在 Linux 中，套接字其实就是一系列的编程接口，Linux 提供了很多特定的 API 来创建和使用套接字，接下来，让我们学习如何使用 Linux 套接字 api 来编写各种网络服务程序。\n套接字类型 在 Linux 中，有三种套接字类型，前两种是重点掌握的，第三种了解即可。\nTCP套接字 (SOCK_STREAM):\n这是一种可靠的套接字连接，保证数据传输的完整性和顺序。 必须先建立连接，才能传输数据。 常用于需要准确数据传输的应用，如网页浏览和文件传输。 UDP套接字 (SOCK_DGRAM):\n不需要建立连接，但是数据传输可能会丢失，没有先后顺序。 适用于视频流和在线游戏，这些应用可以容忍一定的数据丢失。 原始套接字 (SOCK_RAW):\n允许直接对较低层次的协议如 IP 或 ICMP 进行访问和操作，它绕过了 TCP 和 UDP 的处理。 开发者可以使用原始套接字来构建自定义的协议或直接处理来自网络的数据包。 通常用于需要进行网络诊断或网络安全应用，如自定义的ping实现，或者网络嗅探器。 选择哪种类型取决于你的应用需求—是否需要可靠传输（TCP），还是速度更快但可能丢失数据也没关系（UDP）。\n选择使用原始套接字通常意味着你需要对网络协议有深入的理解，因为你将直接与网络层面的数据交互。这比处理 TCP 和 UDP 套接字更复杂，通常只在特殊情况下使用，例如网络工具的开发或定制协议的实现。\n套接字常用 API 接下来，看下常用的套接字 API：\n1 2 3 4 5 6 7 8 9 socket() : 创建套接字 bind() : 绑定套接字到本地地址 listen() : 监听网络连接 accept() : 接受网络连接 connect() : 连接到远程主机 send(), recv() : 发送和接收数据（面向连接的套接字） sendto(), recvfrom() : 发送和接收数据（无连接的套接字） close() ,shutdown() : 关闭套接字 getsockopt(), setsockopt() : 获取和设置套接字选项 套接字地址结构以及地址转换 API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* sockaddr 是一个通用的套接字地址结构，它通常与特定的地址族结构（如 sockaddr_in ）一起使用。 这是因为多数套接字函数，如 bind(), connect(), 和 accept()，需要使用指向 sockaddr 结构的指针的参数。 */ struct sockaddr { sa_family_t sa_family; /* Address family */ char sa_data[]; /* Socket address */ }; // 套接字地址结构（适用于IPv4网络通信的地址结构） struct sockaddr_in { sa_family_t sin_family; # address family: AF_INET in_port_t sin_port; # port in network byte order struct in_addr sin_addr; # ip address }; struct in_addr { uint32_t s_addr; # address in network byte order }; /* 网络地址转换函数 (用于将IP地址在可打印的格式和二进制结构之间转换) inet_pton() 将点分十进制的IP地址（如\u0026#34;192.168.1.1\u0026#34;）转换成网络字节顺序的二进制形式 inet_ntop() 将网络字节顺序的二进制IP地址转换为点分十进制字符串格式 */ # demo 示例: #define INET_ADDRSTRLEN 16； char str[INET_ADDRSTRLEN]; struct in_addr ipv4addr; inet_pton(AF_INET, \u0026#34;192.168.1.1\u0026#34;, \u0026amp;ipv4addr); inet_ntop(AF_INET, \u0026amp;ipv4addr, str, INET_ADDRSTRLEN); printf(\u0026#34;The IPv4 address is: %s\\n\u0026#34;, str); 字节序转换 API 在网络编程中，字节序（也称为端序）指的是数值在内存中保存的顺序。不同的计算机体系结构可能会采用不同的字节序来表示数据。最常见的两种字节序是大端字节序（Big-Endian）和小端字节序（Little-Endian）。在网络通信中，为了确保数据在不同的系统间正确传输和解释，定义了一个统一的字节序，即：网络字节序，它采用大端字节序。\n由于主机字节序与网络字节序可能不同，因此在发送数据前，发送方需要将其主机字节序的数值转换为网络字节序；接收方收到数据后，需要将网络字节序的数值转换回主机字节序。\nLinux 提供了一组 API 来处理字节序的转换：\n1 2 3 4 // 将无符号长整型数/无符号短整型数从主机字节顺序转换为网络字节顺序。 htonl() 和 htons() // 将一个无符号长整型数/无符号短整型数从网络字节顺序转换为主机字节顺序。 ntohl() 和 ntohs() 为了方便记忆，大家可以这样理解：h 代表 host(主机)，n 代表 network(网络);\nl 代表 long(四字节：代表ip)，s 代表 short（两字节：代表端口）。\n以 htons() 举例，host to network short 即：将端口从主机字节序转成网络字节序。\n注意：htonl 和 ntohl 一般处理的是 IP 地址，而 htons 和 ntohs 一般处理的是端口。\nLinux 常见的 IO 模型 前面我们已经学习了 Linux 基础的 socket API，这样我们便可以编写简单的网络服务程序。但现在，我们面临一个新挑战：如何利用有限的服务器资源，来同时高效处理大量的并发请求呢？\n传统的单线程处理方式在现代网络服务中已不合时宜，因为它无法同时处理多个请求，导致效率低下。为了突破这一限制，我们需探究 Linux 提供的各种 I/O 模型。这些模型提供了从阻塞到非阻塞，从多路复用到完全异步的不同解决方案，以适应各种网络应用场景，确保服务器在面对大量请求时也能保持高效运行。\n在讨论这些 IO 模型之前，我们先简单回顾一下 I/O 是什么：\n在计算机中，\u0026ldquo;I/O\u0026quot;就是输入和输出的简称，它描述了数据在计算机系统和外部世界之间的流动。具体来说：\n输入：数据进入计算机，比如你在键盘上敲击字母时，字母被读入计算机。\n输出：数据离开计算机，例如屏幕上显示信息。\n当提到网络时，\u0026ldquo;I/O\u0026quot;扩展了含义：\n网络输入：从外部网络接收数据到你的本地计算机，如通过网络下载文件到你的计算机。\n网络输出：这是指将数据从你的本地计算机发送到外部网络，比如通过计算机发送文件给你的好友。\n简而言之，I/O 是数据在计算机和其他设备或网络之间传递的方式。\n用户进程如何进行 IO 操作？\n让我们通过一个示意图来直观展示用户进程如何从网络获取数据并将其存储到磁盘的整个过程：\n从上图我们也能够清楚的看到，进程进行一次 I/O 操作需要经过两个步骤:\n以 read 读操作为例：\n第一步：等待网络数据的到来\n当网络数据到达时，网络接口卡（NIC）首先通过直接内存访问（DMA）将数据传输到内核空间分配的 socket 接收缓冲区中，无需 CPU 参与。\n第二步：CPU 复制数据至用户空间\n一旦数据通过 DMA 传输到内核的 socket 接收缓冲区，用户进程的 read 系统调用会被唤醒（如果它在等待数据的话）。接下来，CPU 会介入，将数据从内核缓冲区复制到用户空间提供的缓冲区中。\n也就是说，在 I/O 操作的过程中，存在两个潜在的等待时间点 ：一个是等待网络数据到达 socket 接收缓冲区，另一个是等待 CPU 复制数据至用户空间。\n为了减少这些等待时间对应用程序性能的影响，Linux 提供了五种 I/O 模型，它们分别针对这两个步骤的效率问题提供不同的解决方案。\n接下来，我们将深入了解 Linux 支持的五种 I/O 模型:\n阻塞IO（Blocking I/O） 简单图示：\n在阻塞 I/O 中，进程在等待网络数据到达和内核复制数据到用户空间这两个步骤中都需要等待。当一个进程发起 I/O 请求时，它会一直等待直到数据被复制到它的应用层缓冲区中，然后才继续执行。\n非阻塞I/O（Non-blocking I/O） 简单图示：\n在非阻塞 I/O 模型中，当进程尝试从 socket 读取数据时，如果数据尚未到达，read调用不会阻塞进程。相反，它会立即返回一个 EWOULDBLOCK 或 EAGAIN 错误。也就是说，进程不需要等待网络数据到达 socket 接收缓冲区就可以返回继续执行其他任务。\n一旦数据到达并存储在内核缓冲区中，而当进程尝试再次读取，这次 read 操作将成功，并将数据从内核空间复制到用户空间，但这里的数据复制过程是需要等待的。\n总结一下：在非阻塞 I/O 模型中，进程需要等待 socket 数据从内核空间复制到用户空间。 而在等待网络数据到达 socket 接收缓冲区这个时间点是不需要等待的。但是进程需要不断地\u0026quot;轮询\u0026quot;文件描述符，检查 socket 接收缓冲区是否有数据，频繁的轮询可能会导致 CPU 资源的浪费。\nI/O多路复用（I/O Multiplexing） 简单图示：\n工作原理：\nI/O 多路复用允许一个进程或线程同时监控多个网络 sockets 的状态。它通过单个系统调用（select）来检查多个 sockets 是否有数据可读、可写或是否有异常。Linux 提供了多种 I/O 复用技术，包括上面提到的 select、以及 poll、epoll。\n那 I/O 多路复用是如何减少上述提到的两个潜在的等待时间的？\n等待网络数据到达\n在 I/O 多路复用模式下，进程不会在单个 socket 上阻塞等待数据到达。相反，当任何一个被监控的 socket 接收到数据，系统调用（如select）会返回。当 select 返回时，它指示一个或多个 sockets 已接收到数据。这意味着数据已经被网络接口卡（NIC）通过 DMA 操作传输到相应的 socket 接收缓冲区中。\n这样，进程不必在每个 socket 上分别等待，而是在多个sockets上集中等待，提高了效率。\n但是，在 I/O 多路复用中， select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达\n等待CPU复制数据至用户空间\n进程随后可以立即对准备就绪的 socket fd 进行 read 操作。因为数据已经在内核的缓冲区中，CPU 只需要将数据从内核空间复制到用户空间。但这个拷贝数据的完成\n也就是说在 I/O 多路复用中，select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达，但是他的优势在于可以监控多个 sockets 的接收缓冲区是否有数据到来。当多个 sockets 的接收缓冲区有数据到来，进程会一直等待 CPU 复制数据至用户空间才能干其他任务。\n信号驱动I/O（Signal-driven I/O） 简单图示：\n信号驱动 I/O 也是属于Linux 中的一种 IO 模型，它允许应用程序在不阻塞等待 I/O 操作完成的情况下继续执行其他任务。当 I/O 操作（如数据的读取或写入）准备就绪时，操作系统会向应用程序发送一个信号，通知它可以开始执行 I/O 操作了。这种模式主要通过使用信号（如 SIGIO）来实现。\n两个等待时间点对信号驱动 I/O 的影响 :\n等待网络数据到达：在信号驱动 I/O 模型中，应用程序在等待数据到达时不需要阻塞等待。它可以继续执行其他任务或处于休眠状态，直到操作系统发出数据已准备就绪的信号（如 SIGIO）。\n等待内核复制数据到用户空间：当应用程序收到信号并开始实际的 I/O 操作（如 read）时，它仍然需要等待操作系统将数据从内核空间复制到用户空间。\n尽管信号驱动 I/O 提供了一种异步通知机制，使得应用程序能够在I/O事件准备好时接收通知，但它在实践中不如其他模型（如IO复用）那么广泛使用，原因包括：\n编程复杂性：使用信号驱动I/O要求程序员熟悉信号处理和非阻塞I/O操作，这增加了编程的复杂性。\n信号合并和丢失\nLinux 信号处理机制通常不会为同一类型的信号排队。这意味着如果在处理一个信号时另一个相同类型的信号发生，后者可能不会触发额外的信号处理调用，导致应用程序可能错过一些I/O事件的通知。这种信号的合并行为限制了信号驱动I/O模型在高并发场景下准确响应每个I/O事件的能力。\n更好的替代方案：对于需要处理多个并发I/O操作的应用程序，I/O复用（特别是epoll）提供了更高的效率和更好的控制。epoll特别适用于高并发场景，并且相对于信号驱动I/O更易于管理和使用。\n异步I/O（Asynchronous I/O） 简单图示：\naio_read 是 POSIX 异步 I/O 接口的一部分，它专门用于执行异步文件读取操作。不太适用于网络 I/O 。因此上面的图示是基于文件读取对异步 IO 的工作过程进行说明的。\n工作原理：\n在异步 I/O 模型中，当应用程序发起一个I/O操作（例如 aio_read 读取）时，它不需要等待操作完成就可以继续执行其他任务。应用程序仅仅是向操作系统发出 I/O 请求，并且当 I/O 操作真正完成时，操作系统会通知应用程序。这种方式允许应用程序更有效地利用 CPU 时间，因为它不需要在 I/O 操作完成前空闲等待。\n那前面提到的两个潜在等待时间对异步 IO 是否会有影响呢？\n等待内核 PageCache 数据准备好：\n在异步 I/O 中，应用程序在发出读写请求后立即返回，不需要等待数据在内核中准备好。这意味着应用程序可以继续执行其他任务，而内核会异步的从磁盘读取数据至内核缓存 PageCache 中。\n注意： 上面我是通过 aio_read 系统调用来说明异步 I/O 的工作原理的，aio_read 是 Linux 的 POSIX 异步 I/O (AIO) 库提供的接口，主要设计用于文件和块设备的异步读写操作，而不支持网络 I/O。因此这里是等待内核的 PageCache 数据准备好而不是等待网络数据准备好，但都可以归纳为等待数据准备好。\n等待CPU复制数据至用户空间：\n一旦数据在 pagecache 中准备好，操作系统负责将这些数据从内核空间复制到用户空间指定的缓冲区。这个复制过程是由内核自动执行的，而不是由用户进程主动复制的。 用户程序不需要等待这一过程的完成，可以继续进行其他工作。只有在数据完全复制到用户空间后，应用程序才会收到一个完成的信号或通知。进而处理拷贝至用户空间的数据。\n也就是说：在异步 IO 中，不管是等待数据准备好还是等待 CPU 复制数据至用户空间，用户进程都不需要等待。\nLinux 网络 I/O 性能优化 在前面的部分，我们探讨了 Linux的 各种I/O模型。每种模型都有其独特的使用场景和性能特点。特别是在网络编程中，选择合适的I/O模型对于提高服务器的处理能力至关重要。但是，仅仅选择合适的I/O模型并不足以确保最佳性能。实际上，网络I/O性能还受到许多其他因素的影响，比如网卡配置、带宽、服务器的并发处理能力等。因此，我们需要进一步优化 Linux 网络 I/O 性能，以确保我们的应用可以充分利用服务器资源，提供更快、更可靠的服务。\n那么，如何优化 Linux 网络 I/O 性能呢？\n网络 I/O 性能优化主要就是从硬件和软件两个方面来进行：\n首先来看下硬件优化：\n硬件优化无非就是提升服务器硬件性能，包括 CPU、网卡配置升级、内存配置升级等。\n使用多核 CPU ：确保服务器有足够的CPU核心来处理高网络负载。 内存升级：增加足够的内存以支持高速网络操作，特别是对于需要大量内存缓存的应用。 网络接口卡：升级NIC：使用更高速率的NIC，例如从1Gbps升级到10Gbps或更高。\n或者使用 NIC 多队列（Multi-queue）：使用支持多队列的NIC，以便分散处理负载到多个CPU核心。 接下来来看下软件优化：\n1.首先来看下应用程序设计，应用程序本身的设计对网络 I/O 性能有着重大影响：\n选择合适的 I/O 模型：\n选择合适的 I/O 模型，根据应用的特点和需求选择合适的 I/O 模型。对于高并发的网络服务，I/O 多路复用（如 epoll、kqueue）通常是最佳选择。它们允许单个线程高效地监控和处理多个网络连接，减少了线程切换的开销。而对于 I/O 密集型的应用，异步 I/O模型可能会更高效，异步 I/O （如 io_uring、libaio）提供了一种不阻塞应用程序主逻辑的方式来处理 I/O 请求。这种模型允许应用程序在 I/O 请求正在处理时继续执行其他任务。\n使用零拷贝技术：\n传统的数据传输过程涉及多次数据拷贝，包括从内核缓冲区到用户缓冲区。零拷贝技术（如 sendfile）可以减少这些拷贝操作，直接在内核中处理数据，从而减少 CPU 使用和提高效率。\n批量处理和缓冲 : 聚集数据，以减少网络交互和磁盘操作的次数。\na:聚集数据：通过累积数据到达一定量后再进行处理，而不是每次接收到数据就立即处理。以读取网络数据下载至本地磁盘为例：可以等待数据积累到一定量的时候在写入磁盘，这样可以减少磁盘 I/O 次数。\nb.缓冲区管理：需要合理管理缓冲区，以避免溢出，并在适当的时候重置或清空缓冲区。\nc.适用场景：这种模式适合于数据量大、数据频繁到达的场景，如日志收集、批量数据处理等。\n并发和并行处理：利用多核处理器的优势，通过多线程或多进程来提高并发处理能力。\n2. 接下来看下关于操作系统方面的调整，操作系统级别的调整对于优化网络 I/O 也是至关重要的\n增加文件描述符限制：对于高并发的网络服务器，提高文件描述符的限制是必要的，以避免因达到文件描述符上限而无法接受新连接。你可以通过 ulimit -n 命令或修改 /etc/security/limits.conf 文件来增加这个限制。\n调整 TCP 协议栈参数：常见的 TCP协议栈参数有如下的几类：\na：缓冲区大小和资源管理：\n这些参数控制 TCP 缓冲区的大小和整体 TCP 缓冲区的资源管理，以优化数据传输性能和内存使用。\ntcp_rmem 和 tcp_wmem ：分别控制 TCP 接收和发送缓冲区的大小。\ntcp_mem ：控制整体 TCP 缓冲区在系统范围内的使用情况。\nb: 连接建立和终止：\n这类参数涉及 TCP 连接的建立过程和连接终止时的行为。\ntcp_syn_retries 和 tcp_synack_retries : 分别控制 TCP SYN 连接请求和 SYN-ACK 包的重试次数。\ntcp_fin_timeout ： tcp_fin_timeout 参数设置了 TCP 连接在 FIN-WAIT-2 状态下的超时时间。这个参数定义了在一个 TCP 连接被本地端关闭后，系统等待对方发送 FIN 包以完成连接终止过程的最长时间。如果在这个超时时间内没有收到对方的 FIN 包，连接将被强制关闭。\nc :连接保活和状态管理：\n这些参数用于检测和维持空闲连接，以及管理连接状态。\ntcp_keepalive_time ：设置在开始发送 keepalive 探测之前，一个 TCP 连接必须处于空闲状态的时间。\ntcp_keepalive_probes ：设置在断开连接之前，最多发送多少个 keepalive 探测包。\ntcp_keepalive_intvl ： 设置两个连续 keepalive 探测包之间的时间间隔。\ntcp_tw_reuse : 设置允许在 TIME_WAIT 状态的套接字上的端口被重新用于新的连接。\nd:性能优化 : 这些参数用于提升网络性能，减少延迟。\ntcp_nodelay : 禁用 Nagle 算法，减少发送小块数据的延迟。（Nagle 算法是一种为了减少网络上小数据包数量而设计的 TCP 特性。它通过累积较小的数据包并将它们组合成更大的数据块来发送，从而减少了网络上的总数据包数量）。\ntcp_max_syn_backlog : 设置 SYN 接收队列的最大长度，优化高并发连接的接收。\n除了 SYN 接收队列，TCP 连接还涉及到一个\u0026quot;已连接队列\u0026rdquo;（也称为 accept 队列），该队列用于存储已经完成三次握手、等待应用程序 accept 的连接。\n/proc/sys/net/core/somaxconn： 该参数控制着已连接队列的最大长度。\n调整方法:\n这些参数通常通过修改 /etc/sysctl.conf 文件或使用 sysctl 命令进行调整。例如：\n1 2 sysctl -w net.ipv4.tcp_rmem=\u0026#39;4096 87380 6291456\u0026#39; sysctl -w net.ipv4.tcp_wmem=\u0026#39;4096 16384 4194304\u0026#39; 注意： 调整这些参数时，应谨慎考虑系统的整体资源和应用的具体需求。不恰当的设置可能导致性能下降或系统资源耗尽。在生产环境中应用更改前，最好在测试环境中进行充分的测试。\nLinux 常见的服务器模型 服务器模型是网络服务器程序设计的基石，它决定了服务器如何管理多个客户端的连接和请求。接下来，让我们来看看 Linux 下的几种常见的服务器模型是怎样工作的？\n单进程服务器：一对一服务 在单进程服务器模型中。服务器使用一个主进程来逐个处理客户端的连接请求。这意味着，当服务器正在服务一个客户端时，其他客户端必须等待直到当前客户端服务结束。\n图示：\n单进程回射服务器示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server_fd = socket(); bind(); listen(); // The main server loop while (1) { newsockfd = accept(server_fd，...); memset(buffer, 0, 256); // Read and write to the connection in a loop while (1) { n = read(newsockfd, buffer, 255); if (n == 0) break; // If read returns 0, the client has closed the connection // printf(\u0026#34;Client: %s\\n\u0026#34;, buffer); write(newsockfd, buffer, strlen(buffer)); } close(newsockfd); } 缺点：\n无法实现并发： 单进程服务器在任何时刻只能处理一个客户端的请求。这意味着如果有多个客户端同时请求服务，除了第一个之外的所有请求都必须等待，这限制了服务器的并发处理能力。\n性能瓶颈： 由于服务器在处理当前请求时无法接受新的连接，这会导致服务器对其他客户端的响应时间延长，特别是在高流量的情况下，效率低下。\n资源利用不充分： 在多核心处理器上，单进程模型无法充分利用多核的优势，因为它只在一个核心上运行，没有并行处理能力。\n多进程服务器 了解了单进程服务器模型的缺点后，我们自然会寻求更高效的方案来处理多客户端并发的情况。这就引出了多进程服务器模型，它是解决单进程模型限制的常见方案。\n在多进程模型中，服务器为每个新的客户端连接创建一个独立的进程。这允许服务器同时处理多个客户端请求，极大地提高了并发处理能力和资源利用率。\n图示：\n多进程回射服务器示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 server_fd = socket(); bind(); listen(); while(1) { int new_socket =accept(server_fd, ...); int pid = fork(); if(pid \u0026lt; 0) { close(new_socket); } else if(pid == 0) { close(server_fd); // Child does not need the listener handle_client(new_socket); } else { close(new_socket); // Parent does not need this socket } } void handle_client(int new_socket) { char buffer[1024]; int bytes_read; while(1) { bytes_read = read(new_socket, buffer, sizeof(buffer)); if (bytes_read \u0026lt;= 0) { break; // Break the loop if read error or end of file } write(new_socket, buffer, bytes_read); } close(new_socket); exit(0); } 多进程服务器优点：\n稳定性: 多进程服务器中，每个进程是独立的。如果一个进程崩溃，通常不会影响到其他进程，从而提高了服务器的整体稳定性。\n隔离性: 每个进程有自己的地址空间，这意味着进程之间的内存是隔离的。这样可以防止某个进程的错误操作影响到其他进程。\n利用多核优势: 多进程模型能够在多核处理器上运行，每个进程可以被操作系统调度到不同的CPU核心上，充分利用硬件资源。\n缺点：\n资源消耗: 每个进程都需要一定量的内存和系统资源，如果进程数过多，会占用大量的系统资源，这可能导致服务器的性能下降。\n上下文切换开销: 多进程意味着操作系统需要频繁地在进程之间进行上下文切换，这个过程涉及到保存和加载寄存器、更新各种表等操作，会消耗一定的CPU时间。\n多线程服务器 虽然多进程模型提高了服务器的稳定性和隔离性，但它也带来了资源消耗、上下文切换开销等限制。针对多进程模型的这些限制，多线程服务器模型提供了一个更为高效的解决方案。\n多线程服务器模型在同一个进程内创建多个线程来处理客户端请求，每个线程能够独立执行，它们共享进程的资源，如内存空间等资源。而且上下文切换也更快。\n图示：\n多线程回射服务器的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 server_fd = socket(); bind(server_fd, ...); listen(server_fd, ...); while (1) { int new_socket = accept(server_fd, ...); pthread_t thread_id; if (pthread_create(\u0026amp;thread_id, NULL, handle_client, (void*)\u0026amp;new_socket) != 0) { // Handle error } } void* handle_client(void* socket) { int new_socket = *(int*)socket; char buffer[1024]; int bytes_read; while (1) { bytes_read = read(new_socket, buffer, sizeof(buffer)); if (bytes_read \u0026lt;= 0) { break; // Break the loop if read error or end of file } write(new_socket, buffer, bytes_read); } close(new_socket); pthread_exit(NULL); } 多线程服务器优缺点：\n资源效率: 线程共享进程的内存空间，相较于多进程模型，多线程服务器在内存和资源上的开销更小。 上下文切换效率: 线程间的上下文切换比进程间的切换要快，因为线程共享许多资源，切换时所需的资源较少（线程切换一般只需要切换各自寄存器和栈上的数据）。 利用多核优势: 线程可以分布在多个 CPU 核心上运行，这使得多线程服务器能够充分利用多核 CPU 的计算能力。 缺点：\n同步复杂性: 因为线程共享内存和资源，所以必须仔细设计同步机制来避免竞态条件和其他并发问题。 稳定性风险: 一个线程的错误可能影响整个进程，因为它们共享同一内存空间。这可能导致整个服务器程序崩溃。 资源限制: 虽然线程比进程轻量，但大量线程仍然会消耗大量系统资源，尤其是在高并发情况下。 调试困难: 多线程程序的调试较为复杂，尤其是当出现了线程安全问题时，这些问题可能难以重现和定位。 线程池模型 在多线程服务器模型中，每个客户端请求都由一个新的线程来处理。这种方法虽然有效，但在面对大量并发请求时，频繁地创建和销毁线程会导致服务器的性能下降。 特别是在请求数量剧增的情况下，线程创建和销毁的开销会变得显著，同时过多的活跃线程也会竞争有限的CPU和内存资源，进一步影响服务的响应时间和吞吐量。\n而在线程池模型中，服务器启动时会预先创建一定数量的线程，这些线程存放在池中，并不立即执行任务。当客户端请求到达时，请求会被分配给线程池中的一个空闲线程，该线程负责处理整个请求过程。处理完毕后，线程并不销毁，而是返回到池中等待处理下一个请求。\n图示：\n说明：\n服务器（Server）：这是整个流程开始的地方。服务器初始化一个线程池，并不断监听客户端的连接请求。当一个客户端连接请求到来时，服务器接受这个连接（accept()），然后把相应的任务（job：一般是读写客户端数据的逻辑）添加到线程池的任务队列中去。最终，当服务器不再需要线程池时，会销毁它。\n线程池（ThreadPool）：线程池是预先创建的线程集合，用于执行多个任务。它分为两个主要部分：\n任务队列（Job Queue）：这里存放所有待处理的任务（jobs）。当服务器接受一个客户端的连接，它会创建一个任务，并将其添加到这个队列中。 线程队列（Thread Queue）：这里存放的是线程池中所有可用的线程。当任务队列中有任务时，线程池会分配一个线程去执行这个任务。 客户端（Clients）：客户端通过网络连接与服务器进行通信。\nI/O多路复用服务器 什么是 I/O 多路复用？\n在 Linux 中，I/O 多路复用是一种允许单个进程或线程同时监控多个文件描述符（通常是网络套接字）上的读写就绪状态的技术。这使得程序能够在一个或多个文件描述符上发生 I/O 事件时被通知，从而对这些事件作出响应（比如进行读写操作）。这种机制极大地提高了处理多个并发网络连接的效率，因为它允许使用较少的系统资源（如进程和线程）来管理大量的连接。\n上面我们在讲解 I/O 模型的时候，提到了 IO 多路复用，而在讲解服务器模型我们又再次提到了IO 多路复用。可能大家会有疑问：IO 多路复用到底属于 I/O 模型还是服务器模型？\n其实 I/O 多路复用技术是两者之间的桥梁：它是一种有效的 I/O 处理方式，同时也是构建服务器模型的基础。\nI/O 多路复用作为 I/O 模型，关注的是如何有效地管理和执行 I/O 操作，特别是在涉及多个 I/O 源（如网络套接字）时。 I/O 多路复用作为服务器模型，则是在这种 I/O 操作的管理方式基础上构建整个服务器的架构，决定如何接收和处理多个客户端请求，如何分配处理程序来响应这些请求，以及如何利用系统资源。 简单来说，I/O 模型是关于\u0026quot;如何执行 I/O\u0026quot;的，而服务器模型是基于某种 I/O 模型来构建服务的，以及如何组织服务器程序以响应客户端请求。\n常见的 I/O 多路复用技术：\nLinux 提供了多种 I/O 多路复用的机制，如 select, poll, 和 epoll。这些技术的主要区别在于它们处理大量文件描述符的方式和效率。\nIO 复用之 Select 基本概念：\nLinux 中的 select 函数是一种常用的 I/O 复用技术。它允许程序监视多个文件描述符（FDs），以检测是否有任何一个或多个 FD 准备好进行读取、写入或是否有异常发生。这种技术特别适用于同时处理多个网络连接或其他类型的 I/O 操作（如：文件I/O）。\n函数声明\nselect 函数的基本声明如下：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;sys/select.h\u0026gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); /* 参数结构 nfds：监视的文件描述符集合中最大的文件描述符加一。 readfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行读操作。 writefds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行写操作。 exceptfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 有异常发生。 timeout：指定 select 等待准备就绪的 FD 的最长时间。 */ fd_set 是一个文件描述符数组，用于指示 select 函数应该监视的 FDs。\nfd_set 结构图解展示：\n说明：\n参数 readfds、writefds、exceptfds 从用户空间传入内核空间和从内核空间返回用户空间，文件描述符数组中的值代表的含义不同：\n以可读事件 readfds 为例：\n从用户空间传入内核空间：数组值为 0 代表不监控该文件描述符（fd），数组值为 1 代表要监控该文件描述符（fd）。\n从内核空间返回用户空间：数组值为 0 代表该文件描述符数据未准备就绪，数组值为 1 代表该文件描述符数据准备就绪。用户进程可以进行读操作了。\nselect 并发回射服务器程序示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #define PORT 8080 #define MAX_CLIENTS 30 int main() { int server_fd, new_socket, client_socket[MAX_CLIENTS]; struct sockaddr_in address; int addrlen = sizeof(address); fd_set readfds; int max_sd, sd, activity, i, valread; char buffer[1025]; // 数据缓冲区 // 初始化所有客户端套接字 for (i = 0; i \u0026lt; MAX_CLIENTS; i++) { client_socket[i] = 0; } // 创建套接字 server_fd = socket(AF_INET, SOCK_STREAM, 0) // 绑定套接字 address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); bind(server_fd, (struct sockaddr *)\u0026amp;address, sizeof(address))\u0026lt;0 // 监听套接字 listen(server_fd, 3) while (1) { FD_ZERO(\u0026amp;readfds);// 清空 fd_set FD_SET(server_fd, \u0026amp;readfds); // 添加 server_fd 到 fd_set max_sd = server_fd; // 添加客户端套接字到 fd_set for (i = 0; i \u0026lt; MAX_CLIENTS; i++) { sd = client_socket[i]; if (sd \u0026gt; 0) { FD_SET(sd, \u0026amp;readfds); } if (sd \u0026gt; max_sd) { max_sd = sd; } } // 使用 select 监听套接字 activity = select(max_sd + 1, \u0026amp;readfds, NULL, NULL, NULL); // 接受新连接 if (FD_ISSET(server_fd, \u0026amp;readfds)) { if ((new_socket = accept(server_fd, (struct sockaddr *)\u0026amp;address, (socklen_t*)\u0026amp;addrlen))\u0026lt;0) { // 错误处理并退出 } // 将新套接字添加到数组 for (i = 0; i \u0026lt; MAX_CLIENTS; i++) { if (client_socket[i] == 0) { client_socket[i] = new_socket; break; } } } // 其他套接字的数据处理 for (i = 0; i \u0026lt; MAX_CLIENTS; i++) { sd = client_socket[i]; if (FD_ISSET(sd, \u0026amp;readfds)) { // 检查是否是断开连接，否则接收数据 if ((valread = read(sd, buffer, 1024)) == 0) { close(sd); client_socket[i] = 0; } else { buffer[valread] = \u0026#39;\\0\u0026#39;; // 将接收到的数据发送回客户端 send(sd, buffer, strlen(buffer), 0); } } } return 0; } select优缺点：\n优点:\n能够同时监视多个套接字: select 允许服务器以单线程的方式监视多个套接字，来检测它们是否有可读、可写或异常条件发生。\n无需多线程或多进程：select 采用单线程的处理方式，使用 select 可以避免复杂的多线程或多进程管理，减少了上下文切换的开销，简化了并发处理。\n适用于小到中等规模的负载：对于不是很高的并发连接数（几百的连接数），select 通常可以满足需求，且效率不错。\n缺点:\n文件描述符限制：select 可以监视的文件描述符数量是有限的，通常由 FD_SETSIZE 常量决定，这在很多系统上默认是1024。这限制了服务器可以处理的最大并发连接数。当然 select 也会受限于系统级别的文件描述符数量限制。\n效率问题：随着文件描述符数量的增加，select 的性能会线性下降。每次调用select时，都需要重新传入整个文件描述符集合，内核需要遍历这个集合来更新状态，这在文件描述符很多时会成为瓶颈。\n响应时间变长：在 select 返回的文件描述符列表集合中，如果有多个文件描述符同时变为活跃状态，服务器通常会按顺序处理它们。这可能导致对列表前面的连接有偏见，使得后面的连接等待时间较长。\nIO 复用之 Poll 基本概念：\npoll 也是一种 IO 复用技术，用于监视多个文件描述符（通常是网络套接字）的可读性、可写性和异常状态。与 select 类似，poll 允许您的程序监视多个文件描述符，直到一个或多个文件描述符准备好进行 IO 操作。这使得您可以同时管理多个网络连接，而不是逐个阻塞地处理它们。\n函数声明\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;poll.h\u0026gt; int poll(struct pollfd *fds, nfds_t nfds, int timeout); 参数说明： /* fds：指向一个 pollfd 结构数组的指针，该数组包含要监视的文件描述符及其请求的事件（如 POLLIN 表示可读，POLLOUT 表示可写）。 nfds：指定数组 fds 中的元素数量。 timeout：指定等待时间（毫秒）。特殊值有：0 立即返回（非阻塞），-1 无限等待直到某个事件发生。 */ pollfd 结构\npoll 函数使用 pollfd 结构来指定要监视的文件描述符和事件类型：\n1 2 3 4 5 6 7 8 9 struct pollfd { int fd; // 文件描述符 short events; // 请求的事件 short revents; // 实际发生的事件 }; fd：文件描述符 events：要监视的事件，如 POLLIN、POLLOUT revents：由 poll 函数设置，表明哪些事件实际发生了 Poll 底层采用的数据结构图解\n底层数据结构：\n用户空间数组：用户空间程序使用数组（类型为 struct pollfd）来提供要监视的文件描述符及其感兴趣的事件\n但在内核中，为了有效地处理这些文件描述符，poll 的实现转而使用链表。\n内核空间链表：\n当 poll 系统调用被执行时，内核首先将这个数组中的数据复制到内核空间。 在内核中，为了更灵活地处理可能的大量文件描述符，这些 pollfd 结构被组织成链表形式。 链表的每个节点可能包含一个或多个 pollfd 结构，具体取决于可用的内存和文件描述符的数量。 poll 优缺点：\n优点：\n无内置文件描述符限制：与 select 不同，poll 不受文件描述符数量的限制。select 通常受限于 FD_SETSIZE，这在处理大量并发连接时可能成为瓶颈。但它仍然受限于系统级别的文件描述符限制。\n简化的接口：poll 使用单个结构体数组来表示所有监视的文件描述符和相关事件，相比 select 需要使用三个文件描述符集（读、写、异常），接口更为简洁。\n更直观的事件模型：poll 使用位字段来表示不同的事件类型，这使得事件模型比 select 的方式更直观和易于理解。\n缺点：\n线性扫描开销：poll 在处理文件描述符时，需要对整个数组进行线性扫描。当监视的文件描述符数量非常大时，这可能导致性能下降。\n总的来说，poll 是 select 的一种改进，特别是在可处理的文件描述符数量上没有限制，但在高性能和大规模并发处理方面，epoll 在现代 Linux 系统上通常是更佳的选择。\npoll 并发回射服务器程序示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #define PORT 8080 #define MAX_CLIENTS 30 #define BUFFER_SIZE 1024 int main() { int listen_fd, new_socket, valread; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); char buffer[BUFFER_SIZE]; struct pollfd client_fds[MAX_CLIENTS]; // 创建监听套接字 listen_fd = socket(AF_INET, SOCK_STREAM, 0)； // 绑定套接字 address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); bind(listen_fd, (struct sockaddr *)\u0026amp;address, sizeof(address) listen(listen_fd, 3); // 开始监听 // 初始化 pollfd 结构 for (int i = 0; i \u0026lt; MAX_CLIENTS; i++) { client_fds[i].fd = -1; } client_fds[0].fd = listen_fd; client_fds[0].events = POLLIN; // 主循环 while (1) { int activity = poll(client_fds, MAX_CLIENTS, -1); if (activity \u0026lt; 0) { //出错处理并退出 } // 检查是否有新的连接 if (client_fds[0].revents \u0026amp; POLLIN) { if ((new_socket = accept(listen_fd, (struct sockaddr *)\u0026amp;address, (socklen_t*)\u0026amp;addrlen)) \u0026lt; 0) { //出错处理并退出 } // 添加新的套接字到数组 for (int i = 1; i \u0026lt; MAX_CLIENTS; i++) { if (client_fds[i].fd == -1) { client_fds[i].fd = new_socket; client_fds[i].events = POLLIN; break; } } } // 检查客户端活动 for (int i = 1; i \u0026lt; MAX_CLIENTS; i++) { if (client_fds[i].fd \u0026gt; 0 \u0026amp;\u0026amp; (client_fds[i].revents \u0026amp; POLLIN)) { if ((valread = read(client_fds[i].fd, buffer, BUFFER_SIZE)) \u0026gt; 0) { buffer[valread] = \u0026#39;\\0\u0026#39;; send(client_fds[i].fd, buffer, valread, 0); } else { close(client_fds[i].fd); client_fds[i].fd = -1; // 标记为可用 } } } } return 0; } IO 复用之 Epoll 【Linux】IO 多路复用 epoll\n异步I/O服务器模型 在讲述了 I/O 多路复用服务器模型后，我们看到它如何使单个进程能够有效地管理多个网络连接。通过 select、poll 或 epoll，进程可以在多个连接上同时等待数据，而无需为每个连接阻塞等待。这种方法提升了并发处理的效率，但它有一个局限性：一旦某个连接的 I/O 操作开始，该进程必须等待该操作完成才能继续处理下一个连接。 简单理解就是：处理各个连接的 IO 读写是同步的，是串行的。\n为了解决这一问题，引入了异步I/O服务器模型。这种模型极大提升了服务器的任务处理能力，它允许进程在发起I/O操作后立即转而执行其他工作，而无需等待I/O操作的完成。这一过程由操作系统在后台管理，一旦I/O操作完成，进程便会收到通知。进程只需要去处理已被拷贝至应用层缓冲区的数据。\nLinux中的异步I/O实现：\n在Linux中，异步 IO 模型主要由 Linux aio（通过libaio库）和 io_uring 两种技术来实现。\nLinux aio(libaio)\nLinux aio 是 Linux 系统中较早支持的异步I/O机制。它通过 libaio 库提供了一系列的API，允许应用程序非阻塞地启动和管理I/O操作。当一个I/O请求被提交后，libaio负责将其发送到操作系统，应用程序可以继续执行而无需等待。一旦I/O操作完成，应用程序将通过回调函数或其他机制得到通知。\nlibaio提供的 API :\n1 2 3 4 io_setup ：创建一个异步I/O上下文。 io_submit ：向异步I/O上下文提交一个或多个I/O请求。 io_getevents ：从异步I/O上下文中获取已完成的事件。 io_destroy ：销毁一个异步I/O上下文。 尽管 libaio 为异步 I/O 提供了基础支持，但它有一定的局限性，比如：它只适用于文件 I/O，并不适合用于网络 I/O。\n以下是一个简洁的 libaio 使用示例，演示了如何在 Linux 系统中以异步方式进行文件读取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;libaio.h\u0026gt; #include \u0026lt;sys/eventfd.h\u0026gt; #define FILE_PATH \u0026#34;example_file.txt\u0026#34; #define BUFFER_SIZE 1024 int main() { io_context_t ctx; struct iocb cb; struct iocb *cbs[1]; char buffer[BUFFER_SIZE]; int file_fd, efd, ret; struct io_event events[1]; uint64_t u; memset(\u0026amp;ctx, 0, sizeof(ctx)); io_setup(10, \u0026amp;ctx); file_fd = open(FILE_PATH, O_RDWR | O_CREAT, 0644); // 创建eventfd用于通知 efd = eventfd(0, 0); // 准备异步读请求 memset(\u0026amp;cb, 0, sizeof(struct iocb)); io_prep_pread(\u0026amp;cb, file_fd, buffer, BUFFER_SIZE, 0); // 设置eventfd作为完成事件的通知 cb.data = (void *)(uintptr_t)efd; cbs[0] = \u0026amp;cb; // 提交异步I/O请求 io_submit(ctx, 1, cbs) // 在这里，主线程可以执行其他业务逻辑 // ... read(efd, \u0026amp;u, sizeof(uint64_t)); // 在主线程中等待通知 io_getevents(ctx, 1, 1, events, NULL); // 读取异步I/O事件 // 处理完成的I/O事件 if(events[0].data == (void *)(uintptr_t)efd) { printf(\u0026#34;Read %zd bytes: %.*s\\n\u0026#34;, events[0].res, (int)events[0].res, buffer); } close(file_fd); io_destroy(ctx); close(efd); return 0; } io_uring：\nio_uring 是 Linux 内核 5.1 版本引入的全新异步 I/O 框架，io_uring 旨在提供一种高效、灵活且功能丰富的方式来执行异步 I/O 操作。与 libaio 相比，io_uring 提供了更低的系统调用开销，更简单的接口，以及更好的性能。\n如何工作：\nio_uring 的核心思想是通过两个队列来管理异步 I/O 请求。一个叫做提交队列（SQ），另一个叫完成队列（CQ）。\n1.提交请求：当你的程序想要执行一个 I/O 操作，比如读取网络数据，它会创建一个请求并把它放到提交队列（SQ）中。\n2.内核处理：Linux 内核会查看提交队列，取出请求并处理它们。你的程序不需要等待内核完成这个操作，它可以继续做其他事情。\n3.完成通知：一旦内核完成了一个请求，它会把结果放入完成队列（CQ）中。这样程序就知道该操作已经完成，可以继续处理结果了。\nio_uring 的优势：\n性能：它允许应用程序一次性地批量提交多个 I/O 请求，减少了系统调用的数量，所以 io_uring 能够提供比传统的异步 I/O 更好的性能。 减少等待：应用程序不需要每次提交一个请求就等待结果，它可以继续执行其他任务，同时内核在背后处理这些 I/O 请求。 功能丰富：io_uring 支持各种类型的 I/O 操作，包括但不限于文件读写、网络操作等。 易用性：io_uring 提供了一个更为简洁和一致的接口，相比于旧的异步 I/O 接口，它更易于使用和理解。 关于异步 IO 服务器模型的学习，大家只需要理解异步IO的工作方式，以及了解在 Linux 中可以通过 libaio 和 io_uring 技术可以构建异步 IO 服务器模型。如果想深入学习 io_uring 的底层原理，则可以去官网或者谷歌搜索相关资料去深入学习。\n这篇文章，大家可以去了解：\nhttps://cloud.tencent.com/developer/article/2187655\n关于具体的代码示例，则可以去了解 liburing 这个库的 example 代码示例：https://github.com/axboe/liburing\n服务器架构模式 在前面的介绍中，我们了解了常见的服务器模型，但是这些模型在应对高并发场景都会遇到一些挑战，特别是在处理大量并发连接和高效率 I/O 操作方面。尽管模型如多线程、线程池和 I/O 多路复用提供了并发处理的基础架构，但它们各自都有局限性，特别是在高并发和低延迟要求的场景中。\n这些挑战促使了对一种更高效、更可扩展的并发处理模式的需求— 这就是 Reactor 模式。Reactor 模式采用事件驱动的方法，结合同步 I/O 多路复用技术，如 select、poll 或 epoll，提供了一种不同于传统线程模型的并发处理机制。\n为什么需要 Reactor 模式？\n并发和 I/O 效率：传统的多线程和多进程模型在处理成千上万的并发连接时可能会遇到性能瓶颈。这些模型往往涉及重的上下文切换和资源分配，特别是在频繁的 I/O 操作下。\n简化事件处理：在 I/O 多路复用模型中，虽然可以高效地监控多个 I/O 流，但在事件分发和处理方面往往缺乏组织和结构。Reactor 模式提供了一种清晰的框架来处理多个并发 I/O 事件，简化了事件驱动程序的开发。\nReactor 模式详解 Reactor 是什么？\nReactor 模式可以理解为一种在网络编程中常用的设计模式，用于高效地处理多个并发 I/O 事件，如用户请求或网络通信。它的核心概念是使用一个中心化的处理器（称为 Reactor）来监控所有的 I/O 请求。当一个 I/O 事件发生时（例如，新的客户端连接或者数据到达），Reactor 会捕获这个事件，并将其分派给相应的处理程序进行处理。\n核心组件：\n1.Handles (句柄)：\n定义：句柄是对操作系统资源的引用，通常是文件描述符（file descriptor）。在网络编程中，这通常是指代网络套接字（sockets）。\n用途：它用于标识一个特定的网络连接或其他 I/O 资源，如打开的文件、管道等。\n示例：当一个客户端连接到服务器，服务器会为这个连接创建一个套接字，并为其分配一个文件描述符，这个文件描述符就是一个句柄。\n2.Synchronous Event Demultiplexer (事件多路分发器)：\n定义：事件多路分发器是负责等待多个句柄上事件发生的组件。它可以同时监控多个句柄，如网络套接字上的可读或可写事件。\n实现：在 Linux 中，这通常通过系统调用如 select, poll 或 epoll 实现。\n功能：当一个或多个句柄上发生事件时（例如，新的客户端连接、数据到达等），事件多路分发器通知 Reactor。\n3.Event Handler (事件处理器)：\n定义： 它是一个定义了处理不同类型事件所需接口或协议的抽象概念。通常包含一系列的方法或函数，用于处理各种事件，如读取数据（可读事件）、写入数据（可写事件）或处理错误（错误事件）。事件处理器定义了在发生特定事件时应当调用哪些方法，但不涉及这些方法的具体实现。\n例如： 一个事件处理器接口可能有一个 handle_read 方法用于处理可读事件，但它并不实现该方法。\n4.Concrete Event Handlers (具体事件处理器)：\n定义： 具体事件处理器实现了定义在事件处理器接口中的所有方法，提供了如何处理特定事件的具体逻辑。\n例如，一个具体事件处理器可能实现 handle_read 方法来从套接字中读取数据并处理这些数据。又或者实现 handle_accept 方法来处理客户端的连接请求。\n具体事件处理器是实际工作的组件，每个具体的事件处理器实例通常与应用程序中的一个特定资源（一个socket 文件描述符）关联。\n5.Initiation Dispatcher (初始化分发器)：\n定义：初始化分发器是 Reactor 模式的核心组件，负责管理事件循环、监听事件并将它们分发到相应的具体事件处理器。\n职责：它初始化事件多路分发器，注册事件处理器，并在事件发生时调用相应的具体事件处理器。\n事件循环：在整个应用程序的生命周期内，初始化分发器运行一个循环，等待和分发事件。\nselect 实现的 Reactor 网络服务器程序\n这里只是提供一个简单示例，但以上的5个组件都包含。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #define PORT 8080 #define BUFFER_SIZE 1024 #define MAX_CLIENTS 1024 handler_t handlers[MAX_CLIENTS]; int num_clients = 0; typedef struct handler_t { int handle; //句柄：在我们的上下文中就是套接字描述符。 void (*handle_func)(int handle, void *arg); //事件处理器 } handler_t; // 具体事件处理器 ： 处理客户端的连接请求 void acceptor_handler_func(int handle, void *arg) { struct sockaddr_in client_addr; socklen_t client_len = sizeof(client_addr); int client_fd = accept(handle, (struct sockaddr*)\u0026amp;client_addr, \u0026amp;client_len); if (client_fd \u0026lt; 0) { } printf(\u0026#34;Accepted connection from %s\\n\u0026#34;, inet_ntoa(client_addr.sin_addr)); // 将新客户端加入到 handlers 中 handlers[num_clients].handle = client_fd; handlers[num_clients].handle_func = client_handler_func; num_clients++; } // 具体事件处理器：处理客户端的数据处理请求 void client_handler_func(int handle, void *arg) { char buffer[BUFFER_SIZE]; int nbytes = recv(handle, buffer, sizeof(buffer), 0); if (nbytes \u0026lt;= 0) { close(handle); // 将handle从handlers数组中移除 for (int i = 0; i \u0026lt; num_clients; i++) { if (handlers[i].handle == handle) { handlers[i] = handlers[num_clients - 1]; num_clients--; break; } } } else { send(handle, buffer, nbytes, 0); } } void event_demultiplexer() { fd_set read_fds; int fd_max = 0; FD_ZERO(\u0026amp;read_fds); for (int i = 0; i \u0026lt; num_clients; i++) { FD_SET(handlers[i].handle, \u0026amp;read_fds); if (handlers[i].handle \u0026gt; fd_max) { fd_max = handlers[i].handle; } } // 等待 socket 上的可读事件 if (select(fd_max + 1, \u0026amp;read_fds, NULL, NULL, NULL) == -1) { perror(\u0026#34;select\u0026#34;); exit(1); } // 分发事件 for (int i = 0; i \u0026lt; num_clients; i++) { if (FD_ISSET(handlers[i].handle, \u0026amp;read_fds)) { handlers[i].handle_func(handlers[i].handle, NULL); } } } /* Initiation Dispatcher (初始化分发器) Initiation Dispatcher 是 Reactor 模式的核心，允许应用程序注册事件、注销事件。并且它负责启动事件循环，等待事件并分发事件。 */ void run_reactor(int listen_fd) { // 注册事件 handlers[num_clients].handle = listen_fd; handlers[num_clients].handle_func = acceptor_handler_func; num_clients++; // 启动事件循环 while (1) { event_demultiplexer(); } } int main() { int listen_fd; struct sockaddr_in server_addr; listen_fd = socket(AF_INET, SOCK_STREAM, 0) memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); server_addr.sin_addr.s_addr = INADDR_ANY; bind(listen_fd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr); listen(listen_fd, 10); run_reactor(listen_fd); close(listen_fd); return 0; } 基于 epoll 的高效性，我们一般会基于 epoll 去实现 reactor。具体实现可参考这篇文章：\nhttps://zhuanlan.zhihu.com/p/539556726\nReactor 事件处理流程\n下面通过时序图来图示上述代码的执行过程，方便大家理解：\nReactor 模式的优势和应用场景 Reactor 模式的主要优势包括：\n高效的资源利用：\n通过单线程或少量线程来管理多个并发连接，减少了线程上下文切换和资源消耗，提高了资源利用效率。 快速响应能力：\n非阻塞和事件驱动机制确保了快速响应外部事件，提高了程序的响应速度。 更好的可扩展性：\n能够处理成千上万的并发连接，而不会遇到传统多线程或多进程模型中线程资源限制的问题。 应用场景 这种模式特别适合于需要高并发处理的网络服务器，如 Web 服务器、数据库服务器等。\n结论：\nReactor 模式是现代高性能网络编程的基石之一。它通过事件驱动和非阻塞 I/O 机制有效地解决了传统并发模型在高并发环境下的限制，为构建可扩展的网络应用提供了强大的工具。\nProactor 模式详解 在前面的讲解中，我们探讨了 Reactor 模式。该模式主要依赖于同步 I/O，然而，随着并发需求的增加，尤其在高负载环境下，同步 I/O 的局限性逐渐凸显。\n应对这一挑战，异步编程模型的 Proactor 模式提供了一种全新的解决方案。它区别于 Reactor 的同步等待，转而采用完全异步的 I/O 操作。在这个模式下，应用程序无需在 I/O 完成前等待，而是在 I/O 完成后接收通知。Proactor 模式有效减少了等待时间，提高了对并发连接的处理效率，尤其适合于构建高性能、I/O 密集型的网络应用。这一模式不仅提升了性能，也代表了网络编程范式的一次重要转变，为开发高效和可扩展的网络服务提供了新思路。\nProactor 是什么？\nProactor 模式是一种高级的异步编程模型，用于处理 I/O 操作。与传统的同步 I/O 操作（如 Reactor 模式）不同，Proactor 模式允许应用程序在不阻塞主执行线程的情况下执行 I/O 操作。应用程序发起异步 I/O 请求后可以继续执行其他任务，而无需阻塞等待 I/O 操作的完成。当 I/O 操作实际完成时，操作系统会通知应用程序，并触发预定义的回调函数或事件处理程序来处理 I/O 操作的结果。\n核心组件\n异步操作对象： 该对象代表了单个的异步 I/O 操作，如异步读取或写入。它 们通常封装了操作的细节，如操作类型、目标资源(文件描述符)、缓冲区地址等。\n异步操作对象的定义\n1 2 3 4 5 6 7 8 9 10 11 12 enum { ADD_TYPE_ACCEPT, ADD_TYPE_READ, ADD_TYPE_WRITE }; struct io_data { int type; // ADD_TYPE_ACCEPT, ADD_TYPE_READ, ADD_TYPE_WRITE 等 int fd; size_t bytes_read; char buffer[BUFFER_SIZE]; }; Proactor 初始器（Proactor Initiator） ：\nProactor 初始器是负责启动和配置异步 I/O 操作流程的组件。它通常由用户空间的代码执行，负责准备和提交异步 I/O 请求到内核。\n在 io_uring 中，Proactor 初始器 对应的是用户空间代码，特别是负责初始化 io_uring 实例、以及提交异步 I/O 请求到内核的逻辑。\n来看下在 io_uring 中， Proactor Initiator 的代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 初始化 io_uring实例 int ret = io_uring_queue_init(256, \u0026amp;ring, 0); // 提交一个异步读取请求 static void submit_async_read(struct io_uring *ring, int fd) { struct io_data *data = malloc(sizeof(struct io_data)); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); data-\u0026gt;fd = fd; data-\u0026gt;type = ADD_TYPE_READ; io_uring_prep_read(sqe, fd, data-\u0026gt;buffer, BUFFER_SIZE, 0); // 准备读取请求 io_uring_sqe_set_data(sqe, data); // 设置用户数据 io_uring_submit(ring); // 提交请求 } 异步操作处理器（Asynchronous Operation Processor）：\n异步操作处理器是 Proactor 模式的核心，在内核中执行，负责启动异步 I/O 操作并在操作完成时通知用户空间的 Proactor 实例。\n在 io_uring 中，异步操作处理器 实际上是 io_uring 的内核组件。这包括提交队列（SQ）和完成队列（CQ），以及内核中负责处理这些队列的逻辑。\n完成处理器（Completion Handler）\n完成处理器是由应用程序定义的回调函数，它们在异步 I/O 操作完成时被调用以处理 I/O 操作的结果。\n在 io_uring 中，完成处理器 对应于那些被提交到 io_uring 并在 I/O 操作完成后执行的回调函数。这些回调函数处理 io_uring 从完成队列中获取的 CQEs(多个完成队列条目)。\n异步读取回调函数代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void handle_read(struct io_uring *ring, struct io_uring_cqe *cqe) { struct io_data *data = io_uring_cqe_get_data(cqe); if (!data) { return; // 数据为空则直接返回 } if (cqe-\u0026gt;res \u0026lt;= 0) { // 客户端断开连接或读取错误 close(data-\u0026gt;fd); } else { // 读取数据，准备回写(data-\u0026gt;buffer缓冲区已经有数据了) data-\u0026gt;bytes_read = cqe-\u0026gt;res; printf(\u0026#34;Received: %.*s\\n\u0026#34;, (int)data-\u0026gt;bytes_read, data-\u0026gt;buffer); // 可以在这里添加写回逻辑 } free(data); // 释放内存 } Proactor 实例：\nProactor 实例是负责管理整个异步 I/O 流程的组件，它管理着异步操作处理器和完成处理器，调度完成处理器，并处理所有的异步事件。\n在 io_uring 中，Proactor 实例 对应的是用户空间中维护 io_uring 接口和逻辑的部分，其实就是一个事件循环，它负责监控完成队列（CQ），确定哪些 I/O 操作已经完成，并触发相应的完成处理器。\nProactor 实例代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 运行事件循环以处理异步 I/O 操作 void run_io_uring_loop(struct io_uring *ring) { struct io_uring_cqe *cqe; unsigned head; while (1) { // 提交所有挂起的请求并等待至少一个请求完成 io_uring_submit_and_wait(ring, 1); // 处理所有已完成的事件 io_uring_for_each_cqe(ring, head, cqe) { if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;IO operation failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); } else { handle_read(ring, cqe); // 调用完成处理器 } // 标记该事件已处理 io_uring_cqe_seen(ring, cqe); } } } Proactor 事件处理流程\n启动异步操作（Proactor 初始器）：\n你的程序（通过 Proactor 初始器）准备一个异步 I/O 操作，比如说读取文件或接收网络数据。这个准备过程涉及指定要进行的操作类型（例如读取或写入）、哪个文件或网络连接，以及数据存放的位置。\n一旦准备好，这个异步操作被提交给操作系统。如果使用 io_uring，这意味着将操作请求放入 io_uring 的提交队列（SQ）。操作系统内核处理异步操作（由异步操作处理器执行）。\n一旦异步操作被提交，操作系统接管这个任务。在 io_uring 中，内核会处理这些 I/O 请求。与此同时，你的程序可以继续执行其他任务，不必等待 I/O 操作完成。\n通知 Proactor实例 ：\n当操作系统完成了一个异步 I/O 操作，它会将此操作的结果放入完成队列（CQ）。\n你的程序中的 Proactor 实例会定期检查这个完成队列，看看是否有任何操作已经完成。\n处理完成的操作（完成处理器）：\n对于每一个已经完成的操作，Proactor 实例会调用相应的完成处理器。完成处理器是你事先定义好的，专门用来处理异步操作完成后的数据的函数。比如说，如果操作对象是网络套接字，处理器可能会处理读取到的数据。\n清理和准备下一步操作：\n一旦完成处理器运行完毕，Proactor 实例会进行必要的清理工作，并准备接收和处理更多的完成事件。\n总结一下：Proactor 模式允许你的程序异步地执行 I/O 操作，同时继续进行其他任务。操作系统在后台处理这些 I/O 请求，当它们完成时，你的程序会得到通知，并调用相应的回调函数来处理结果。这个过程优化了资源的使用，提高了应用程序的响应性和效率。\nProactor 模式的优势 完全的异步处理：\nProactor 模式实现了真正的异步 I/O。在 Proactor 模式中，所有的 I/O 操作（包括读写）都是异步完成的。这意味着应用程序可以在 I/O 操作进行时继续执行其他任务，而无需等待 I/O 操作的完成。\n相比之下，Reactor 模式通常只能异步地处理 I/O 请求的准备阶段（例如等待数据到达或可发送状态），而实际的读写操作仍然是同步进行的。\n减少线程阻塞：\n在 Proactor 模式中，由于 I/O 操作完全异步，应用程序线程不会因等待 I/O 操作而阻塞，这对于保持高性能和响应性是非常重要的。\nReactor 模式虽然减少了直接的 I/O 等待（例如等待数据到达），但在处理数据时仍然可能出现阻塞（如：数据处理操作耗时较长）。\n简化编程模型：\nProactor 模式通过预定义的回调或事件处理器简化了异步 I/O 的编程模型，使得代码更加清晰和易于维护。\n在 Reactor 模式中，编程者需要显式处理 I/O 事件的分发和响应，可能导致更复杂的事件处理逻辑。\nProactor 模式的应用场景 高性能网络服务器：\n如 Web 服务器、数据库服务器等，特别是在需要处理大量并发网络请求的场景。\n文件 I/O 密集型应用：\n例如日志处理、大数据分析，以及任何需要频繁读写大型文件的应用。\n总结 在本系列文章中，我们深入探讨了Linux下的套接字编程，一个在网络通信中不可或缺的核心技术-套接字。套接字作为网络通信的基石，使得不同主机间的数据交换变得可能。\n套接字的本质\n我们首先解析了套接字的概念，它是支持TCP/IP网络通信的基础API，为应用层与网络层之间提供了一个抽象层。通过套接字，应用程序可以不用关心底层的网络细节，就能进行网络通信。\n套接字类型\n接着，我们探讨了套接字的三种基本类型：\n流式套接字（SOCK_STREAM）：提供序列化的、可靠的、双向的连接通信。 数据报套接字（SOCK_DGRAM）：提供非连接的、不可靠的通信。 原始套接字（SOCK_RAW）：允许直接访问底层协议，用于需要细粒度控制的场景。 关键API与结构\n我们详细介绍了套接字编程中的关键API，如 socket、bind、listen、accept、connect以及send和recv函数，以及套接字地址结构（如sockaddr）和地址转换API，这些是进行套接字编程的基础。\n数据处理\n字节序转换API的讨论，帮助我们处理跨平台的数据一致性问题。\nLinux的IO模型\n本系列文章还覆盖了Linux系统中的多种IO模型，包括阻塞IO、非阻塞IO、I/O多路复用、信号驱动IO和异步IO，它们各有优势，适用于不同的场景。\n网络I/O性能优化\n在网络I/O性能优化部分，我们讨论了硬件优化和软件优化策略，强调了应用程序设计的重要性和内核参数调整的作用。\n服务器模型\n最后，我们探讨了 Linux 环境下常见的服务器模型，包括单进程、多进程、多线程、线程池和I/O多路复用模型以及异步I/O服务器模型，每种模型都有其应用场景和优缺点。\n架构模式\n服务器架构模式，如 Reactor 和 Proactor，提供了高效处理并发网络事件的方法，是构建高性能网络应用的关键。\n总结：\n水平触发：更易于使用和理解，但可能会导致更多的 epoll_wait 调用，尤其是在高负载下。\n边缘触发：更高的性能潜力，减少了 epoll_wait 调用的次数，但需要更谨慎的缓冲区管理和错误处理。\n","date":"2025-04-23T00:00:00Z","image":"https://serennan.github.io/post/linux-network/cover.png","permalink":"https://serennan.github.io/post/linux-network/","title":"【Linux】网络编程入门"},{"content":"1. move 在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。从实现上讲，std::move基本等同于一个类型转换：static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(lvalue);，函数原型如下:\n1 2 3 4 5 template\u0026lt;class _Ty\u0026gt; _NODISCARD constexpr remove_reference_t\u0026lt;_Ty\u0026gt;\u0026amp;\u0026amp; move(_Ty\u0026amp;\u0026amp; _Arg) _NOEXCEPT { return (static_cast\u0026lt;remove_reference_t\u0026lt;_Ty\u0026gt;\u0026amp;\u0026amp;\u0026gt;(_Arg)); } 使用方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Test { public： Test(){} // 其他成员 }; int main() { Test t; Test \u0026amp;\u0026amp; v1 = t; // 错误：使用左值初始化右值引用 Test \u0026amp;\u0026amp; v2 = move(t); // 正确：使用move将左值转换为右值 return 0; } 假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：\n1 2 3 4 5 6 list\u0026lt;string\u0026gt; ls; ls.push_back(\u0026#34;hello\u0026#34;); ls.push_back(\u0026#34;world\u0026#34;); // 其他操作 list\u0026lt;string\u0026gt; ls1 = ls; // 拷贝构造 list\u0026lt;string\u0026gt; ls2 = move(ls); // 移动构造 如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数（T::T(T\u0026amp;\u0026amp; another)）和具有移动语义的赋值函数（T\u0026amp;\u0026amp; T::operator=(T\u0026amp;\u0026amp; rhs)），在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。\n2. forward 右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用C++11提供的std::forward()函数，该函数实现的功能称之为完美转发。\n1 2 3 4 template \u0026lt;class T\u0026gt; T\u0026amp;\u0026amp; forward (typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp; t) noexcept; template \u0026lt;class T\u0026gt; T\u0026amp;\u0026amp; forward (typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; t) noexcept; std::forward\u0026lt;T\u0026gt;(t); 当T为左值引用类型时，t将被转换为T类型的左值 当T不是左值引用类型时，t将被转换为T类型的右值 下面通过一个例子演示一下关于forward的使用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; void printValue(T\u0026amp; t) { cout \u0026lt;\u0026lt; \u0026#34;l-value: \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void printValue(T\u0026amp;\u0026amp; t) { cout \u0026lt;\u0026lt; \u0026#34;r-value: \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } template\u0026lt;typename T\u0026gt; void testForward(T \u0026amp;\u0026amp; v) { printValue(v); printValue(move(v)); printValue(forward\u0026lt;T\u0026gt;(v)); cout \u0026lt;\u0026lt; endl; } int main() { testForward(520); int num = 1314; testForward(num); testForward(forward\u0026lt;int\u0026gt;(num)); testForward(forward\u0026lt;int\u0026amp;\u0026gt;(num)); testForward(forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(num)); return 0; } 测试代码打印的结果如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 l-value: 520 r-value: 520 r-value: 520 l-value: 1314 r-value: 1314 l-value: 1314 l-value: 1314 r-value: 1314 r-value: 1314 l-value: 1314 r-value: 1314 l-value: 1314 l-value: 1314 r-value: 1314 r-value: 1314 testForward(520);函数的形参为未定引用类型T\u0026amp;\u0026amp;，实参为右值，初始化后被推导为一个右值引用 printValue(v);已命名的右值v，编译器会视为左值处理，实参为左值 printValue(move(v));已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值 printValue(forward\u0026lt;T\u0026gt;(v));forward的模板参数为右值引用，最终得到一个右值，实参为右值 testForward(num);函数的形参为未定引用类型T\u0026amp;\u0026amp;，实参为左值，初始化后被推导为一个左值引用 printValue(v);实参为左值 printValue(move(v));通过move将左值转换为右值，实参为右值 printValue(forward\u0026lt;T\u0026gt;(v));forward的模板参数为左值引用，最终得到一个左值引用，实参为左值 testForward(forward\u0026lt;int\u0026gt;(num));forward的模板类型为int，最终会得到一个右值，函数的形参为未定引用类型T\u0026amp;\u0026amp;被右值初始化后得到一个右值引用类型 printValue(v);已命名的右值v，编译器会视为左值处理，实参为左值 printValue(move(v));已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值 printValue(forward\u0026lt;T\u0026gt;(v));forward的模板参数为右值引用，最终得到一个右值，实参为右值 testForward(forward\u0026lt;int\u0026amp;\u0026gt;(num));forward的模板类型为int\u0026amp;，最终会得到一个左值，函数的形参为未定引用类型T\u0026amp;\u0026amp;被左值初始化后得到一个左值引用类型 printValue(v);实参为左值 printValue(move(v));通过move将左值转换为右值，实参为右值 printValue(forward\u0026lt;T\u0026gt;(v));forward的模板参数为左值引用，最终得到一个左值，实参为左值 testForward(forward\u0026lt;int\u0026amp;\u0026amp;\u0026gt;(num));forward的模板类型为int\u0026amp;\u0026amp;，最终会得到一个右值，函数的形参为未定引用类型T\u0026amp;\u0026amp;被右值初始化后得到一个右值引用类型 printValue(v);已命名的右值v，编译器会视为左值处理，实参为左值 printValue(move(v));已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值 printValue(forward\u0026lt;T\u0026gt;(v));forward的模板参数为右值引用，最终得到一个右值，实参为右值 ","date":"2025-04-22T00:00:00Z","image":"https://serennan.github.io/post/cpp-move-forward/cover.png","permalink":"https://serennan.github.io/post/cpp-move-forward/","title":"【C++11】移动语义和完美转发"},{"content":"线程池 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n线程池是一种用于管理和重用线程的技术，广泛用于需要大量短生命周期线程的应用场景，如并发任务处理、网络服务和高性能计算等。使用线程池可以有效减少线程创建和销毁的开销，提升系统性能。\n1. 线程池的设计 线程池的基本思想是预先创建一定数量的线程，并将它们放入一个池中。线程池负责管理线程的生命周期，并将任务分配给空闲线程执行。这样可以避免每次任务执行时都创建和销毁线程的开销。\n如果要编写一个线程池，它的组成如下:\n线程池管理器：负责创建、销毁线程，维护线程池状态（如空闲线程、忙碌线程）。 任务队列：用于存储待执行的任务。任务通常以函数对象（如 std::function）的形式存储。 工作线程：线程池中的实际线程，它们从任务队列中取出任务并执行。 同步机制：用于保护任务队列和线程池状态的线程安全操作，通常使用互斥锁和条件变量。 在设计线程池时，我们需要考虑以下几个重要原则：\n线程池大小管理： 固定大小：线程池中的线程数量固定不变。适用于负载比较稳定的场景。 动态调整：根据任务负载动态调整线程池大小。适用于负载变化较大的场景。 任务队列管理： FIFO 队列：最常用的任务队列实现方式，按照任务提交的顺序执行任务。 优先级队列：根据任务的优先级执行任务，适用于需要按优先级处理任务的场景。 线程安全： 互斥锁：用于保护共享资源（如任务队列）的访问。 条件变量：用于线程之间的通信，如通知空闲线程有新的任务到来。 原子变量：对原子变量的操作都是原子操作，它是线程安全的。 任务执行与错误处理： 任务执行过程中的异常需要适当处理，以避免线程池中的线程因未捕获异常而终止。 2. 使用C++11实现线程池 2.1 头文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #pragma once #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; class ThreadPool { public: ThreadPool(int min = 4, int max = thread::hardware_concurrency()); ~ThreadPool(); void addTask(function\u0026lt;void()\u0026gt; f); private: void manager(); void worker(); private: thread* m_manager; map\u0026lt;thread::id, thread\u0026gt; m_workers; vector\u0026lt;thread::id\u0026gt; m_ids; int m_minThreads; int m_maxThreads; atomic\u0026lt;bool\u0026gt; m_stop; atomic\u0026lt;int\u0026gt; m_curThreads; atomic\u0026lt;int\u0026gt; m_idleThreads; atomic\u0026lt;int\u0026gt; m_exitNumber; queue\u0026lt;function\u0026lt;void()\u0026gt;\u0026gt; m_tasks; mutex m_idsMutex; mutex m_queueMutex; condition_variable m_condition; }; 相关函数介绍:\n构造函数：初始化线程池，并创建指定数量的工作线程和管理者线程。 析构函数：设置 m_stop 标志为 true，通知所有线程退出，然后等待所有线程退出任务函数并释放线程资源。 std::thread::hardware_concurrency() 是 C++ 标准库中 std::thread 类的一个静态成员函数。 用于查询计算机的硬件线程并发能力，即计算机上可以并发执行的线程数。 通常，这个值等于 CPU 核心数或者 CPU 核心数乘以超线程（Hyper-Threading）技术带来的线程数。 manager()：管理者线程的任务函数 worker()：工作的线程的任务函数 addTask(function\u0026lt;void()\u0026gt; f)：将任务添加到任务队列，并通知一个线程有新任务到来。 线程的任务函数是一个可调用对象，类型为 function\u0026lt;void()\u0026gt;，返回值类型为void，无参数 对应的任务队列为queue\u0026lt;function\u0026lt;void()\u0026gt;\u0026gt; m_tasks 2.2 源文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #include \u0026#34;threadpool.h\u0026#34; #include \u0026lt;iostream\u0026gt; ThreadPool::ThreadPool(int min, int max) : m_maxThreads(max), m_minThreads(min), m_stop(false), m_exitNumber(0) { m_idleThreads = m_curThreads = min; cout \u0026lt;\u0026lt; \u0026#34;线程数量: \u0026#34; \u0026lt;\u0026lt; m_curThreads \u0026lt;\u0026lt; endl; m_manager = new thread(\u0026amp;ThreadPool::manager, this); for (int i = 0; i \u0026lt; m_curThreads; ++i) { thread t(\u0026amp;ThreadPool::worker, this); m_workers.insert(make_pair(t.get_id(), move(t))); } } ThreadPool::~ThreadPool() { m_stop = true; m_condition.notify_all(); for (auto\u0026amp; it : m_workers) { thread\u0026amp; t = it.second; if (t.joinable()) { cout \u0026lt;\u0026lt; \u0026#34;******** 线程 \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; \u0026#34; 将要退出了...\u0026#34; \u0026lt;\u0026lt; endl; t.join(); } } if (m_manager-\u0026gt;joinable()) { m_manager-\u0026gt;join(); } delete m_manager; } void ThreadPool::addTask(function\u0026lt;void()\u0026gt; f) { { lock_guard\u0026lt;mutex\u0026gt; locker(m_queueMutex); m_tasks.emplace(f); } m_condition.notify_one(); } void ThreadPool::manager() { while (!m_stop.load()) { this_thread::sleep_for(chrono::seconds(2)); int idle = m_idleThreads.load(); int current = m_curThreads.load(); if (idle \u0026gt; current / 2 \u0026amp;\u0026amp; current \u0026gt; m_minThreads) { m_exitNumber.store(2); m_condition.notify_all(); unique_lock\u0026lt;mutex\u0026gt; lck(m_idsMutex); for (const auto\u0026amp; id : m_ids) { auto it = m_workers.find(id); if (it != m_workers.end()) { cout \u0026lt;\u0026lt; \u0026#34;############## 线程 \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;被销毁了....\u0026#34; \u0026lt;\u0026lt; endl; (*it).second.join(); m_workers.erase(it); } } m_ids.clear(); } else if (idle == 0 \u0026amp;\u0026amp; current \u0026lt; m_maxThreads) { thread t(\u0026amp;ThreadPool::worker, this); cout \u0026lt;\u0026lt; \u0026#34;+++++++++++++++ 添加了一个线程, id: \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; endl; m_workers.insert(make_pair(t.get_id(), move(t))); m_curThreads++; m_idleThreads++; } } } void ThreadPool::worker() { while (!m_stop.load()) { function\u0026lt;void()\u0026gt; task = nullptr; { unique_lock\u0026lt;mutex\u0026gt; locker(m_queueMutex); while (!m_stop \u0026amp;\u0026amp; m_tasks.empty()) { m_condition.wait(locker); if (m_exitNumber.load() \u0026gt; 0) { cout \u0026lt;\u0026lt; \u0026#34;----------------- 线程任务结束, ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; m_exitNumber--; m_curThreads--; unique_lock\u0026lt;mutex\u0026gt; lck(m_idsMutex); m_ids.emplace_back(this_thread::get_id()); return; } } if (!m_tasks.empty()) { cout \u0026lt;\u0026lt; \u0026#34;取出一个任务...\u0026#34; \u0026lt;\u0026lt; endl; task = move(m_tasks.front()); m_tasks.pop(); } } if (task) { m_idleThreads--; task(); m_idleThreads++; } } } void calc(int x, int y) { int res = x + y; cout \u0026lt;\u0026lt; \u0026#34;res = \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(2)); } int main() { ThreadPool pool(4); for (int i = 0; i \u0026lt; 10; ++i) { auto func = bind(calc, i, i * 2); pool.addTask(func); } getchar(); return 0; } void worker(): 工作的线程的任务函数 工作的线程在该函数内部通过while (!m_stop.load())循环重复的进行从任务队列取数据 -\u0026gt; 处理数据的动作 如果线程池没关闭并且任务队列为空，工作的线程被条件变量阻塞 通过addTask往任务队列中添加了新任务之后，可以唤醒被条件变量阻塞的线程 void manager()：管理者线程的任务函数 通过睡眠的方式每隔一段时间对线程池中的工作进行进行一次检测 如果空闲线程数量 \u0026gt; 总线程数量的一半并且线程总数量大于最小线程数量，销毁两个工作的线程 空闲线程为0并且线程总数量小于最大线程数，添加一个工作线程 void addTask(function\u0026lt;void()\u0026gt; f)： 添加新的任务到任务队列 通过notify_one()唤醒一个被阻塞的工作线程 关于 main() 函数中的测试代码 通过添加任务的函数addTask可以得知任务函数返回值类型是void并且无参，但是测试程序中添加的任务函数是void calc(int x, int y)携带了两个参数，很显然和任务函数的参数是类型是不匹配的，程序中的解决方案是对函数和参数进行绑定： 1 auto func = bind(calc, i, i * 2); 这样得到的可调用对象就是无参的。通过这种方式表面看起来只能存储无参函数的任务队列就可以存储带任意参数的有参函数了。 getchar();通过该函数阻塞主线程，程序运行完毕之后，按任意键解除阻塞，主线程执行完毕，程序（进程）也就退出了。 3. 线程异步 线程异步（Asynchronous Threading）是一种编程范式，用于执行任务或操作而不阻塞主线程或其他线程的执行。这种方法特别适用于需要同时处理多个操作或在后台执行长时间运行的任务的场景。线程异步的核心思想是将耗时的操作与主执行流程分离，使得系统能够继续处理其他任务，而无需等待耗时操作完成。\n异步执行：与同步操作不同，异步操作不要求调用者在任务完成之前等待结果。异步操作通常会在后台线程中执行，主线程或其他线程可以继续执行其他任务。 线程：在多线程编程中，异步操作通常通过创建新的线程来实现。新线程会执行异步任务，而主线程则继续进行其他操作。 在上面的线程池代码中，如果任务函数有返回值，我们就可以通过线程异步的方式，将子线程也就是工作的线程的返回值传递给主线程，核心操作就是修改添加任务的函数addTask。\n为了让线程池添加任务的函数更加灵活和通过以及实现线程异步，我们需要将其修改成一个模板函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #pragma once #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; class ThreadPool { public: ThreadPool(int min, int max = thread::hardware_concurrency()); ~ThreadPool(); template\u0026lt;typename F, typename... Args\u0026gt; auto addTask(F\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args) -\u0026gt; future\u0026lt;typename result_of\u0026lt;F(Args...)\u0026gt;::type\u0026gt; { using returnType = typename result_of\u0026lt;F(Args...)\u0026gt;::type; auto task = make_shared\u0026lt;packaged_task\u0026lt;returnType()\u0026gt;\u0026gt;(bind(forward\u0026lt;F\u0026gt;(f), forward\u0026lt;Args\u0026gt;(args)...)); future\u0026lt;returnType\u0026gt; res = task-\u0026gt;get_future(); { unique_lock\u0026lt;mutex\u0026gt; lock(m_queueMutex); m_tasks.emplace([task]() { (*task)(); }); } m_condition.notify_one(); return res; } private: void manager(); void worker(); private: thread* m_manager; map\u0026lt;thread::id, thread\u0026gt; m_workers; vector\u0026lt;thread::id\u0026gt; m_ids; int m_minThreads; int m_maxThreads; atomic\u0026lt;bool\u0026gt; m_stop; atomic\u0026lt;int\u0026gt; m_curThreads; atomic\u0026lt;int\u0026gt; m_idleThreads; atomic\u0026lt;int\u0026gt; m_exitNumber; queue\u0026lt;function\u0026lt;void()\u0026gt;\u0026gt; m_tasks; mutex m_idsMutex; mutex m_queueMutex; condition_variable m_condition; }; 关于模板函数addTask的相关细节解释如下:\n模板参数 F 和 Args...： F 是一个类型参数，代表任务函数的类型或函数对象的类型。这个函数或函数对象将被传递给 addTask 函数来执行。 Args... 是可变参数模板，表示传递给 F 的参数类型。Args 可以是任何数量的参数类型。 auto 返回类型： 返回类型是 future\u0026lt;typename result_of\u0026lt;F(Args...)\u0026gt;::type\u0026gt;，表示 addTask 函数会返回一个 future 对象，用于异步获取任务的结果。result_of\u0026lt;F(Args...)\u0026gt;::type 用于推导 F 运行后的返回类型。 通过使用 typename，我们明确告诉编译std::result_of\u0026lt;F(Args...)\u0026gt;::type 是一个类型，而不是其他实体（例如静态成员）。 using returnType： 使用 result_of\u0026lt;F(Args...)\u0026gt;::type 来获取任务函数 F 执行后的返回类型，并将其命名为 returnType。 make_shared\u0026lt;packaged_task\u0026lt;returnType()\u0026gt;\u0026gt;： std::make_shared 是一个模板函数，用于创建并返回一个 std::shared_ptr，它以一种异常安全的方式分配和构造对象。这里，std::make_shared 用于创建一个指向 std::packaged_task 的共享指针。 std::packaged_task 是一个模板类，用于包装一个可调用对象（如函数、lambda 表达式、函数对象等），使其可以异步执行，并允许获取其执行结果。std::packaged_task 提供了一个 std::future 对象，通过该对象可以在任务完成后获取其结果。 returnType() 表示 packaged_task 将封装一个返回类型为 returnType 的任务。 bind(forward\u0026lt;F\u0026gt;(f), forward\u0026lt;Args\u0026gt;(args)...) : std::bind 是一个标准库函数模板，用于绑定参数到可调用对象上，返回一个新的可调用对象。这里，std::bind 绑定了传入的函数 f 和参数 args...，生成一个不接受参数的新函数对象。 std::forward 是一个模板函数，用于完美转发参数。addTask函数的参数(F\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args)为未定引用类型，std::forward保留了参数的值类别（左值或右值），以确保参数在转发过程中不会被不必要地拷贝或移动。 task-\u0026gt;get_future()： get_future 返回一个 future 对象，这个对象用于获取异步任务的结果。 任务队列： unique_lock\u0026lt;mutex\u0026gt; lock(m_queueMutex) 用于加锁，确保线程安全地将任务加入任务队列。 m_tasks.emplace([task]() { (*task)(); }); 将任务添加到任务队列中。这里使用了一个 lambda 函数来调用 (*task)()，即执行封装的任务。 通知条件变量： m_condition.notify_one() 用于通知等待的线程（如果有的话）任务队列中有新的任务可用。 然后再来看一下测试代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int calc(int x, int y) { int res = x + y; this_thread::sleep_for(chrono::seconds(2)); return res; } int main() { ThreadPool pool(4); vector\u0026lt;future\u0026lt;int\u0026gt;\u0026gt; results; for (int i = 0; i \u0026lt; 10; ++i) { results.emplace_back(pool.addTask(calc, i, i * 2)); } for (auto\u0026amp;\u0026amp; res : results) { cout \u0026lt;\u0026lt; \u0026#34;线程函数返回值: \u0026#34; \u0026lt;\u0026lt; res.get() \u0026lt;\u0026lt; endl; } return 0; } 关于std::future 类的 get() 方法再来给大家详细说明一下:\n阻塞行为： 当调用 get() 方法时，如果异步操作还没有完成，调用线程会被阻塞，直到异步操作完成并且结果准备好为止。这意味着调用 get() 会暂停线程的执行，直到可以安全地获取到结果。 返回值： 一旦异步操作完成，get() 方法会返回存储在 std::future 中的结果。如果异步操作抛出了异常，get() 方法会重新抛出那个异常，所以你需要准备好处理可能的异常。 一次性调用： get() 方法只能调用一次。调用一次后，future 对象会变得无效，如果你尝试再次调用 get()，程序会抛出 std::future_error 异常。 因此，在测试程序中我们通过vector\u0026lt;future\u0026lt;int\u0026gt;\u0026gt; results;容器存储了各个工作的线程返回的future对象\n","date":"2025-04-16T00:00:00Z","image":"https://serennan.github.io/post/cpp-threapool/cover.png","permalink":"https://serennan.github.io/post/cpp-threapool/","title":"【C++11】线程池"},{"content":"IO多路复用 epoll 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n1. 概述 epoll 全称 eventpoll，是 linux 内核实现IO多路转接/复用（IO multiplexing）的一个实现。IO多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll是select和poll的升级版，相较于这两个前辈，epoll改进了工作方式，因此它更加高效。\n对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的 select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降 select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。 程序员需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测 使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制 当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，推荐使用epoll() 2. 操作函数 在epoll中一共提供是三个API函数，分别处理不同的操作，函数原型如下：\n1 2 3 4 5 6 7 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event _event); int epoll_wait(int epfd, struct epoll_event_ events, int maxevents, int timeout); select/poll低效的原因之一是将“添加/维护待检测任务”和“阻塞进程/线程”两个步骤合二为一。每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket个数相对固定，并不需要每次都修改。epoll将这两个操作分开，先用 epoll_ctl()维护等待队列，再调用 epoll_wait()阻塞进程（解耦）。\n2.1 epoll_create()函数 epoll_create()函数的作用是创建一个红黑树模型的实例，用于管理待检测的文件描述符的集合。\n1 int epoll_create(int size); 函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。 函数返回值： 失败：返回-1 成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的epoll实例了 2.2 epoll_ctl()函数 epoll_ctl()函数的作用是管理红黑树实例上的节点，可以进行添加、删除、修改操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef union epoll_data { void _ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; epoll_data_t data; }; int epoll_ctl(int epfd, int op, int fd, struct epoll_event_ event); 函数参数： epfd：epoll_create() 函数的返回值，通过这个参数找到epoll实例 op：这是一个枚举值，控制通过该函数执行什么操作 EPOLL_CTL_ADD：往epoll模型中添加新的节点 EPOLL_CTL_MOD：修改epoll模型中已经存在的节点 EPOLL_CTL_DEL：删除epoll模型中的指定的节点 fd：文件描述符，即要添加/修改/删除的文件描述符 event：epoll事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件 events：委托epoll检测的事件 EPOLLIN：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪 EPOLLOUT：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪 EPOLLERR：异常事件 data：用户数据变量，这是一个联合体类型，通常情况下使用里边的 fd成员，用于存储待检测的文件描述符的值，在调用 epoll_wait()函数的时候这个值会被传出。 函数返回值： 失败：返回-1 成功：返回0 2.3 epoll_wait()函数 epoll_wait()函数的作用是检测创建的epoll实例中有没有就绪的文件描述符。\n1 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 函数参数： epfd：epoll_create() 函数的返回值, 通过这个参数找到epoll实例 events：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息 maxevents：修饰第二个参数, 结构体数组的容量（元素个数） timeout：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒 0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回 大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回 -1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞 函数返回值： 成功： 等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符 大于0：检测到的已就绪的文件描述符的总个数 失败：返回-1 3. epoll的使用 3.1 操作步骤 在服务器端使用epoll进行IO多路转接的操作步骤如下：\n创建监听的套接字 1 int lfd = socket(AF_INET, SOCK_STREAM, 0); 设置端口复用（可选） 1 2 int opt = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)); 使用本地的IP与端口和监听的套接字进行绑定 1 int ret = bind(lfd, (struct sockaddr*)\u0026amp;serv_addr, sizeof(serv_addr)); 给监听的套接字设置监听 1 listen(lfd, 128); 创建epoll实例对象 1 int epfd = epoll_create(100); 将用于监听的套接字添加到epoll实例中 1 2 3 4 struct epoll_event ev; ev.events = EPOLLIN; ev.data.fd = lfd; int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, \u0026amp;ev); 检测添加到epoll实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理 1 int num = epoll_wait(epfd, evs, size, -1); 如果是监听的文件描述符，和新客户端建立连接，将得到的文件描述符添加到epoll实例中 1 2 3 4 int cfd = accept(curfd, NULL, NULL); ev.events = EPOLLIN; ev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, \u0026amp;ev); 如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从epoll实例中删除 1 2 3 4 5 6 7 8 9 10 int len = recv(curfd, buf, sizeof(buf), 0); if(len == 0) { epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); } else if(len \u0026gt; 0) { send(curfd, buf, len, 0); } 重复第7步的操作 3.2 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; int main(int argc, const char* argv[]) { int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } struct sockaddr_in serv_addr; memset(\u0026amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(9999); serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); int opt = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)); int ret = bind(lfd, (struct sockaddr*)\u0026amp;serv_addr, sizeof(serv_addr)); if(ret == -1) { perror(\u0026#34;bind error\u0026#34;); exit(1); } ret = listen(lfd, 64); if(ret == -1) { perror(\u0026#34;listen error\u0026#34;); exit(1); } int epfd = epoll_create(100); if(epfd == -1) { perror(\u0026#34;epoll_create\u0026#34;); exit(0); } struct epoll_event ev; ev.events = EPOLLIN; ev.data.fd = lfd; ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, \u0026amp;ev); if(ret == -1) { perror(\u0026#34;epoll_ctl\u0026#34;); exit(0); } struct epoll_event evs[1024]; int size = sizeof(evs) / sizeof(struct epoll_event); while(1) { int num = epoll_wait(epfd, evs, size, -1); printf(\u0026#34;==== num: %d\\n\u0026#34;, num); for(int i=0; i\u0026lt;num; ++i) { int curfd = evs[i].data.fd; if(curfd == lfd) { int cfd = accept(curfd, NULL, NULL); int flag = fcntl(cfd, F_GETFL); flag |= O_NONBLOCK; fcntl(cfd, F_SETFL, flag); ev.events = EPOLLIN | EPOLLET; ev.data.fd = cfd; ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, \u0026amp;ev); if(ret == -1) { perror(\u0026#34;epoll_ctl-accept\u0026#34;); exit(0); } } else { char buf[5]; memset(buf, 0, sizeof(buf)); while(1) { int len = recv(curfd, buf, sizeof(buf), 0); if(len == 0) { printf(\u0026#34;客户端断开了连接...\\n\u0026#34;); epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); break; } else if(len \u0026gt; 0) { write(STDOUT_FILENO, buf, len); send(curfd, buf, len, 0); } else { if(errno == EAGAIN) { printf(\u0026#34;数据读完了...\\n\u0026#34;); break; } else { perror(\u0026#34;recv\u0026#34;); exit(0); } } } } } } return 0; } 4. epoll的工作模式 4.1 水平模式 水平模式可以简称为LT模式，LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行IO操作了。如果我们不作任何操作，内核还是会继续通知使用者。\n水平模式的特点：\n读事件：如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，epoll_wait()解除阻塞 当读事件被触发，epoll_wait()解除阻塞，之后就可以接收数据了 如果接收数据的buf很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数） 因为读数据是被动的，必须要通过读事件才能知道有数据到达了，因此对于读事件的检测是必须的 写事件：如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait()解除阻塞 当写事件被触发，epoll_wait()解除阻塞，之后就可以将数据写入到写缓冲区了 写事件的触发发生在写数据之前而不是之后，被写入到写缓冲区中的数据是由内核自动发送出去的 如果写缓冲区没有被写满，写事件会一直被触发 因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的 epoll水平模式示例代码 4.2 边沿模式 边沿模式可以简称为ET模式，ET（edge-triggered）是高速工作方式，只支持no-block socket。在这种模式下，当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）。如果我们对这个文件描述符做IO操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。\n边沿模式的特点:\n读事件：当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件 如果有新数据进入到读缓冲区，读事件被触发，epoll_wait()解除阻塞 读事件被触发，可以通过调用read()/recv()函数将缓冲区数据读出 如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次 如果数据被全部读走或者只读走一部分，此时有新数据进入，读事件被触发，并且只通知一次 写事件：当写缓冲区状态可写，写事件只会触发一次 如果写缓冲区被检测到可写，写事件被触发，epoll_wait()解除阻塞 写事件被触发，就可以通过调用write()/send()函数，将数据写入到写缓冲区中 写缓冲区从不满到被写满，期间写事件只会被触发一次 写缓冲区从满到不满，状态变为可写，写事件只会被触发一次 综上所述：epoll的边沿模式下 epoll_wait()检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。 4.2.1 ET模式的设置 边沿模式不是默认的epoll模式，需要额外进行设置。epoll设置边沿模式是非常简单的，epoll管理的红黑树示例中每个节点都是 struct epoll_event类型，只需要将 EPOLLET添加到结构体的 events成员中即可：\n1 2 struct epoll_event ev; ev.events = EPOLLIN | EPOLLET; 示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int num = epoll_wait(epfd, evs, size, -1); for(int i=0; i\u0026lt;num; ++i) { int curfd = evs[i].data.fd; if(curfd == lfd) { int cfd = accept(curfd, NULL, NULL); struct epoll_event ev; ev.events = EPOLLIN | EPOLLET; ev.data.fd = cfd; ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, \u0026amp;ev); if(ret == -1) { perror(\u0026#34;epoll_ctl-accept\u0026#34;); exit(0); } } } 4.2.2 设置非阻塞 对于写事件的触发一般情况下是不需要进行检测的，因为写缓冲区大部分情况下都是有足够的空间可以进行数据的写入。对于读事件的触发就必须要检测了，因为服务器也不知道客户端什么时候发送数据，如果使用epoll的边沿模式进行读事件的检测，有新数据达到只会通知一次，那么必须要保证得到通知后将数据全部从读缓冲区中读出。那么，应该如何读这些数据呢？\n方式1：准备一块特别大的内存，用于存储从读缓冲区中读出的数据，但是这种方式有很大的弊端： 内存的大小没有办法界定，太大浪费内存，太小又不够用 系统能够分配的最大堆内存也是有上限的，栈内存就更不必多言了 方式2：循环接收数据 1 2 3 4 int len = 0; while((len = recv(curfd, buf, sizeof(buf), 0)) \u0026gt; 0) { } 这样做也是有弊端的，因为套接字操作默认是阻塞的，当读缓冲区数据被读完之后，读操作就阻塞了也就是调用的 read()/recv()函数被阻塞了，当前进程/线程被阻塞之后就无法处理其他操作了。 要解决阻塞问题，就需要将套接字默认的阻塞行为修改为非阻塞，需要使用 fcntl()函数进行处理：\n1 2 3 int flag = fcntl(cfd, F_GETFL); flag |= O_NONBLOCK; fcntl(cfd, F_SETFL, flag); fcntl函数的使用详解 通过上述分析就可以得出一个结论：epoll在边沿模式下，必须要将套接字设置为非阻塞模式，但是，这样就会引发另外的一个bug，在非阻塞模式下，循环地将读缓冲区数据读到本地内存中，当缓冲区数据被读完了，调用的 read()/recv()函数还会继续从缓冲区中读数据，此时函数调用就失败了，返回-1，对应的全局变量 errno 值为 EAGAIN 或者 EWOULDBLOCK如果打印错误信息会得到如下的信息：Resource temporarily unavailable\n1 2 3 4 5 6 7 8 9 10 11 12 13 int len = recv(curfd, buf, sizeof(buf), 0); if(len == -1) { if(errno == EAGAIN) { printf(\u0026#34;数据读完了...\\n\u0026#34;); } else { perror(\u0026#34;recv\u0026#34;); exit(0); } } 4.2.3 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/epoll.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;errno.h\u0026gt; int main(int argc, const char* argv[]) { int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } struct sockaddr_in serv_addr; memset(\u0026amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(9999); serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); int opt = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, \u0026amp;opt, sizeof(opt)); int ret = bind(lfd, (struct sockaddr*)\u0026amp;serv_addr, sizeof(serv_addr)); if(ret == -1) { perror(\u0026#34;bind error\u0026#34;); exit(1); } ret = listen(lfd, 64); if(ret == -1) { perror(\u0026#34;listen error\u0026#34;); exit(1); } int epfd = epoll_create(100); if(epfd == -1) { perror(\u0026#34;epoll_create\u0026#34;); exit(0); } struct epoll_event ev; ev.events = EPOLLIN; ev.data.fd = lfd; ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, \u0026amp;ev); if(ret == -1) { perror(\u0026#34;epoll_ctl\u0026#34;); exit(0); } struct epoll_event evs[1024]; int size = sizeof(evs) / sizeof(struct epoll_event); while(1) { int num = epoll_wait(epfd, evs, size, -1); printf(\u0026#34;==== num: %d\\n\u0026#34;, num); for(int i=0; i\u0026lt;num; ++i) { int curfd = evs[i].data.fd; if(curfd == lfd) { int cfd = accept(curfd, NULL, NULL); int flag = fcntl(cfd, F_GETFL); flag |= O_NONBLOCK; fcntl(cfd, F_SETFL, flag); ev.events = EPOLLIN | EPOLLET; ev.data.fd = cfd; ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, \u0026amp;ev); if(ret == -1) { perror(\u0026#34;epoll_ctl-accept\u0026#34;); exit(0); } } else { char buf[5]; memset(buf, 0, sizeof(buf)); while(1) { int len = recv(curfd, buf, sizeof(buf), 0); if(len == 0) { printf(\u0026#34;客户端断开了连接...\\n\u0026#34;); epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); break; } else if(len \u0026gt; 0) { write(STDOUT_FILENO, buf, len); send(curfd, buf, len, 0); } else { if(errno == EAGAIN) { printf(\u0026#34;数据读完了...\\n\u0026#34;); break; } else { perror(\u0026#34;recv\u0026#34;); exit(0); } } } } } } return 0; } ","date":"2025-04-14T00:00:00Z","image":"https://serennan.github.io/post/linux-epoll/cover.png","permalink":"https://serennan.github.io/post/linux-epoll/","title":"【Linux】IO多路复用 epoll"},{"content":"using 的使用 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n在C++中using用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在C++11中赋予了using新的功能，让C++变得更年轻，更灵活。\n1. 定义别名 在 C++中可以通过 typedef 重定义一个类型，语法格式如下：\n1 2 typedef 旧的类型名 新的类型名; typedef unsigned int uint_t; 被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用using。\n在使用的时候，关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。 使用using定义别名的语法格式是这样的：\n1 2 using 新的类型 = 旧的类型; using uint_t = int; 通过using和typedef的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了，看一下下面的例子：\n1 2 3 typedef int(*func_ptr)(int, double); using func_ptr1 = int(*)(int, double); 如果不是特别熟悉函数指针与typedef，第一眼很难看出func_ptr其实是一个别名，其本质是一个函数指针，指向的函数返回类型是int，函数参数有两个分别是int，double类型。\n使用using定义函数指针别名的写法看起来就非常直观了，把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边，比较清晰，可读性比较好。\n2. 模板的别名 使用typedef重定义类似很方便，但是它有一点限制，比如无法重定义一个模板，比如我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:\n1 2 3 typedef map\u0026lt;int, string\u0026gt; m1; typedef map\u0026lt;int, int\u0026gt; m2; typedef map\u0026lt;int, double\u0026gt; m3; 在这种情况下我们就不自觉的想到了模板：\n1 2 template \u0026lt;typename T\u0026gt; typedef map\u0026lt;int, T\u0026gt; type; 使用typename不支持给模板定义别名，这个简单的需求仅通过typedef很难办到，需要添加一个外敷类\n在C++中，\u0026ldquo;外敷类\u0026rdquo;（Wrapper Class）是指一种设计模式，它通过创建一个新的类来封装或\u0026quot;包裹\u0026quot;现有的功能或类型，以提供更简单、更安全或更灵活的接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; struct MyMap { typedef map\u0026lt;int, T\u0026gt; type; }; int main(void) { MyMap\u0026lt;string\u0026gt;::type m; m.insert(make_pair(1, \u0026#34;luffy\u0026#34;)); m.insert(make_pair(2, \u0026#34;ace\u0026#34;)); MyMap\u0026lt;int\u0026gt;::type m1; m1.insert(1, 100); m1.insert(2, 200); return 0; } 通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。在C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名，对于上面的需求可以写成这样：\n1 2 template \u0026lt;typename T\u0026gt; using mymap = map\u0026lt;int, T\u0026gt;; 完整的示例代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; using mymap = map\u0026lt;int, T\u0026gt;; int main(void) { mymap\u0026lt;string\u0026gt; m; m.insert(make_pair(1, \u0026#34;luffy\u0026#34;)); m.insert(make_pair(2, \u0026#34;ace\u0026#34;)); mymap\u0026lt;int\u0026gt; m1; m1.insert(1, 100); m1.insert(2, 200); return 0; } 上面的例子中通过使用using给模板指定别名，就可以基于别名非常方便的给value指定相应的类型，这样使编写的程序变得更加灵活，看起来也更加简洁一些。\n最后在强调一点：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。\n","date":"2025-04-11T00:00:00Z","image":"https://serennan.github.io/post/cpp-using/cover.png","permalink":"https://serennan.github.io/post/cpp-using/","title":"【C++11】uisng的使用"},{"content":"共享智能指针 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。\nC++11中提供了三种智能指针，使用这些智能指针时需要引用头文件 \u0026lt;memory\u0026gt;：\nstd::shared_ptr：共享的智能指针 std::unique_ptr：独占的智能指针 std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 shared_ptr的。 共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针 shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及 reset方法。 共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数 use_count，函数原型如下：\n1 long use_count() const noexcept; 1. 通过构造函数初始化 1 std::shared_ptr\u0026lt;T\u0026gt; 智能指针名字(创建堆内存); 测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; int main() { shared_ptr\u0026lt;int\u0026gt; ptr1(new int(520)); cout \u0026lt;\u0026lt; \u0026#34;ptr1管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr1.use_count() \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;char\u0026gt; ptr2(new char[12]); cout \u0026lt;\u0026lt; \u0026#34;ptr2管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr2.use_count() \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;int\u0026gt; ptr3; cout \u0026lt;\u0026lt; \u0026#34;ptr3管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr3.use_count() \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;int\u0026gt; ptr4(nullptr); cout \u0026lt;\u0026lt; \u0026#34;ptr4管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr4.use_count() \u0026lt;\u0026lt; endl; return 0; } 测试代码输出的结果如下:\n1 2 3 4 ptr1管理的内存引用计数: 1 ptr2管理的内存引用计数: 1 ptr3管理的内存引用计数: 0 ptr4管理的内存引用计数: 0 如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1。\n另外，不要使用一个原始指针初始化多个 shared_ptr。\n1 2 3 int *p = new int; shared_ptr\u0026lt;int\u0026gt; p1(p); shared_ptr\u0026lt;int\u0026gt; p2(p); 2. 通过拷贝和移动构造函数初始化 当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; int main() { // 1. 通过构造函数初始化 shared_ptr\u0026lt;int\u0026gt; ptr1(new int(520)); cout \u0026lt;\u0026lt; \u0026#34;ptr1管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr1.use_count() \u0026lt;\u0026lt; endl; // 2. 通过拷贝构造函数初始化 shared_ptr\u0026lt;int\u0026gt; ptr2(ptr1); cout \u0026lt;\u0026lt; \u0026#34;ptr2管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr2.use_count() \u0026lt;\u0026lt; endl; // 3. 通过拷贝赋值运算符初始化 shared_ptr\u0026lt;int\u0026gt; ptr3 = ptr1; cout \u0026lt;\u0026lt; \u0026#34;ptr3管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr3.use_count() \u0026lt;\u0026lt; endl; // 4. 通过移动构造函数初始化 shared_ptr\u0026lt;int\u0026gt; ptr4(std::move(ptr1)); cout \u0026lt;\u0026lt; \u0026#34;ptr4管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr4.use_count() \u0026lt;\u0026lt; endl; // 5. 通过移动赋值运算符初始化 std::shared_ptr\u0026lt;int\u0026gt; ptr5 = std::move(ptr2); cout \u0026lt;\u0026lt; \u0026#34;ptr5管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr5.use_count() \u0026lt;\u0026lt; endl; return 0; } 测试程序输入的结果：\n1 2 3 4 5 ptr1管理的内存引用计数: 1 ptr2管理的内存引用计数: 2 ptr3管理的内存引用计数: 3 ptr4管理的内存引用计数: 3 ptr5管理的内存引用计数: 3 如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。\n3. 通过 make_shared () 初始化 通过C++提供的 std::make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：\n1 2 template\u0026lt; class T, class... Args \u0026gt; shared_ptr\u0026lt;T\u0026gt; make_shared( Args\u0026amp;\u0026amp;... args ); T：模板参数的数据类型 Args\u0026amp;\u0026amp;... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定 测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class Test { public: Test() { cout \u0026lt;\u0026lt; \u0026#34;construct Test...\u0026#34; \u0026lt;\u0026lt; endl; } Test(int x) { cout \u0026lt;\u0026lt; \u0026#34;construct Test, x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } Test(string str) { cout \u0026lt;\u0026lt; \u0026#34;construct Test, str = \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } ~Test() { cout \u0026lt;\u0026lt; \u0026#34;destruct Test ...\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { shared_ptr\u0026lt;int\u0026gt; ptr1 = make_shared\u0026lt;int\u0026gt;(520); cout \u0026lt;\u0026lt; \u0026#34;ptr1管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr1.use_count() \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;Test\u0026gt; ptr2 = make_shared\u0026lt;Test\u0026gt;(); cout \u0026lt;\u0026lt; \u0026#34;ptr2管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr2.use_count() \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;Test\u0026gt; ptr3 = make_shared\u0026lt;Test\u0026gt;(520); cout \u0026lt;\u0026lt; \u0026#34;ptr3管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr3.use_count() \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;Test\u0026gt; ptr4 = make_shared\u0026lt;Test\u0026gt;(\u0026#34;我是要成为海贼王的男人!!!\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;ptr4管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr4.use_count() \u0026lt;\u0026lt; endl; return 0; } 输出：\n1 2 3 4 5 6 7 8 9 10 ptr1管理的内存引用计数: 1 construct Test... ptr2管理的内存引用计数: 1 construct Test, x = 520 ptr3管理的内存引用计数: 1 construct Test, str = 我是要成为海贼王的男人!!! ptr4管理的内存引用计数: 1 destruct Test ... destruct Test ... destruct Test ... 使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的()可完成地址的初始化，如果要创建一个类对象，函数的()内部需要指定构造对象需要的参数，也就是类构造函数的参数。\n4. 通过 reset 方法初始化 共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：\n1 2 3 4 5 6 7 8 9 10 void reset() noexcept; template\u0026lt; class Y \u0026gt; void reset( Y* ptr ); template\u0026lt; class Y, class Deleter \u0026gt; void reset( Y* ptr, Deleter d ); template\u0026lt; class Y, class Deleter, class Alloc \u0026gt; void reset( Y* ptr, Deleter d, Alloc alloc ); ptr：指向要取得所有权的对象的指针 d：指向要取得所有权的对象的指针 aloc：内部存储所用的分配器 测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; int main() { shared_ptr\u0026lt;int\u0026gt; ptr1 = make_shared\u0026lt;int\u0026gt;(520); shared_ptr\u0026lt;int\u0026gt; ptr2 = ptr1; shared_ptr\u0026lt;int\u0026gt; ptr3 = ptr1; shared_ptr\u0026lt;int\u0026gt; ptr4 = ptr1; cout \u0026lt;\u0026lt; \u0026#34;ptr1管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr1.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ptr2管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr2.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ptr3管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr3.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ptr4管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr4.use_count() \u0026lt;\u0026lt; endl; ptr4.reset(); cout \u0026lt;\u0026lt; \u0026#34;ptr1管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr1.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ptr2管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr2.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ptr3管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr3.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ptr4管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr4.use_count() \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;int\u0026gt; ptr5; ptr5.reset(new int(250)); cout \u0026lt;\u0026lt; \u0026#34;ptr5管理的内存引用计数: \u0026#34; \u0026lt;\u0026lt; ptr5.use_count() \u0026lt;\u0026lt; endl; return 0; } 测试代码输入的结果:\n1 2 3 4 5 6 7 8 9 10 11 ptr1管理的内存引用计数: 4 ptr2管理的内存引用计数: 4 ptr3管理的内存引用计数: 4 ptr4管理的内存引用计数: 4 ptr1管理的内存引用计数: 3 ptr2管理的内存引用计数: 3 ptr3管理的内存引用计数: 3 ptr4管理的内存引用计数: 0 ptr5管理的内存引用计数: 1 如果使用reset方法，就可以将智能指针重新指向一块新的内存，同时这块新的内存的引用计数也会+1。如果reset方法不带参数，那么智能指针就会指向空指针，同时原来指向的内存的引用计数也会-1。\n对于一个未初始化的共享智能指针，可以通过reset方法来初始化，\n5. 获取原始指针 通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的 get()方法，其函数原型如下：\n1 T* get() const noexcept; 测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; int main() { int len = 128; shared_ptr\u0026lt;char\u0026gt; ptr(new char[len]); char* add = ptr.get(); memset(add, 0, len); strcpy(add, \u0026#34;我是要成为海贼王的男人!!!\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;string: \u0026#34; \u0026lt;\u0026lt; add \u0026lt;\u0026lt; endl; shared_ptr\u0026lt;int\u0026gt; p(new int); *p = 100; cout \u0026lt;\u0026lt; *p.get() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; return 0; } memset 是 C/C++ 中的一个标准库函数，用于将内存块的每个字节设置为特定的值。它的函数原型如下：\n1 void *memset(void *ptr, int value, size_t num); 参数说明：\nptr ：指向要填充的内存块的指针 value ：要设置的值（以 int 形式传递，但实际会转换为 unsigned char） num ：要填充的字节数 如果value设置为0，即清空内存块缓冲区\n6. 指定删除器 当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; void deleteIntPtr(int* p) { delete p; cout \u0026lt;\u0026lt; \u0026#34;int 型内存被释放了...\u0026#34;; } int main() { shared_ptr\u0026lt;int\u0026gt; ptr(new int(250), deleteIntPtr); return 0; } 删除器函数也可以是lambda表达式，因此代码也可以写成下面这样：\n1 2 3 4 5 int main() { shared_ptr\u0026lt;int\u0026gt; ptr(new int(250), [](int* p) {delete p; }); return 0; } 在上面的代码中，lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。\n在C++11中使用shared_ptr管理动态数组时，需要指定删除器，因为 std::shared_ptr的默认删除器不支持数组对象，具体的处理代码如下：\n1 2 3 4 5 int main() { shared_ptr\u0026lt;int\u0026gt; ptr(new int[10], [](int* p) {delete[]p; }); return 0; } 在删除数组内存时，除了自己编写删除器，也可以使用C++提供的 std::default_delete\u0026lt;T\u0026gt;()函数作为删除器，这个函数内部的删除功能也是通过调用 delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：\n1 2 3 4 5 int main() { shared_ptr\u0026lt;int\u0026gt; ptr(new int[10], default_delete\u0026lt;int[]\u0026gt;()); return 0; } 另外，我们还可以自己封装一个make_shared_array方法来让shared_ptr支持数组，代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; shared_ptr\u0026lt;T\u0026gt; make_share_array(size_t size) { return shared_ptr\u0026lt;T\u0026gt;(new T[size], default_delete\u0026lt;T[]\u0026gt;()); } int main() { // 创建并操作int数组 shared_ptr\u0026lt;int\u0026gt; ptr1 = make_share_array\u0026lt;int\u0026gt;(5); for(int i = 0; i \u0026lt; 5; ++i) { ptr1.get()[i] = i * 10; // 使用get()获取原始指针并操作数组 cout \u0026lt;\u0026lt; ptr1.get()[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 创建并操作char数组(字符串) shared_ptr\u0026lt;char\u0026gt; ptr2 = make_share_array\u0026lt;char\u0026gt;(20); strcpy(ptr2.get(), \u0026#34;Hello, shared_ptr!\u0026#34;); cout \u0026lt;\u0026lt; ptr2.get() \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-04-11T00:00:00Z","image":"https://serennan.github.io/post/cpp-share_ptr/cover.png","permalink":"https://serennan.github.io/post/cpp-share_ptr/","title":"【C++11】共享智能指针"},{"content":"Google Test 测试框架 在项目开发中，测试项目是非常重要的，关系到代码的一些逻辑以及性能测试。\n由于C++没有自带的测试框架，Google Test是Google开发的一个C++测试框架，支持自动化测试、死亡测试、参数化测试等多种测试场景。\n配置 1 2 3 4 5 6 7 8 9 10 11 12 # 克隆Google Test仓库 git clone https://github.com/google/googletest.git # 进入项目目录 cd googletest/ # 创建并进入build目录 mkdir build \u0026amp;\u0026amp; cd build # 使用CMake配置项目，指定C++17标准 cmake -DCMAKE_CXX_STANDARD=17 .. # 编译项目 make # 安装到系统目录(可选) sudo make install 可以不执行最后一条指令，直接把头文件和库文件复制到项目目录中。具体步骤如下：\n复制头文件： 1 cp -r googletest/include/gtest /path/to/your/project/include/ 复制库文件： 1 2 cp googletest/build/lib/libgtest.a /path/to/your/project/lib/ cp googletest/build/lib/libgtest_main.a /path/to/your/project/lib/ 在CMakeLists.txt中添加以下配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 指定CMake最低版本要求 cmake_minimum_required(VERSION 3.10) # 定义项目名称 project(gtest) # 设置C++17标准 set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED ON) # 生成编译命令数据库(用于IDE支持) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 链接库文件目录 link_directories(${CMAKE_SOURCE_DIR}/lib) # 添加可执行文件 add_executable(${PROJECT_NAME} src/main.cpp) # 添加头文件目录 target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/include ) # 链接Google Test库 target_link_libraries(${PROJECT_NAME} libgtest.a # Google Test核心库 libgtest_main.a # 提供main()函数的库 ) 基本用法 包含头文件 1 #include \u0026lt;gtest/gtest.h\u0026gt; 编写测试用例 1 2 3 4 5 // TEST宏定义测试用例，参数为测试套件名和测试名 TEST(TestSuiteName, TestName) { // EXPECT_EQ断言检查两个值是否相等 EXPECT_EQ(1, 1); // 断言 } 运行测试 1 2 3 4 int main(int argc, char **argv) { testing::InitGoogleTest(\u0026amp;argc, argv); return RUN_ALL_TESTS(); } 常见测试场景 简单测试 1 2 3 4 5 // 简单测试示例：验证2+2等于4 TEST(MathTest, TwoPlusTwoEqualsFour) { // 使用EXPECT_EQ断言验证表达式结果 EXPECT_EQ(2 + 2, 4); } 测试夹具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 测试夹具类，继承自testing::Test class QueueTest : public testing::Test { protected: // 每个测试用例执行前会调用SetUp void SetUp() override { q1_.Enqueue(1); // 初始化测试数据 } Queue\u0026lt;int\u0026gt; q1_; // 测试对象 }; // TEST_F用于测试夹具，第一个参数是夹具类名 TEST_F(QueueTest, IsEmptyInitially) { // 验证队列初始状态 EXPECT_EQ(q1_.size(), 1); } gmock使用 后续有使用到再做演示\n","date":"2025-04-09T00:00:00Z","image":"https://serennan.github.io/post/c-google_test/cover.png","permalink":"https://serennan.github.io/post/c-google_test/","title":"Google Test 测试框架"},{"content":"多数元素 这题虽然是个简单题，但是官方给出的题解很丰富，我觉得可以通过这道题来拓展一下我们的解题思路\n官方：169.多数元素 Leetcode官方题解\n题目描述 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1：\n输入：nums = [3,2,3]\n输出：3\n示例 2：\n输入：nums = [2,2,1,1,1,2,2]\n输出：2\n提示：\nn == nums.length\n1 \u0026lt;= n \u0026lt;= 5 * 104\n-109 \u0026lt;= nums[i] \u0026lt;= 109\n进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。\n方法一：哈希表 思路\n这是最容易想到的思路，使用哈希表记录每个元素出现的次数，只要某个元素次数出现超过n/2，那么这个元素就是众数。\n算法\n使用哈希表存储每个元素以及出现的次数。键表示一个元素，值表示这个元素出现的次数。循环遍历整个数组，只要有某一个数超过n/2，就返回这个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt; \u0026amp;nums) { unordered_map\u0026lt;int, int\u0026gt; map; int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { map[nums[i]]++; if (map[nums[i]] \u0026gt; n / 2) { return nums[i]; } } return 0; } }; 复杂度分析\n时间复杂度：O(n)。其中 n 是数组 nums 的长度。我们遍历数组 nums 一次，对于 nums 中的每一个元素，将其插入哈希表都只需要常数时间。\n空间复杂度：O(n)。哈希表中最多包含 n - (n/2) 个键值对。\n方法二：排序 思路\n如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为[n/2]的元素（下标从 0 开始）一定是众数。\n算法\n对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。\n1 2 3 4 5 6 7 8 9 class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); return nums[nums.size()/2]; } }; 复杂度分析\n时间复杂度：O(nlogn)。排序复杂度 空间复杂度：O(logn)。语言自带的排序算法需要使用O(logn)的栈空间。 方法三：随机化 思路\n这个思路挺新颖的，因为众数占据超过一半的下标，所以有超过 50% 的概率能找到众数。\n算法\n由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt; \u0026amp;nums) { while (true) { int candidate = nums[rand() % nums.size()]; int count = 0; for (int num : nums) if (num == candidate) ++count; if (count \u0026gt; nums.size() / 2) return candidate; } return -1; } }; 复杂度分析\n时间复杂度：理论上最坏时间复杂度是O(∞)，运气很差的情况下一直得不到众数。但是众数占比超过 50% ，随机取数的概率还是非常大的。（这里我就没详细计算了，官方题解上有详细的计算）\n空间复杂度：O(1)。随机方法只需要常数级别的额外空间\n方法四：Boyer-Moore 投票算法 思路\n如果使用一个变量count，初始化是0，遇到众数加1，反之减1，那么得到的count至少大于0。（因为众数最少都是n/2 + 1）\n算法\n维护一个候选众数 candidate 和出现次数count。初始时，candidate可以是任意数，count为0;\n遍历整个nums，每次都判断当前数 num 是否等于candidate，相等则count增加，反之减少，每当count减小到负数，就更换candidate的值，count重置为0;\n在遍历完成之后，candidate即为众数。\n例子\n简单的举一个例子：\nnums 2 2 1 1 1 1 2 2 3 2 2 2 2 candidate 2 2 2 2 1 1 1 1 3 3 2 2 2 count 1 2 1 0 1 2 1 0 1 0 1 2 3 第一个数就是众数，假如我们使用value只记录众数 2 ，记录方法和count一样：\nnums 2 2 1 1 1 1 2 2 3 2 2 2 2 value 1 2 1 0 -1 -2 -1 0 -1 0 1 2 3 你会惊讶的发现，此时的count和value要么相等，要么互为相反数，candidate是2时，就相等，candidate是其他数时，就互为相反数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int candidate = nums[0]; int count = 0; for (auto num : nums) { if (num == candidate) { count++; } else { count--; if (count == 0) { candidate = num; count = 1; } } } return candidate; } }; 复杂度分析\n时间复杂度：O(n)。值对数组进行一次扫描。 空间复杂度：O(n)。不需要额外的空间。 ","date":"2025-04-05T00:00:00Z","image":"https://serennan.github.io/post/169.majority-element/cover.png","permalink":"https://serennan.github.io/post/169.majority-element/","title":"【面试高频】 169.多数元素"},{"content":"多线程线程异步 C++11中增加的线程类，使得我们能够非常方便的创建和使用线程，但有时会有些不方便，比如需要获取线程返回的结果，就不能通过join()得到结果，只能通过一些额外手段获得，比如：定义一个全局变量，在子线程中赋值，在主线程中读这个变量的值，整个过程比较繁琐。C++提供的线程库中提供了一些类用于访问异步操作的结果。\n那么，什么叫做异步呢？\n我们去星巴克买咖啡，因为都是现磨的，所以需要等待，但是我们付完账后不会站在柜台前死等，而是去找个座位坐下来玩玩手机打发一下时间，当店员把咖啡磨好之后，就会通知我们过去取，这就叫做异步。\n顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客去做别的事情了，有两条时间线（异步） 顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客没去做别的事情而是死等，这时就只有一条时间线（同步），此时效率相对较低。 因此多线程程序中的任务大都是异步的，主线程和子线程分别执行不同的任务。\n1. std::future 如果想要在主线程中得到某个子线程任务函数返回的结果，可以使用C++11提供的std:future类，这个类需要和其他类或函数搭配使用，先来介绍一下这个类的API函数：\n类的定义\n通过类的定义可以得知，future是一个模板类，也就是这个类可以存储任意指定类型的数据。\n1 2 3 template\u0026lt; class T \u0026gt; class future; template\u0026lt; class T \u0026gt; class future\u0026lt;T\u0026amp;\u0026gt;; template\u0026lt;\u0026gt; class future\u0026lt;void\u0026gt;; 构造函数\n1 2 3 future() noexcept; future( future\u0026amp;\u0026amp; other ) noexcept; future( const future\u0026amp; other ) = delete; 构造函数①：默认无参构造函数 构造函数②：移动构造函数，转移资源的所有权 构造函数③：使用=delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝 常用成员函数（public)\n一般情况下使用=进行赋值操作就进行对象的拷贝，但是future对象不可用复制，因此会根据实际情况进行处理：\n如果other是右值，那么转移资源的所有权 如果other是非右值，不允许进行对象之间的拷贝（该函数被显示删除禁止使用） 1 2 future\u0026amp; operator=( future\u0026amp;\u0026amp; other ) noexcept; future\u0026amp; operator=( const future\u0026amp; other ) = delete; 取出future对象内部保存的数据，其中void get()是为future\u0026lt;void\u0026gt;准备的，此时对象内部类型就是void，该函数是一个阻塞函数，当子线程的数据就绪后解除阻塞就能得到传出的数值了。\n1 2 3 T get(); T\u0026amp; get(); void get(); 因为future对象内部存储的是异步线程任务执行完毕后的结果，是在调用之后的将来得到的，因此可以通过调用wait()方法，阻塞当前线程，等待这个子线程的任务执行完毕，任务执行完毕当前线程的阻塞也就解除了。\n1 void wait() const; 如果当前线程wait()方法就会死等，直到子线程任务执行完毕将返回值写入到future对象中，调用wait_for()只会让线程阻塞一定的时长，但是这样并不能保证对应的那个子线程中的任务已经执行完毕了。wait_until()和wait_for()函数功能是差不多，前者是阻塞到某一指定的时间点，后者是阻塞一定的时长。\n1 2 3 4 template\u0026lt; class Rep, class Period \u0026gt; std::future_status wait_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration ) const; template\u0026lt; class Clock, class Duration \u0026gt; std::future_status wait_until( const std::chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; timeout_time ) const; 当wait_until()和wait_for()函数返回之后，并不能确定子线程当前的状态，因此我们需要判断函数的返回值，这样就能知道子线程当前的状态了：\n常量 解释 future_status::deferred 子线程中的任务尚未启动 future_status::ready 子线程中的任务已经执行完毕，结果已就绪 future_status::timeout 子线程中的任务正在执行中，指定等待时长已用完 2. std::promise std::promise是一个协助线程赋值的类，它能够将数据和future对象绑定起来，为获取线程函数中的某个值提供便利。\n2.1 类成员函数 类定义\n通过std::promise类的定义可以得知，这也是一个模板类，我们要在线程中传递什么类型的数据，模板参数就指定为什么类型。\n1 2 3 template\u0026lt; class R \u0026gt; class promise; template\u0026lt; class R \u0026gt; class promise\u0026lt;R\u0026amp;\u0026gt;; template\u0026lt;\u0026gt; class promise\u0026lt;void\u0026gt;; 构造函数\n1 2 3 promise(); promise( promise\u0026amp;\u0026amp; other ) noexcept; promise( const promise\u0026amp; other ) = delete; 构造函数①：默认构造函数，得到一个空对象 构造函数②：移动构造函数 构造函数③：使用=delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝 公共成员函数\n在std::promise类内部管理着一个future类对象，调用get_future()就可以得到这个future对象了。\n1 std::future\u0026lt;R\u0026gt; get_future(); 存储要传出的 value 值，并立即让状态就绪，这样数据被传出其它线程就可以得到这个数据了。重载的第四个函数是为promise\u0026lt;void\u0026gt;类型的对象准备的。\n1 2 3 4 void set_value( const R\u0026amp; value ); void set_value( R\u0026amp;\u0026amp; value ); void set_value( R\u0026amp; value ); void set_value(); 存储要传出的 value 值，但是不立即令状态就绪。在当前线程退出时，子线程资源被销毁，再令状态就绪。\n1 2 3 4 void set_value_at_thread_exit( const R\u0026amp; value ); void set_value_at_thread_exit( R\u0026amp;\u0026amp; value ); void set_value_at_thread_exit( R\u0026amp; value ); void set_value_at_thread_exit(); 2.2 promise的使用 通过promise传递数据的过程一共分为5步：\n在主线程中创建std::promise对象 将这个std::promise对象通过引用的方式传递给子线程的任务函数 在子线程任务函数中给std::promise对象赋值 在主线程中通过std::promise对象取出绑定的future实例对象 通过得到的future对象取出子线程任务函数中返回的值。 使用 set_value 子线程任务函数执行期间，让状态就绪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; int main() { promise\u0026lt;int\u0026gt; pr; thread t1([](promise\u0026lt;int\u0026gt; \u0026amp;p) { p.set_value(100); this_thread::sleep_for(chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;睡醒了....\u0026#34; \u0026lt;\u0026lt; endl; }, ref(pr)); future\u0026lt;int\u0026gt; f = pr.get_future(); int value = f.get(); cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; t1.join(); return 0; } 示例程序输出的结果：\n1 2 3 value: 100 // 立刻就绪 // 子线程休眠5秒后才输出 睡醒了.... 示例程序的中子线程的任务函数指定的是一个匿名函数，在这个匿名的任务函数执行期间通过p.set_value(100);传出了数据并且激活了状态，数据就绪后，外部主线程中的int value = f.get();解除阻塞，并将得到的数据打印出来，5秒钟之后子线程休眠结束，匿名的任务函数执行完毕。\n使用 set_value_at_thread_exit 子线程任务函数执行结束，让状态就绪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; using namespace std; int main() { promise\u0026lt;int\u0026gt; pr; thread t1([](promise\u0026lt;int\u0026gt; \u0026amp;p) { p.set_value_at_thread_exit(100); this_thread::sleep_for(chrono::seconds(5)); cout \u0026lt;\u0026lt; \u0026#34;睡醒了....\u0026#34; \u0026lt;\u0026lt; endl; }, ref(pr)); future\u0026lt;int\u0026gt; f = pr.get_future(); int value = f.get(); cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; t1.join(); return 0; } 示例程序输出的结果：\n1 2 3 // 子线程休眠5秒后才输出 睡醒了.... value: 100 // 子线程执行完毕后才就绪 在示例程序中，子线程的这个匿名的任务函数中通过p.set_value_at_thread_exit(100);在执行完毕并退出之后才会传出数据并激活状态，数据就绪后，外部主线程中的int value = f.get();解除阻塞，并将得到的数据打印出来，因此子线程在休眠5秒钟之后主线程中才能得到传出的数据。\n另外，在这两个实例程序中有一个知识点需要强调，在外部主线程中创建的promise对象必须要通过引用的方式传递到子线程的任务函数中，在实例化子线程对象的时候，如果任务函数的参数是引用类型，那么实参一定要放到std::ref()函数中，表示要传递这个实参的引用到任务函数中。\n3. std::packaged_task std::packaged_task类包装了一个可调用对象包装器类对象（可调用对象包装器包装的是可调用对象，可调用对象都可以作为函数来使用）\n这个类可以将内部包装的函数和future类绑定到一起，以便进行后续的异步调用，它和std::promise有点类似，std::promise内部保存一个共享状态的值，而std::packaged_task保存的是一个函数。\n3.1 类成员函数 类的定义\n通过类的定义可以看到这也是一个模板类，模板类型和要在线程中传出的数据类型是一致的。\n1 2 3 4 // 定义于头文件 \u0026lt;future\u0026gt; template\u0026lt; class \u0026gt; class packaged_task; template\u0026lt; class R, class ...Args \u0026gt; class packaged_task\u0026lt;R(Args...)\u0026gt;; 构造函数\n1 2 3 4 packaged_task() noexcept; template\u0026lt; class F \u0026gt; explicit packaged_task( F\u0026amp;\u0026amp; f ); packaged_task( const packaged_task\u0026amp; ) = delete; packaged_task( packaged_task\u0026amp;\u0026amp; rhs ) noexcept; 构造函数①：无参构造，构造一个无任务的空对象 构造函数②：通过一个可调用对象，构造一个任务对象 构造函数③：显示删除，不允许通过拷贝构造函数进行对象的拷贝 构造函数④：移动构造函数 常用公共成员函数\n1 std::future\u0026lt;R\u0026gt; get_future(); 通过调用任务对象内部的get_future()方法就可以得到一个future对象，基于这个对象就可以得到传出的数据了。\n3.2 packaged_task的使用 packaged_task其实就是对子线程要执行的任务函数进行了包装，和可调用对象包装器的使用方法相同，包装完毕之后直接将包装得到的任务对象传递给线程对象就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; int main() { // packaged_task\u0026lt;返回值类型(参数类型)\u0026gt; packaged_task\u0026lt;int(string)\u0026gt; task([](string x) -\u0026gt; int { // lambda参数类型必须匹配packaged_task的参数类型(string) // lambda返回值类型必须匹配packaged_task的返回值类型(int) return stoi(x); // 将string转换为int返回 }); // thread构造函数的参数: // 第一个参数是可调用对象(这里是包装后的task) // 第二个参数必须能转换为task的参数类型(string) thread t1(ref(task), \u0026#34;10\u0026#34;); // future类型必须匹配packaged_task的返回值类型(int) future\u0026lt;int\u0026gt; f = task.get_future(); // value类型必须匹配future的模板参数(int) int value = f.get(); cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; t1.join(); return 0; } 在上面的示例代码中，通过packaged_task类包装了一个匿名函数作为子线程的任务函数，最终的得到的这个任务对象需要通过引用的方式传递到子线程内部，这样才能在主线程的最后通过任务对象得到future对象，再通过这个future对象取出子线程通过返回值传递出的数据。\n4. std::async std::async函数比前面提到的std::promise和packaged_task更高级一些，因为通过这函数可以直接启动一个子线程并在这个子线程中执行对应的任务函数，异步任务执行完成返回的结果也是存储到一个future对象中，当需要获取异步任务的结果时，只需要调用future 类的get()方法即可，如果不关注异步任务的结果，只是简单地等待任务完成的话，可以调用future 类的wait()或者wait_for()方法。该函数的函数原型如下：\n1 2 3 4 5 6 7 8 // 定义于头文件 \u0026lt;future\u0026gt; template\u0026lt; class Function, class... Args\u0026gt; std::future\u0026lt;std::result_of_t\u0026lt;std::decay_t\u0026lt;Function\u0026gt;(std::decay_t\u0026lt;Args\u0026gt;...)\u0026gt;\u0026gt; async( Function\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); template\u0026lt; class Function, class... Args \u0026gt; std::future\u0026lt;std::result_of_t\u0026lt;std::decay_t\u0026lt;Function\u0026gt;(std::decay_t\u0026lt;Args\u0026gt;...)\u0026gt;\u0026gt; async( std::launch policy, Function\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); 可以看到这是一个模板函数，在C++11中这个函数有两种调用方式：\n函数①：直接调用传递到函数体内部的可调用对象，返回一个future对象 函数②：通过指定的策略调用传递到函数内部的可调用对象，返回一个future对象 函数参数:\nf：可调用对象，这个对象在子线程中被作为任务函数使用 Args：传递给 f 的参数（实参） policy：可调用对象·f的执行策略 策略 说明 launch::async 调用 async 函数时创建新的线程执行任务函数 launch::deferred 调用 async 函数时不执行任务函数，直到调用了 future 的 get() 或者 wait() 时才执行任务（这种方式不会创建新的线程） 4.1 方式1 调用async()函数直接创建线程执行任务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; future\u0026lt;int\u0026gt; f = async([](int x) { cout \u0026lt;\u0026lt; \u0026#34;子线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(5)); return x += 100; }, 100); future_status status; do { status = f.wait_for(chrono::seconds(1)); if (status == future_status::deferred) { cout \u0026lt;\u0026lt; \u0026#34;线程还没有执行...\u0026#34; \u0026lt;\u0026lt; endl; f.wait(); } else if (status == future_status::ready) { cout \u0026lt;\u0026lt; \u0026#34;子线程返回值: \u0026#34; \u0026lt;\u0026lt; f.get() \u0026lt;\u0026lt; endl; } else if (status == future_status::timeout) { cout \u0026lt;\u0026lt; \u0026#34;任务还未执行完毕, 继续等待...\u0026#34; \u0026lt;\u0026lt; endl; } } while (status != future_status::ready); return 0; } 示例程序输出的结果为：\n1 2 3 4 5 6 7 8 主线程ID: 8904 子线程ID: 25036 任务还未执行完毕, 继续等待... 任务还未执行完毕, 继续等待... 任务还未执行完毕, 继续等待... 任务还未执行完毕, 继续等待... 任务还未执行完毕, 继续等待... 子线程返回值: 200 调用async()函数时不指定策略就是直接创建线程并执行任务，示例代码的主线程中做了如下操作status = f.wait_for(chrono::seconds(1));其实直接调用f.get()就能得到子线程的返回值。这里为了给大家演示wait_for()的使用，所以写的复杂了些。\n4.2 方式2 调用async()函数不创建线程执行任务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; future\u0026lt;int\u0026gt; f = async(launch::deferred, [](int x) { cout \u0026lt;\u0026lt; \u0026#34;子线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; return x += 100; }, 100); this_thread::sleep_for(chrono::seconds(5)); cout \u0026lt;\u0026lt; f.get(); return 0; } 示例程序输出的结果：\n1 2 3 4 主线程ID: 140097415804736 // 主线程休眠 5 秒 子线程ID: 140097415804736 200 由于指定了 launch::deferred 策略，因此调用 async() 函数并不会创建新的线程执行任务，当使用 future 类对象调用了 get() 或者 wait() 方法后才开始执行任务（此处一定要注意调用 wait_for() 函数是不行的）。通过测试程序输出的结果可以看到，两次输出的线程ID是相同的，任务函数是在主线程中被延迟（主线程休眠了5秒）调用了。\n4.3 方式3 调用async()函数创建线程执行任务\n将 launch::deferred 策略改为 launch::async 策略，以创建新的线程执行任务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; future\u0026lt;int\u0026gt; f = async(launch::async, [](int x) { cout \u0026lt;\u0026lt; \u0026#34;子线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; return x += 100; }, 100); this_thread::sleep_for(chrono::seconds(5)); cout \u0026lt;\u0026lt; f.get(); return 0; } 示例程序输出的结果：\n1 2 3 4 主线程ID: 139768596973376 子线程ID: 139768596969152 // 主线程休眠 5 秒 200 由于指定了 launch::async 策略，因此调用 async() 函数会立即创建一个新线程来执行任务。主线程和子线程的ID不同，任务函数是在子线程中立即执行的，而主线程会继续执行其他代码。主线程在休眠5秒后通过 future 对象的 get() 方法获取任务的结果。\n最终总结 使用async()函数，是多线程操作中最简单的一种方式，不需要自己创建线程对象，并且可以得到子线程函数的返回值。 使用std::promise类，在子线程中可以传出返回值也可以传出其他数据，并且可选择在什么时机将数据从子线程中传递出来，使用起来更灵活。 使用std::packaged_task类，可以将子线程的任务函数进行包装，并且可以得到子线程的返回值。 ","date":"2025-04-04T00:00:00Z","image":"https://serennan.github.io/post/cpp-async/cover.png","permalink":"https://serennan.github.io/post/cpp-async/","title":"【C++11】多线程异步操作"},{"content":"原子变量 个人学习笔记，参照大丙老师的博客：爱编程的大丙\nC++11提供了一个原子类型std::atomic\u0026lt;T\u0026gt;，通过这个原子类型管理的内部变量就可以称之为原子变量，我们可以给原子类型指定bool、char、int、long、指针等类型作为模板参数（不支持浮点类型和复合类型）。\n原子指的是一系列不可被CPU上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核CPU下，当某个CPU核心开始运行原子操作时，会先暂停其它CPU内核对内存的操作，以保证原子操作不会被其它CPU内核所干扰。\n由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。\n可以看出原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了CAS循环，当大量的冲突发生时，该等待还是得等待，但是总归比锁要好。\nC++11内置了整形的原子变量，这样就可以更方便的使用原子变量了。在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁。因为对原子变量进行的操作只能是一个原子操作（atomic operation），原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何的上下文切换。多线程同时访问共享资源造成数据混乱的原因就是因为CPU的上下文切换导致的，使用原子变量解决了这个问题，因此互斥锁的使用也就不再需要了。\nCAS全称是Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值\n1. atomic 类成员 类定义\n1 2 template\u0026lt; class T \u0026gt; struct atomic; 通过定义可得知：在使用这个模板类的时候，一定要指定模板类型。\n构造函数 1 2 3 4 5 atomic() noexcept = default; constexpr atomic( T desired ) noexcept; atomic( const atomic\u0026amp; ) = delete; 构造函数①：默认无参构造函数。 构造函数②：使用 desired 初始化原子变量的值。 构造函数③：使用=delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝 公共成员函数 原子类型在类内部重载了=操作符，并且不允许在类的外部使用 =进行对象的拷贝。\n1 2 3 4 5 T operator=( T desired ) noexcept; T operator=( T desired ) volatile noexcept; atomic\u0026amp; operator=( const atomic\u0026amp; ) = delete; atomic\u0026amp; operator=( const atomic\u0026amp; ) volatile = delete; 原子地以 desired 替换当前值。按照 order 的值影响内存。\n1 2 void store( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept; void store( T desired, std::memory_order order = std::memory_order_seq_cst ) volatile noexcept; desired：存储到原子变量中的值 order：强制的内存顺序 原子地加载并返回原子变量的当前值。按照 order 的值影响内存。直接访问原子对象也可以得到原子变量的当前值。\n1 2 T load( std::memory_order order = std::memory_order_seq_cst ) const noexcept; T load( std::memory_order order = std::memory_order_seq_cst ) const volatile noexcept; 内存顺序约束 通过上面的 API 函数我们可以看出，在调用 atomic类提供的 API 函数的时候，需要指定原子顺序，在C++11给我们提供的 API 中使用枚举用作执行原子操作的函数的实参，以指定如何同步不同线程上的其他操作。\n定义如下:\n1 2 3 4 5 6 7 8 typedef enum memory_order { memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst } memory_order; memory_order_relaxed， 这是最宽松的规则，它对编译器和CPU不做任何限制，可以乱序 memory_order_release 释放，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面 memory_order_acquire 获取, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和Release在不同线程中联合使用 memory_order_consume：改进版的memory_order_acquire ，开销更小 memory_order_acq_rel，它是Acquire 和 Release 的结合，同时拥有它们俩提供的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序 memory_order_seq_cst 顺序一致性， memory_order_seq_cst 就像是memory_order_acq_rel的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到memory_order_seq_cst 的原子操作，线程中该memory_order_seq_cst 操作前的数据操作绝对不会被重新排在该memory_order_seq_cst 操作之后，且该memory_order_seq_cst 操作后的数据操作也绝对不会被重新排在memory_order_seq_cst 操作前。 2. 原子变量的使用 假设我们要制作一个多线程交替数数的计数器，我们使用互斥锁和原子变量的方式分别进行实现，对比一下二者的差异：\n2.1 互斥锁版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; struct Counter { void increment() { for (int i = 0; i \u0026lt; 10; ++i) { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); m_value++; cout \u0026lt;\u0026lt; \u0026#34;increment number: \u0026#34; \u0026lt;\u0026lt; m_value \u0026lt;\u0026lt; \u0026#34;, theadID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::milliseconds(100)); } } void decrement() { for (int i = 0; i \u0026lt; 10; ++i) { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); m_value--; cout \u0026lt;\u0026lt; \u0026#34;decrement number: \u0026#34; \u0026lt;\u0026lt; m_value \u0026lt;\u0026lt; \u0026#34;, theadID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::milliseconds(100)); } } int m_value = 0; mutex m_mutex; }; int main() { Counter c; auto increment = bind(\u0026amp;Counter::increment, \u0026amp;c); auto decrement = bind(\u0026amp;Counter::decrement, \u0026amp;c); thread t1(increment); thread t2(decrement); t1.join(); t2.join(); return 0; } 2.2 原子变量版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; struct Counter { void increment() { for (int i = 0; i \u0026lt; 10; ++i) { m_value++; cout \u0026lt;\u0026lt; \u0026#34;increment number: \u0026#34; \u0026lt;\u0026lt; m_value \u0026lt;\u0026lt; \u0026#34;, theadID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::milliseconds(500)); } } void decrement() { for (int i = 0; i \u0026lt; 10; ++i) { m_value--; cout \u0026lt;\u0026lt; \u0026#34;decrement number: \u0026#34; \u0026lt;\u0026lt; m_value \u0026lt;\u0026lt; \u0026#34;, theadID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::milliseconds(500)); } } atomic_int m_value = 0; }; int main() { Counter c; auto increment = bind(\u0026amp;Counter::increment, \u0026amp;c); auto decrement = bind(\u0026amp;Counter::decrement, \u0026amp;c); thread t1(increment); thread t2(decrement); t1.join(); t2.join(); return 0; } 通过代码的对比可以看出，使用了原子变量之后，就不需要再定义互斥量了，在使用上更加简便，并且这两种方式都能保证在多线程操作过程中数据的正确性，不会出现数据的混乱。\n原子类型atomic\u0026lt;T\u0026gt; 可以封装原始数据最终得到一个原子变量对象，操作原子对象能够得到和操作原始数据一样的效果，当然也可以通过store()和load()来读写原子对象内部的原始数据。\n","date":"2025-04-04T00:00:00Z","image":"https://serennan.github.io/post/cpp-atomic/cover.png","permalink":"https://serennan.github.io/post/cpp-atomic/","title":"【C++11】线程同步之原子变量"},{"content":"条件变量 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n条件变量是C++11提供的另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合起来使用，C++11提供了两种条件变量：\ncondition_variable：需要配合std::unique_lock\u0026lt;std::mutex\u0026gt;进行wait操作，也就是阻塞线程的操作。\ncondition_variable_any：可以和任意带有lock()、unlock()语义的mutex搭配使用，也就是说有四种：\nstd::mutex：独占的非递归互斥锁 std::timed_mutex：带超时的独占非递归互斥锁 std::recursive_mutex：不带超时功能的递归互斥锁 std::recursive_timed_mutex：带超时的递归互斥锁 条件变量通常用于生产者和消费者模型，大致使用过程如下：\n拥有条件变量的线程获取互斥量\n循环检查某个条件，如果条件不满足阻塞当前线程，否则线程继续向下执行\n产品的数量达到上限，生产者阻塞，否则生产者一直生产。。。 产品的数量为零，消费者阻塞，否则消费者一直消费。。。 条件满足之后，可以调用notify_one()或者notify_all()唤醒一个或者所有被阻塞的线程\n由消费者唤醒被阻塞的生产者，生产者解除阻塞继续生产。。。 由生产者唤醒被阻塞的消费者，消费者解除阻塞继续消费。。。 1. condition_variable 1.1 成员函数 condition_variable的成员函数主要分为两部分：线程等待（阻塞）函数 和 线程通知（唤醒）函数，这些函数被定义于头文件 \u0026lt;condition_variable\u0026gt;。\n等待函数\n调用wait()函数的线程会被阻塞\n1 2 3 void wait (unique_lock\u0026amp; lck); template void wait (unique_lock\u0026amp; lck, Predicate pred); 函数①：调用该函数的线程直接被阻塞 函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数 该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数 表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行 独占的互斥锁对象不能直接传递给wait()函数，需要通过模板类unique_lock进行二次处理。 如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行。 wait_for()函数和wait()的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。\n1 2 3 4 5 template \u0026lt;class Rep, class Period\u0026gt; cv_status wait_for (unique_lock\u0026amp; lck, const chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; rel_time); template \u0026lt;class Rep, class Period, class Predicate\u0026gt; bool wait_for(unique_lock\u0026amp; lck, const chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; rel_time, Predicate pred); wait_until()函数和wait_for()的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。\n1 2 3 4 5 template \u0026lt;class Clock, class Duration\u0026gt; cv_status wait_until (unique_lock\u0026amp; lck, const chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; abs_time); template \u0026lt;class Clock, class Duration, class Predicate\u0026gt; bool wait_until (unique_lock\u0026amp; lck, const chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; abs_time, Predicate pred); 通知函数\n1 2 void notify_one() noexcept; void notify_all() noexcept; notify_one()：唤醒一个被当前条件变量阻塞的线程 notify_all()：唤醒全部被当前条件变量阻塞的线程 1.2 生产者和消费者模型 我们可以使用条件变量来实现一个同步队列，这个队列作为生产者线程和消费者线程的共享资源，示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; class SyncQueue { public: SyncQueue(int maxSize) : m_maxSize(maxSize) {} void put(const int\u0026amp; x) { unique_lock\u0026lt;mutex\u0026gt; locker(m_mutex); while (m_queue.size() == m_maxSize) { cout \u0026lt;\u0026lt; \u0026#34;任务队列已满, 请耐心等待...\u0026#34; \u0026lt;\u0026lt; endl; m_notFull.wait(locker); } m_queue.push_back(x); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; 被生产\u0026#34; \u0026lt;\u0026lt; endl; m_notEmpty.notify_one(); } int take() { unique_lock\u0026lt;mutex\u0026gt; locker(m_mutex); while (m_queue.empty()) { cout \u0026lt;\u0026lt; \u0026#34;任务队列已空，请耐心等待。。。\u0026#34; \u0026lt;\u0026lt; endl; m_notEmpty.wait(locker); } int x = m_queue.front(); m_queue.pop_front(); m_notFull.notify_one(); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; 被消费\u0026#34; \u0026lt;\u0026lt; endl; return x; } bool empty() { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); return m_queue.empty(); } bool full() { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); return m_queue.size() == m_maxSize; } int size() { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); return m_queue.size(); } private: list\u0026lt;int\u0026gt; m_queue; // 存储队列数据 mutex m_mutex; // 互斥锁 condition_variable m_notEmpty; // 不为空的条件变量 condition_variable m_notFull; // 没有满的条件变量 int m_maxSize; // 任务队列的最大任务个数 }; int main() { SyncQueue taskQ(50); auto produce = bind(\u0026amp;SyncQueue::put, \u0026amp;taskQ, placeholders::_1); auto consume = bind(\u0026amp;SyncQueue::take, \u0026amp;taskQ); thread t1[3]; thread t2[3]; for (int i = 0; i \u0026lt; 3; ++i) { t1[i] = thread(produce, i+100); t2[i] = thread(consume); } for (int i = 0; i \u0026lt; 3; ++i) { t1[i].join(); t2[i].join(); } return 0; } 条件变量condition_variable类的wait()还有一个重载的方法，可以接受一个条件，这个条件也可以是一个返回值为布尔类型的函数，条件变量会先检查判断这个条件是否满足，如果满足条件（布尔值为true），则当前线程重新获得互斥锁的所有权，结束阻塞，继续向下执行；如果不满足条件（布尔值为false），当前线程会释放互斥锁（解锁）同时被阻塞，等待被唤醒。\n上面示例程序中的put()、take()函数可以做如下修改：\nput()函数 1 2 3 4 5 6 7 8 9 10 11 12 13 void put(const int\u0026amp; x) { unique_lock\u0026lt;mutex\u0026gt; locker(m_mutex); m_notFull.wait(locker, [this] { return m_queue.size() != m_maxSize; }); m_queue.push_back(x); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; 被生产\u0026#34; \u0026lt;\u0026lt; endl; m_notEmpty.notify_one(); } take()函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int take() { unique_lock\u0026lt;mutex\u0026gt; locker(m_mutex); m_notEmpty.wait(locker, [this] { return !m_queue.empty(); }); int x = m_queue.front(); m_queue.pop_front(); m_notFull.notify_one(); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; 被消费\u0026#34; \u0026lt;\u0026lt; endl; return x; } 修改之后可以发现，程序变得更加精简了，而且执行效率更高了，因为在这两个函数中的while循环被删掉了，但是最终的效果是一样的，推荐使用这种方式的wait()进行线程的阻塞。\n2. condition_variable_any 2.1 成员函数 condition_variable_any的成员函数也是分为两部分：线程等待（阻塞）函数和线程通知（唤醒）函数，这些函数被定义于头文件 \u0026lt;condition_variable\u0026gt;。\n等待函数 1 2 3 4 5 template \u0026lt;class Lock\u0026gt; void wait (Lock\u0026amp; lck); template \u0026lt;class Lock, class Predicate\u0026gt; void wait (Lock\u0026amp; lck, Predicate pred); 函数①：调用该函数的线程直接被阻塞 函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数 该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数 表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行 可以直接传递给wait()函数的互斥锁类型有四种，分别是： std::mutex、std::timed_mutex、std::recursive_mutex、std::recursive_timed_mutex 如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行。 wait_for()函数和wait()的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。\n1 2 3 4 5 template \u0026lt;class Lock, class Rep, class Period\u0026gt; cv_status wait_for (Lock\u0026amp; lck, const chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; rel_time); template \u0026lt;class Lock, class Rep, class Period, class Predicate\u0026gt; bool wait_for (Lock\u0026amp; lck, const chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; rel_time, Predicate pred); wait_until()函数和wait_for()的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。\n1 2 3 4 5 template \u0026lt;class Lock, class Clock, class Duration\u0026gt; cv_status wait_until (Lock\u0026amp; lck, const chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; abs_time); template \u0026lt;class Lock, class Clock, class Duration, class Predicate\u0026gt; bool wait_until (Lock\u0026amp; lck, const chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; abs_time, Predicate pred); 通知函数 1 2 void notify_one() noexcept; void notify_all() noexcept; notify_one()：唤醒一个被当前条件变量阻塞的线程 notify_all()：唤醒全部被当前条件变量阻塞的线程 2.2 生产者和消费者模型 使用条件变量condition_variable_any同样可以实现上面的生产者和消费者的例子，代码只有个别细节上有所不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; class SyncQueue { public: SyncQueue(int maxSize) : m_maxSize(maxSize) {} void put(const int\u0026amp; x) { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); m_notFull.wait(m_mutex, [this] { return m_queue.size() != m_maxSize; }); m_queue.push_back(x); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; 被生产\u0026#34; \u0026lt;\u0026lt; endl; m_notEmpty.notify_one(); } int take() { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); m_notEmpty.wait(m_mutex, [this] { return !m_queue.empty(); }); int x = m_queue.front(); m_queue.pop_front(); m_notFull.notify_one(); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; 被消费\u0026#34; \u0026lt;\u0026lt; endl; return x; } bool empty() { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); return m_queue.empty(); } bool full() { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); return m_queue.size() == m_maxSize; } int size() { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); return m_queue.size(); } private: list\u0026lt;int\u0026gt; m_queue; mutex m_mutex; condition_variable_any m_notEmpty; condition_variable_any m_notFull; int m_maxSize; }; int main() { SyncQueue taskQ(50); auto produce = bind(\u0026amp;SyncQueue::put, \u0026amp;taskQ, placeholders::_1); auto consume = bind(\u0026amp;SyncQueue::take, \u0026amp;taskQ); thread t1[3]; thread t2[3]; for (int i = 0; i \u0026lt; 3; ++i) { t1[i] = thread(produce, i + 100); t2[i] = thread(consume); } for (int i = 0; i \u0026lt; 3; ++i) { t1[i].join(); t2[i].join(); } return 0; } 总结：\n以上介绍的两种条件变量各自有各自的特点，condition_variable 配合 unique_lock 使用更灵活一些，可以在任何时候自由地释放互斥锁，而 condition_variable_any 如果和 lock_guard 一起使用必须要等到其生命周期结束才能将互斥锁释放。但是，condition_variable_any 可以和多种互斥锁配合使用，应用场景也更广，而 condition_variable 只能和独占的非递归互斥锁（mutex）配合使用，有一定的局限性。\n","date":"2025-04-03T00:00:00Z","image":"https://serennan.github.io/post/cpp-condition_variable/cover.png","permalink":"https://serennan.github.io/post/cpp-condition_variable/","title":"【C++11】线程同步之条件变量"},{"content":"C++线程同步之互斥锁 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n进行多线程编程，如果多个线程需要对同一块内存进行操作，比如：同时读、同时写、同时读写对于后两种情况来说，如果不做任何的人为干涉就会出现各种各样的错误数据。这是因为线程在运行的时候需要先得到CPU时间片，时间片用完之后需要放弃已获得的CPU资源，就这样线程频繁地在就绪态和运行态之间切换，更复杂一点还可以在就绪态、运行态、挂起态之间切换，这样就会导致线程的执行顺序并不是有序的，而是随机的混乱的。\n解决多线程数据混乱的方案就是进行线程同步，最常用的就是互斥锁，在C++11中一共提供了四种互斥锁：\nstd::mutex：独占的互斥锁，不能递归使用 std::timed_mutex：带超时的独占互斥锁，不能递归使用 std::recursive_mutex：递归互斥锁，不带超时功能 std::recursive_timed_mutex：带超时的递归互斥锁 1. std::mutex 不论是在C还是C++中，进行线程同步的处理流程基本上是一致的，C++的mutex类提供了相关的API函数：\n1.1 成员函数 lock()函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用，函数原型如下：\n1 void lock(); 独占互斥锁对象有两种状态：锁定和未锁定。如果互斥锁是打开的，调用lock()函数的线程会得到互斥锁的所有权，并将其上锁，其它线程再调用该函数的时候由于得不到互斥锁的所有权，就会被lock()函数阻塞。当拥有互斥锁所有权的线程将互斥锁解锁，此时被lock()阻塞的线程解除阻塞，抢到互斥锁所有权的线程加锁并继续运行，没抢到互斥锁所有权的线程继续阻塞。\n除了使用lock()还可以使用try_lock()获取互斥锁的所有权并对互斥锁加锁，函数原型如下：\n1 bool try_lock(); 二者的区别在于try_lock()不会阻塞线程，lock()会阻塞线程：\n如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回true 如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回false 当互斥锁被锁定之后可以通过unlock()进行解锁，但是需要注意的是只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁，其它线程是没有权限做这件事情的。该函数的函数原型如下：\n1 void unlock(); 通过介绍以上三个函数，使用互斥锁进行线程同步的大致思路差不多就能搞清楚了，主要分为以下几步：\n找到多个线程操作的共享资源（全局变量、堆内存、类成员变量等），也可以称之为临界资源 找到和共享资源有关的上下文代码，也就是临界区 在临界区的上边调用互斥锁类的lock()方法 在临界区的下边调用互斥锁的unlock()方法 1 2 3 4 g_num_mutex.lock(); ++g_num; cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; endl; g_num_mutex.unlock(); 比如这段代码，共享资源是g_num，那么临界区主要就是和g_num有关的代码。\n线程同步的目的是让多线程按照顺序依次执行临界区代码，这样做线程对共享资源的访问就从并行访问变为了线性访问，访问效率降低了，但是保证了数据的正确性。\n当线程对互斥锁对象加锁，并且执行完临界区代码之后，一定要使用这个线程对互斥锁解锁，否则最终会造成线程的死锁。死锁之后当前应用程序中的所有线程都会被阻塞，并且阻塞无法解除，应用程序也无法继续运行。\n1.2 线程同步 举个栗子，我们让两个线程共同操作同一个全局变量，二者交替数数，将数值存储到这个全局变量里边并打印出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; int g_num = 0; mutex g_num_mutex; void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { g_num_mutex.lock(); ++g_num; cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; endl; g_num_mutex.unlock(); this_thread::sleep_for(chrono::seconds(1)); } } int main() { thread t1(slow_increment, 0); thread t2(slow_increment, 1); t1.join(); t2.join(); } 在上面的示例程序中，两个子线程执行的任务的一样的（其实也可以不一样，不同的任务中也可以对共享资源进行读写操作），在任务函数中把与全局变量相关的代码加了锁，两个线程只能顺序访问这部分代码（如果不进行线程同步打印出的数据是混乱且无序的）。另外需要强调一点：\n在所有线程的任务函数执行完毕之前，互斥锁对象是不能被析构的，一定要在程序中保证这个对象的可用性。 互斥锁的个数和共享资源的个数相等，也就是说每一个共享资源都应该对应一个互斥锁对象。互斥锁对象的个数和线程的个数没有关系。 2. std::lock_guard lock_guard是C++11新增的一个模板类，使用这个类，可以简化互斥锁lock()和unlock()的写法，同时也更安全。这个模板类的定义和常用的构造函数原型如下：\n1 2 3 4 template\u0026lt; class Mutex \u0026gt; class lock_guard; explicit lock_guard( mutex_type\u0026amp; m ); lock_guard在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。lock_guard使用了RAII技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。\n使用lock_guard对上面的例子进行修改，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void slow_increment(int id) { for (int i = 0; i \u0026lt; 3; ++i) { { lock_guard\u0026lt;mutex\u0026gt; lock(g_num_mutex); ++g_num; cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; g_num \u0026lt;\u0026lt; endl; } this_thread::sleep_for(chrono::seconds(1)); } } 通过修改发现代码被精简了，而且不用担心因为忘记解锁而造成程序的死锁，但是这种方式也要注意，在上面的示例程序中如果不加大括号，整个for循环的体都会被当做临界区，导致程序效率低，所以这里可以加一个大括号来指定临界区。\n3. std::recursive_mutex 递归互斥锁std::recursive_mutex允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题，在下面的例子中使用独占非递归互斥量会发生死锁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; struct Calculate { Calculate() : m_i(6) {} void mul(int x) { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); m_i *= x; } void div(int x) { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); m_i /= x; } void both(int x, int y) { lock_guard\u0026lt;mutex\u0026gt; locker(m_mutex); mul(x); div(y); } int m_i; mutex m_mutex; }; int main() { Calculate cal; cal.both(6, 3); return 0; } 上面的程序中执行了cal.both(6, 3);调用之后，程序就会发生死锁，在both()中已经对互斥锁加锁了，继续调用mul()函数，已经得到互斥锁所有权的线程再次获取这个互斥锁的所有权就会造成死锁（在C++中程序会异常退出，使用C库函数会导致这个互斥锁永远无法被解锁，最终阻塞所有的线程）。要解决这个死锁的问题，一个简单的办法就是使用递归互斥锁std::recursive_mutex，它允许一个线程多次获得互斥锁的所有权。修改之后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; struct Calculate { Calculate() : m_i(6) {} void mul(int x) { lock_guard\u0026lt;recursive_mutex\u0026gt; locker(m_mutex); m_i *= x; } void div(int x) { lock_guard\u0026lt;recursive_mutex\u0026gt; locker(m_mutex); m_i /= x; } void both(int x, int y) { lock_guard\u0026lt;recursive_mutex\u0026gt; locker(m_mutex); mul(x); div(y); } int m_i; recursive_mutex m_mutex; }; int main() { Calculate cal; cal.both(6, 3); cout \u0026lt;\u0026lt; \u0026#34;cal.m_i = \u0026#34; \u0026lt;\u0026lt; cal.m_i \u0026lt;\u0026lt; endl; return 0; } 虽然递归互斥锁可以解决同一个互斥锁频繁获取互斥锁资源的问题，但是还是建议少用，主要原因如下：\n使用递归互斥锁的场景往往都是可以简化的，使用递归互斥锁很容易放纵复杂逻辑的产生，从而导致bug的产生 递归互斥锁比非递归互斥锁效率要低一些。 递归互斥锁虽然允许同一个线程多次获得同一个互斥锁的所有权，但最大次数并未具体说明，一旦超过一定的次数，就会抛出std::system错误。 4. std::timed_mutex std::timed_mutex是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。\nstd::timed_mutex比std::_mutex多了两个成员函数：try_lock_for()和try_lock_until()：\n1 2 3 4 5 6 7 8 9 void lock(); bool try_lock(); void unlock(); template \u0026lt;class Rep, class Period\u0026gt; bool try_lock_for (const chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; rel_time); template \u0026lt;class Clock, class Duration\u0026gt; bool try_lock_until (const chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; abs_time); try_lock_for函数是当线程获取不到互斥锁资源的时候，让线程阻塞一定的时间长度 try_lock_until函数是当线程获取不到互斥锁资源的时候，让线程阻塞到某一个指定的时间点 关于两个函数的返回值：当得到互斥锁的所有权之后，函数会马上解除阻塞，返回true，如果阻塞的时长用完或者到达指定的时间点之后，函数也会解除阻塞，返回false 下面的示例程序中为大家演示了std::timed_mutex的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; timed_mutex g_mutex; void work() { chrono::seconds timeout(1); while (true) { if (g_mutex.try_lock_for(timeout)) { cout \u0026lt;\u0026lt; \u0026#34;当前线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;, 得到互斥锁所有权...\u0026#34; \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::seconds(10)); g_mutex.unlock(); break; } else { cout \u0026lt;\u0026lt; \u0026#34;当前线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;, 没有得到互斥锁所有权...\u0026#34; \u0026lt;\u0026lt; endl; this_thread::sleep_for(chrono::milliseconds(50)); } } } int main() { thread t1(work); thread t2(work); t1.join(); t2.join(); return 0; } 示例代码输出的结果：\n1 2 3 4 5 6 7 8 9 10 11 当前线程ID: 125776, 得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 没有得到互斥锁所有权... 当前线程ID: 112324, 得到互斥锁所有权... 在上面的例子中，通过一个while循环不停的去获取超时互斥锁的所有权，如果得不到就阻塞1秒钟，1秒之后如果还是得不到阻塞50毫秒，然后再次继续尝试，直到获得互斥锁的所有权，跳出循环体。\n关于递归超时互斥锁std::recursive_timed_mutex的使用方式和std::timed_mutex是一样的，只不过它可以允许一个线程多次获得互斥锁所有权，而std::timed_mutex只允许线程获取一次互斥锁所有权。另外，递归超时互斥锁std::recursive_timed_mutex也拥有和std::recursive_mutex一样的弊端，不建议频繁使用。\n","date":"2025-04-02T00:00:00Z","image":"https://serennan.github.io/post/cpp-mutex/cover.png","permalink":"https://serennan.github.io/post/cpp-mutex/","title":"【C++11】线程同步之互斥锁"},{"content":"call_once 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n在某些特定情况下，某些函数只能在多线程环境下调用一次，比如：要初始化某个对象，而这个对象只能被初始化一次，就可以使用std::call_once()来保证函数在多线程环境下只能被调用一次。使用call_once()的时候，需要一个once_flag作为call_once()的传入参数，该函数的原型如下：\n1 2 template\u0026lt; class Callable, class... Args \u0026gt; void call_once( std::once_flag\u0026amp; flag, Callable\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); flag：once_flag类型的对象，要保证这个对象能够被多个线程同时访问到 f：回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数 args：作为实参传递给回调函数 多线程操作过程中，std::call_once()内部的回调函数只会被执行一次，示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; using namespace std; once_flag g_flag; void do_once(int a, string b) { cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, age: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void do_something(int age, string name) { static int num = 1; call_once(g_flag, do_once, 19, \u0026#34;luffy\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;do_something() function num = \u0026#34; \u0026lt;\u0026lt; num++ \u0026lt;\u0026lt; endl; } int main() { thread t1(do_something, 20, \u0026#34;ace\u0026#34;); thread t2(do_something, 20, \u0026#34;sabo\u0026#34;); thread t3(do_something, 19, \u0026#34;luffy\u0026#34;); t1.join(); t2.join(); t3.join(); return 0; } 示例程序输出的结果：\n1 2 3 4 name: luffy, age: 19 do_something() function num = 1 do_something() function num = 2 do_something() function num = 3 通过输出的结果可以看到，虽然运行的三个线程中都执行了任务函数do_something()，但是call_once()中指定的回调函数只被执行了一次，我们的目的也达到了。\n","date":"2025-04-01T00:00:00Z","image":"https://serennan.github.io/post/cpp-callonce/cover.png","permalink":"https://serennan.github.io/post/cpp-callonce/","title":"【C++11】call_once"},{"content":"C++11线程的使用 个人学习笔记，参照大丙老师的博客：爱编程的大丙\nC++11之前，C++语言没有对并发编程提供语言级别的支持，这使得我们在编写可移植的并发程序时，存在诸多的不便。现在C++11中增加了线程以及线程相关的类，很方便地支持了并发编程，使得编写的多线程程序的可移植性得到了很大的提高。\nC++11中提供的线程类叫做std::thread，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。我们首先来了解一下这个类提供的一些常用API：\n1. 构造函数 1 2 3 4 5 thread() noexcept; thread( thread\u0026amp;\u0026amp; other ) noexcept; template\u0026lt; class Function, class... Args \u0026gt; explicit thread( Function\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); thread( const thread\u0026amp; ) = delete; 构造函数①：默认构造函数，构造一个线程对象，在这个线程中不执行任何处理动作。 构造函数②：移动构造函数，将 other 的线程所有权转移给新的thread 对象。之后 other 不再表示执行线程。 构造函数③：创建线程对象，并在该线程中执行函数f中的业务逻辑，args是要传递给函数f的参数。 任务函数f的可选类型有很多，具体如下： 普通函数，类成员函数，匿名函数，仿函数（这些都是可调用对象类型） 可以是可调用对象包装器类型，也可以是使用绑定器绑定之后得到的类型（仿函数） 构造函数④：使用=delete显示删除拷贝构造, 不允许线程对象之间的拷贝。 2. 公共成员函数 2.1 get_id() 应用程序启动之后默认只有一个线程，这个线程一般称之为主线程或父线程，通过线程类创建出的线程一般称之为子线程，每个被创建出的线程实例都对应一个线程ID，这个ID是唯一的，可以通过这个ID来区分和识别各个已经存在的线程实例，这个获取线程ID的函数叫做get_id()，函数原型如下：\n1 std::thread::id get_id() const noexcept; 示例程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void func(int num, string str) { for (int i = 0; i \u0026lt; 10; ++i) { cout \u0026lt;\u0026lt; \u0026#34;子线程: i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;num: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34;, str: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } } void func1() { for (int i = 0; i \u0026lt; 10; ++i) { cout \u0026lt;\u0026lt; \u0026#34;子线程: i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程的线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; thread t(func, 520, \u0026#34;i love you\u0026#34;); thread t1(func1); cout \u0026lt;\u0026lt; \u0026#34;线程t 的线程ID: \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程t1的线程ID: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; endl; } thread t(func, 520, \u0026quot;i love you\u0026quot;);：创建了子线程对象t，func()函数会在这个子线程中运行。 func()是一个回调函数，线程启动之后就会执行这个任务函数，程序员只需要实现即可。 func()的参数是通过thread的参数进行传递的，520,i love you都是调用func()需要的实参。 线程类的构造函数③是一个变参函数，因此无需担心线程任务函数的参数个数问题。 任务函数func()一般返回值指定为void，因为子线程在调用这个函数的时候不会处理其返回值。 thread t1(func1);：子线程对象t1中的任务函数func1()，没有参数，因此在线程构造函数中就无需指定了。 通过线程对象调用get_id()就可以知道这个子线程的线程ID了，t.get_id()，t1.get_id()。 在上面的示例程序中有一个bug，在主线程中依次创建出两个子线程，打印两个子线程的线程ID，最后主线程执行完毕就退出了（主线程就是执行main()函数的那个线程）。默认情况下，主线程销毁时会将与其关联的两个子线程也一并销毁，但是这时有可能子线程中的任务还没有执行完毕，最后也就得不到我们想要的结果了。\n当启动了一个线程（创建了一个thread对象）之后，在这个线程结束的时候（std::terminate()），我们如何去回收线程所使用的资源呢？thread库给我们两种选择：\n加入式（join()） 分离式（detach()） 另外，我们必须要在线程对象销毁之前在二者之间作出选择，否则程序运行期间就会有bug产生。\n2.2 join() join()字面意思是连接一个线程，意味着主动地等待线程的终止（线程阻塞）。在某个线程中通过子线程对象调用join()函数，调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。\n再次强调，我们一定要搞清楚这个函数阻塞的是哪一个线程，函数在哪个线程中被执行，那么函数就阻塞哪个线程。 该函数的函数原型如下：\n1 void join(); 有了这样一个线程阻塞函数之后，就可以解决在上面测试程序中的bug了，如果要阻塞主线程的执行，只需要在主线程中通过子线程对象调用这个方法即可，当调用这个方法的子线程对象中的任务函数执行完毕之后，主线程的阻塞也就随之解除了。修改之后的示例代码如下：\n1 2 3 4 5 6 7 8 9 int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程的线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; thread t(func, 520, \u0026#34;i love you\u0026#34;); thread t1(func1); cout \u0026lt;\u0026lt; \u0026#34;线程t 的线程ID: \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程t1的线程ID: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; endl; t.join(); t1.join(); } 当主线程运行到第八行t.join();，根据子线程对象t的任务函数func()的执行情况，主线程会做如下处理：\n如果任务函数func()还没执行完毕，主线程阻塞，直到任务执行完毕，主线程解除阻塞，继续向下运行。 如果任务函数func()已经执行完毕，主线程不会阻塞，继续向下运行。 同样，第9行的代码亦如此。\n为了更好的理解join()的使用，再来给大家举一个例子，场景如下：\n程序中一共有三个线程，其中两个子线程负责分段下载同一个文件，下载完毕之后，由主线程对这个文件进行下一步处理，那么示例程序就应该这么写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void download1() { // 模拟下载, 总共耗时500ms，阻塞线程500ms this_thread::sleep_for(chrono::milliseconds(500)); cout \u0026lt;\u0026lt; \u0026#34;子线程1: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;, 找到历史正文....\u0026#34; \u0026lt;\u0026lt; endl; } void download2() { // 模拟下载, 总共耗时300ms，阻塞线程300ms this_thread::sleep_for(chrono::milliseconds(300)); cout \u0026lt;\u0026lt; \u0026#34;子线程2: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;, 找到历史正文....\u0026#34; \u0026lt;\u0026lt; endl; } void doSomething() { cout \u0026lt;\u0026lt; \u0026#34;集齐历史正文, 呼叫罗宾....\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;历史正文解析中....\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;起航，前往拉夫德尔....\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;找到OnePiece, 成为海贼王, 哈哈哈!!!\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;若干年后，草帽全员卒....\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;大海贼时代再次被开启....\u0026#34; \u0026lt;\u0026lt; endl; } int main() { thread t1(download1); thread t2(download2); // 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行 t1.join(); t2.join(); doSomething(); } 示例程序输出的结果：\n1 2 3 4 5 6 7 8 子线程2: 72540, 找到历史正文.... 子线程1: 79776, 找到历史正文.... 集齐历史正文, 呼叫罗宾.... 历史正文解析中.... 起航，前往拉夫德尔.... 找到OnePiece, 成为海贼王, 哈哈哈!!! 若干年后，草帽全员卒.... 大海贼时代再次被开启.... 在上面示例程序中最核心的处理是在主线程调用doSomething();之前在第35、36行通过子线程对象调用了join()方法，这样就能够保证两个子线程的任务都执行完毕了，也就是文件内容已经全部下载完成，主线程再对文件进行后续处理，如果子线程的文件没有下载完毕，主线程就去处理文件，很显然从逻辑上讲是有问题的。\n2.3 detach() detach()函数的作用是进行线程分离，分离主线程和创建出的子线程。在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。（其实就是孩子翅膀硬了，和家里断绝关系，自己外出闯荡了，如果家里被诛九族还是会受牵连）。该函数函数原型如下：\n1 void detach(); 线程分离函数没有参数也没有返回值，只需要在线程成功之后，通过线程对象调用该函数即可，继续将上面的测试程序修改一下：\n1 2 3 4 5 6 7 8 9 10 11 int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程的线程ID: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; thread t(func, 520, \u0026#34;i love you\u0026#34;); thread t1(func1); cout \u0026lt;\u0026lt; \u0026#34;线程t 的线程ID: \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;线程t1的线程ID: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; endl; t.detach(); t1.detach(); this_thread::sleep_for(chrono::seconds(5)); } 注意事项：线程分离函数detach()不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过join()阻塞主线程等待子线程中的任务执行完毕，或者调用get_id()获取子线程的线程ID。有利就有弊，鱼和熊掌不可兼得，建议使用join()。\n2.5 joinable() joinable()函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：\n返回值为true：主线程和子线程之间有关联（连接）关系 返回值为false：主线程和子线程之间没有关联（连接）关系 1 bool joinable() const noexcept; 示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void foo() { this_thread::sleep_for(std::chrono::seconds(1)); } int main() { thread t; cout \u0026lt;\u0026lt; \u0026#34;before starting, joinable: \u0026#34; \u0026lt;\u0026lt; t.joinable() \u0026lt;\u0026lt; endl; t = thread(foo); cout \u0026lt;\u0026lt; \u0026#34;after starting, joinable: \u0026#34; \u0026lt;\u0026lt; t.joinable() \u0026lt;\u0026lt; endl; t.join(); cout \u0026lt;\u0026lt; \u0026#34;after joining, joinable: \u0026#34; \u0026lt;\u0026lt; t.joinable() \u0026lt;\u0026lt; endl; thread t1(foo); cout \u0026lt;\u0026lt; \u0026#34;after starting, joinable: \u0026#34; \u0026lt;\u0026lt; t1.joinable() \u0026lt;\u0026lt; endl; t1.detach(); cout \u0026lt;\u0026lt; \u0026#34;after detaching, joinable: \u0026#34; \u0026lt;\u0026lt; t1.joinable() \u0026lt;\u0026lt; endl; } 示例代码打印的结果如下：\n1 2 3 4 5 before starting, joinable: 0 after starting, joinable: 1 after joining, joinable: 0 after starting, joinable: 1 after detaching, joinable: 0 基于示例代码打印的结果可以得到以下结论：\n在创建的子线程对象的时候，如果没有指定任务函数，那么子线程不会启动，主线程和这个子线程也不会进行连接 在创建的子线程对象的时候，如果指定了任务函数，子线程启动并执行任务，主线程和这个子线程自动连接成功 子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false 在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。 2.6 operator= 线程中的资源是不能被复制的，因此通过=操作符进行赋值操作最终并不会得到两个完全相同的对象。\n1 2 3 4 // move (1)\tthread\u0026amp; operator= (thread\u0026amp;\u0026amp; other) noexcept; // copy [deleted] (2)\tthread\u0026amp; operator= (const other\u0026amp;) = delete; 通过以上=操作符的重载声明可以得知：\n如果other是一个右值，会进行资源所有权的转移 如果other不是右值，禁止拷贝，该函数被显示删除（=delete），不可用 3. 静态函数 thread线程类还提供了一个静态方法，用于获取当前计算机的CPU核心数，根据这个结果在程序中创建出数量相等的线程，每个线程独自占有一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的。\n1 static unsigned hardware_concurrency() noexcept; 示例代码如下：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; int main() { int num = thread::hardware_concurrency(); cout \u0026lt;\u0026lt; \u0026#34;CPU number: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } ","date":"2025-03-31T00:00:00Z","image":"https://serennan.github.io/post/cpp-thread/cover.png","permalink":"https://serennan.github.io/post/cpp-thread/","title":"【C++11】线程的使用"},{"content":"命名空间-this_thread 个人学习笔记，参照大丙老师的博客：爱编程的大丙\n在C++11中不仅添加了线程类，还添加了一个关于线程的命名空间std::this_thread，在这个命名空间中提供了四个公共的成员函数，通过这些成员函数就可以对当前线程进行相关的操作了。\n1. get_id() 调用命名空间std::this_thread中的get_id()方法可以得到当前线程的线程ID，函数原型如下：\n1 thread::id get_id() noexcept; 关于函数使用对应的示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; void func() { cout \u0026lt;\u0026lt; \u0026#34;子线程: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;主线程: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; endl; thread t(func); t.join(); } 程序启动，开始执行main()函数，此时只有一个线程也就是主线程。当创建了子线程对象t之后，指定的函数func()会在子线程中执行，这时通过调用this_thread::get_id()就可以得到当前线程的线程ID了。\n2. sleep_for() 同样地，线程被创建后也有这五种状态：创建态、就绪态、运行态、阻塞态(挂起态)、退出态(终止态)，关于状态之间的转换是一样的。\n线程和进程的执行有很多相似之处，在计算机中启动的多个线程都需要占用CPU资源，但是CPU的个数是有限的并且每个CPU在同一时间点不能同时处理多个任务。为了能够实现并发处理，多个线程都是分时复用CPU时间片，快速的交替处理各个线程中的任务。因此多个线程之间需要争抢CPU时间片，抢到了就执行，抢不到则无法执行（因为默认所有的线程优先级都相同，内核也会从中调度，不会出现某个线程永远抢不到CPU时间片的情况）。\n命名空间this_thread中提供了一个休眠函数sleep_for()，调用这个函数的线程会马上从运行态变成阻塞态并在这种状态下休眠一定的时长，因为阻塞态的线程已经让出了CPU资源，代码也不会被执行，所以线程休眠过程中对CPU来说没有任何负担。这个函数的函数原型如下，参数需要指定一个休眠时长，是一个时间段：\n1 2 template \u0026lt;class Rep, class Period\u0026gt; void sleep_for (const chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; rel_time); 示例程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void func() { for (int i = 0; i \u0026lt; 10; ++i) { this_thread::sleep_for(chrono::seconds(1)); cout \u0026lt;\u0026lt; \u0026#34;子线程: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;, i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } } int main() { thread t(func); t.join(); } 在func()函数的for循环中使用了this_thread::sleep_for(chrono::seconds(1));之后，每循环一次程序都会阻塞1秒钟，也就是说每隔1秒才会进行一次输出。需要注意的是：程序休眠完成之后，会从阻塞态重新变成就绪态，就绪态的线程需要再次争抢CPU时间片，抢到之后才会变成运行态，这时候程序才会继续向下运行。\n3. sleep_until() 命名空间this_thread中提供了另一个休眠函数sleep_until()，和sleep_for()不同的是它的参数类型不一样：\nsleep_until()：指定线程阻塞到某一个指定的时间点time_point类型，之后解除阻塞 sleep_for()：指定线程阻塞一定的时间长度duration类型，之后解除阻塞 该函数的函数原型如下：\n1 2 template \u0026lt;class Clock, class Duration\u0026gt; void sleep_until (const chrono::time_point\u0026lt;Clock,Duration\u0026gt;\u0026amp; abs_time); 示例程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; void func() { for (int i = 0; i \u0026lt; 10; ++i) { // 获取当前系统时间点 auto now = chrono::system_clock::now(); // 时间间隔为2s chrono::seconds sec(2); // 当前时间点之后休眠两秒 this_thread::sleep_until(now + sec); cout \u0026lt;\u0026lt; \u0026#34;子线程: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;, i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } } int main() { thread t(func); t.join(); } sleep_until()和sleep_for()函数的功能是一样的，只不过前者是基于时间点去阻塞线程，后者是基于时间段去阻塞线程，项目开发过程中根据实际情况选择最优的解决方案即可。\n4. yield() 命名空间this_thread中提供了一个非常绅士的函数yield()，在线程中调用这个函数之后，处于运行态的线程会主动让出自己已经抢到的CPU时间片，最终变为就绪态，这样其它的线程就有更大的概率能够抢到CPU时间片了。使用这个函数的时候需要注意一点，线程调用了yield()之后会主动放弃CPU资源，但是这个变为就绪态的线程会马上参与到下一轮CPU的抢夺战中，不排除它能继续抢到CPU时间片的情况，这是概率问题。\n1 void yield() noexcept; 函数对应的示例程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; using namespace std; void func() { for (int i = 0; i \u0026lt; 100000000000; ++i) { cout \u0026lt;\u0026lt; \u0026#34;子线程: \u0026#34; \u0026lt;\u0026lt; this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;, i = \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; this_thread::yield(); } } int main() { thread t(func); thread t1(func); t.join(); t1.join(); } 在上面的程序中，执行func()中的for循环会占用大量的时间，在极端情况下，如果当前线程占用CPU资源不释放就会导致其他线程中的任务无法被处理，或者该线程每次都能抢到CPU时间片，导致其他线程中的任务没有机会被执行。解决方案就是每执行一次循环，让该线程主动放弃CPU资源，重新和其他线程再次抢夺CPU时间片，如果其他线程抢到了CPU时间片就可以执行相应的任务了。\n结论:\nstd::this_thread::yield()的目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降。 std::this_thread::yield()是让当前线程主动放弃了当前自己抢到的CPU资源，但是在下一轮还会继续抢。 ","date":"2025-03-30T00:00:00Z","image":"https://serennan.github.io/post/cpp-this_thread/cover.png","permalink":"https://serennan.github.io/post/cpp-this_thread/","title":"【C++11】命名空间-this_thread"},{"content":"处理日期和时间的 chrono 库 个人学习笔记，参照大丙老师的博客：爱编程的大丙\nC++11中提供了日期和时间相关的库chrono，通过chrono库可以很方便地处理日期和时间，为程序的开发提供了便利。chrono库主要包含三种类型的类：时间间隔duration、时钟clocks、时间点time point。\n1. 时间间隔 duration 1.1 常用类成员 duration表示一段时间间隔，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。duration的原型如下：\n1 2 3 4 5 // 定义于头文件 \u0026lt;chrono\u0026gt; template\u0026lt; class Rep, class Period = std::ratio\u0026lt;1\u0026gt; \u0026gt; class duration; Rep：这是一个数值类型，表示时钟数（周期）的类型（默认为整形）。若 Rep 是浮点数，则 duration 能使用小数描述时钟周期的数目。\nPeriod：表示时钟的周期，它的原型如下：\n1 2 3 4 5 // 定义于头文件 \u0026lt;ratio\u0026gt; template\u0026lt; std::intmax_t Num, std::intmax_t Denom = 1 \u0026gt; class ratio; ratio 类表示每个时钟周期的秒数，其中第一个模板参数 Num 代表分子， Denom 代表分母，该分母值默认为 1 ，因此，ratio代表的是一个分子除以分母的数值，比如：ratio\u0026lt;2\u0026gt;代表一个时钟周期是2秒，ratio\u0026lt;60\u0026gt;代表一分钟，ratio\u0026lt;60x60\u0026gt;代表一个小时，ratio\u0026lt;60x60x24\u0026gt;代表一天。而ratio\u0026lt;1,1000\u0026gt;代表的是1/1000秒，也就是1毫秒，ratio\u0026lt;1,1000000\u0026gt;代表一微秒，ratio\u0026lt;1,1000000000\u0026gt;代表一纳秒。\n为了方便使用，在标准库中定义了一些常用的时间间隔，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于chrono命名空间下，定义如下：\n纳秒：std::chrono::nanoseconds\n微秒：std::chrono::microseconds\n毫秒：std::chrono::milliseconds\n秒： std::chrono::seconds\n分钟：std::chrono::minutes\n小时：std::chrono::hours\nduration类的构造函数原型如下：\n1 2 3 4 5 6 7 8 // 1. 拷贝构造函数 duration( const duration\u0026amp; ) = default; // 2. 通过指定时钟周期的类型来构造对象 template\u0026lt; class Rep2 \u0026gt; constexpr explicit duration( const Rep2\u0026amp; r ); // 3. 通过指定时钟周期类型，和时钟周期长度来构造对象 template\u0026lt; class Rep2, class Period2 \u0026gt; constexpr duration( const duration\u0026lt;Rep2,Period2\u0026gt;\u0026amp; d ); 为了更加方便的进行duration对象之间的操作，类内部进行了操作符重载。\nduration类还提供了获取时间间隔的时钟周期数的方法 count() ，函数原型如下：\n1 constexpr rep count() const; 1.2 类的使用 通过构造函数构造事件间隔对象示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { chrono::hours h(1); // 一小时 chrono::milliseconds ms{ 3 }; // 3 毫秒 chrono::duration\u0026lt;int, ratio\u0026lt;1000\u0026gt;\u0026gt; ks(3); // 3000 秒 // chrono::duration\u0026lt;int, ratio\u0026lt;1000\u0026gt;\u0026gt; d3(3.5); // error chrono::duration\u0026lt;double\u0026gt; dd(6.6); // 6.6 秒 // 使用小数表示时钟周期的次数 chrono::duration\u0026lt;double, std::ratio\u0026lt;1, 30\u0026gt;\u0026gt; hz(3.5); } h(1)时钟周期为1小时，共有1个时钟周期，所以h表示的时间间隔为1小时 ms(3)时钟周期为1毫秒，共有3个时钟周期，所以ms表示的时间间隔为3毫秒 ks(3)时钟周期为1000秒，一共有三个时钟周期，所以ks表示的时间间隔为3000秒 d3(3.5)时钟周期为1000秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误 dd(6.6)时钟周期为默认的1秒，共有6.6个时钟周期，所以dd表示的时间间隔为6.6秒 hz(3.5)时钟周期为1/30秒，共有3.5个时钟周期，所以hz表示的时间间隔为1/30*3.5秒 chrono库中根据duration类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（时钟周期 * 周期次数 = 总的时间间隔）。\n示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::chrono::milliseconds ms{3}; // 3 毫秒 std::chrono::microseconds us = 2*ms; // 6000 微秒 // 时间间隔周期为 1/30 秒 std::chrono::duration\u0026lt;double, std::ratio\u0026lt;1, 30\u0026gt;\u0026gt; hz(3.5); std::cout \u0026lt;\u0026lt; \u0026#34;3 ms duration has \u0026#34; \u0026lt;\u0026lt; ms.count() \u0026lt;\u0026lt; \u0026#34; ticks\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;6000 us duration has \u0026#34; \u0026lt;\u0026lt; us.count() \u0026lt;\u0026lt; \u0026#34; ticks\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;3.5 hz duration has \u0026#34; \u0026lt;\u0026lt; hz.count() \u0026lt;\u0026lt; \u0026#34; ticks\\n\u0026#34;; } 输出结果为：\n1 2 3 3 ms duration has 3 ticks 6000 us duration has 6000 ticks 3.5 hz duration has 3.5 ticks ms时间单位为毫秒，初始化操作ms{3}表示时间间隔为3毫秒，一共有3个时间周期，每个周期为1毫秒 us时间单位为微秒，初始化操作2*ms表示时间间隔为6000微秒，一共有6000个时间周期，每个周期为1微秒 hz时间单位为秒，初始化操作hz(3.5)表示时间间隔为1/30*3.5秒，一共有3.5个时间周期，每个周期为1/30秒 由于在duration类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; int main() { chrono::minutes t1(10); chrono::seconds t2(60); chrono::seconds t3 = t1 - t2; cout \u0026lt;\u0026lt; t3.count() \u0026lt;\u0026lt; \u0026#34; second\u0026#34; \u0026lt;\u0026lt; endl; } 程序输出的结果：\n1 540 second 在上面的测试程序中，t1代表10分钟，t2代表60秒，t3是t1减去t2，也就是60*10-60=540，这个540表示的时钟周期，每个时钟周期是1秒，因此两个时间间隔之间的差值为540秒。\n注意事项：duration的加减运算有一定的规则，当两个duration时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算，统一的规则如下：假设有ratio\u0026lt;x1,y1\u0026gt; 和 ratio\u0026lt;x2,y2\u0026gt;两个时钟周期，首先需要求出x1，x2的最大公约数X，然后求出y1，y2的最小公倍数Y，统一之后的时钟周期ratio为ratio\u0026lt;X,Y\u0026gt;。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; int main() { chrono::duration\u0026lt;double, ratio\u0026lt;9, 7\u0026gt;\u0026gt; d1(3); chrono::duration\u0026lt;double, ratio\u0026lt;6, 5\u0026gt;\u0026gt; d2(1); // d1 和 d2 统一之后的时钟周期 chrono::duration\u0026lt;double, ratio\u0026lt;3, 35\u0026gt;\u0026gt; d3 = d1 - d2; } 对于分子6,、9最大公约数为3，对于分母7、5最小公倍数为35，因此推导出的时钟周期为ratio\u0026lt;3,35\u0026gt;\n2. 时间点 time point chrono库中提供了一个表示时间点的类time_point，该类的定义如下：\n1 2 3 4 5 // 定义于头文件 \u0026lt;chrono\u0026gt; template\u0026lt; class Clock, class Duration = typename Clock::duration \u0026gt; class time_point; 它被实现成如同存储一个 Duration 类型的自 Clock 的纪元起始开始的时间间隔的值，通过这个类最终可以得到时间中的某一个时间点。\nClock：此时间点在此时钟上计量 Duration：用于计量从纪元起时间的 std::chrono::duration 类型 time_point类的构造函数原型如下：\n1 2 3 4 5 6 7 // 1. 构造一个以新纪元(epoch，即：1970.1.1)作为值的对象，需要和时钟类一起使用，不能单独使用该无参构造函数 time_point(); // 2. 构造一个对象，表示一个时间点，其中d的持续时间从epoch开始，需要和时钟类一起使用，不能单独使用该构造函数 explicit time_point( const duration\u0026amp; d ); // 3. 拷贝构造函数，构造与t相同时间点的对象，使用的时候需要指定模板参数 template\u0026lt; class Duration2 \u0026gt; time_point( const time_point\u0026lt;Clock,Duration2\u0026gt;\u0026amp; t ); 在这个类中除了构造函数还提供了另外一个time_since_epoch()函数，用来获得1970年1月1日到time_point对象中记录的时间经过的时间间隔（duration），函数原型如下：\n1 duration time_since_epoch() const; 除此之外，时间点time_point对象和时间段对象duration之间还支持直接进行算术运算（即加减运算）。\n由于该时间点类经常和下面要介绍的时钟类一起使用，所以在此先不举例，在时钟类的示例代码中会涉及到时间点类的使用，到此为止只需要搞明白时间点类的提供的这几个函数的作用就可以了。\n3. 时钟clocks chrono库中提供了获取当前的系统时间的时钟类，包含的时钟一共有三种：\nsystem_clock：系统的时钟，系统的时钟可以修改，甚至可以网络对时，因此使用系统时间计算时间差可能不准。 steady_clock：是固定的时钟，相当于秒表。开始计时后，时间只会增长并且不能修改，适合用于记录程序耗时 high_resolution_clock：和时钟类 steady_clock 是等价的（是它的别名） 在这些时钟类的内部有time_point、duration、Rep、Period等信息，基于这些信息来获取当前时间，以及实现time_t和time_point之间的相互转换。\n时钟类成员类型 描述 rep 表示时钟周期次数的有符号算术类型 period 表示时钟计次周期的 std::ratio 类型 duration 时间间隔，可以表示负时长 time_point 表示在当前时钟里边记录的时间点 在使用chrono提供的时钟类的时候，不需要创建类对象，直接调用类的静态方法就可以得到想要的时间了。\n3.1 system_clock system_clock 是一个系统范围的实时时钟。它提供了对当前时间点 time_point 的访问，将得到的时间点转换为 time_t 类型的时间对象，就可以基于这个时间对象获取当前的时间信息。 system_clock 的底层源码定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct system_clock { // wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime using rep = long long; using period = ratio\u0026lt;1, 10\u0026#39;000\u0026#39;000\u0026gt;; // 100 nanoseconds using duration = chrono::duration\u0026lt;rep, period\u0026gt;; using time_point = chrono::time_point\u0026lt;system_clock\u0026gt;; static constexpr bool is_steady = false; _NODISCARD static time_point now() noexcept { // get current time return time_point(duration(_Xtime_get_ticks())); } _NODISCARD static __time64_t to_time_t(const time_point \u0026amp;_Time) noexcept { // convert to __time64_t return duration_cast\u0026lt;seconds\u0026gt;(_Time.time_since_epoch()).count(); } _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept { // convert from __time64_t return time_point{seconds{_Tm}}; } }; 通过以上源码可以了解到在system_clock类中的一些细节信息：\nrep：时钟周期次数是通过整形来记录的long long period：一个时钟周期是100纳秒ratio\u0026lt;1, 10'000'000\u0026gt; duration：时间间隔为rep * period纳秒chrono::duration\u0026lt;rep, period\u0026gt; time_point：时间点通过系统时钟做了初始化chrono::time_point\u0026lt;system_clock\u0026gt;，里面记录了新纪元时间点 另外还可以看到system_clock类一共提供了三个静态成员函数：\n1 2 3 4 5 6 // 返回表示当前时间的时间点。 static std::chrono::time_point\u0026lt;std::chrono::system_clock\u0026gt; now() noexcept; // 将 time_point 时间点类型转换为 std::time_t 类型 static std::time_t to_time_t( const time_point\u0026amp; t ) noexcept; // 将 std::time_t 类型转换为 time_point 时间点类型 static std::chrono::system_clock::time_point from_time_t( std::time_t t ) noexcept; 例如，要获取当前的系统时间，并且需要将其以能够识别的方式打印出来，示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; using namespace std::chrono; int main() { // 新纪元1970.1.1时间 system_clock::time_point epoch; duration\u0026lt;int, ratio\u0026lt;60*60*24\u0026gt;\u0026gt; day(1); // 新纪元1970.1.1时间 + 1天 system_clock::time_point ppt(day); using dday = duration\u0026lt;int, ratio\u0026lt;60 * 60 * 24\u0026gt;\u0026gt;; // 新纪元1970.1.1时间 + 10天 time_point\u0026lt;system_clock, dday\u0026gt; t(dday(10)); // 系统当前时间 system_clock::time_point today = system_clock::now(); // 转换为time_t时间类型 time_t tm = system_clock::to_time_t(today); cout \u0026lt;\u0026lt; \u0026#34;今天的日期是: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm); time_t tm1 = system_clock::to_time_t(today+day); cout \u0026lt;\u0026lt; \u0026#34;明天的日期是: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm1); time_t tm2 = system_clock::to_time_t(epoch); cout \u0026lt;\u0026lt; \u0026#34;新纪元时间: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm2); time_t tm3 = system_clock::to_time_t(ppt); cout \u0026lt;\u0026lt; \u0026#34;新纪元时间+1天: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm3); time_t tm4 = system_clock::to_time_t(t); cout \u0026lt;\u0026lt; \u0026#34;新纪元时间+10天: \u0026#34; \u0026lt;\u0026lt; ctime(\u0026amp;tm4); } 示例代码打印的结果为：\n1 2 3 4 5 今天的日期是: Thu Apr 8 11:09:49 2021 明天的日期是: Fri Apr 9 11:09:49 2021 新纪元时间: Thu Jan 1 08:00:00 1970 新纪元时间+1天: Fri Jan 2 08:00:00 1970 新纪元时间+10天: Sun Jan 11 08:00:00 1970 3.2 steady_clock 如果我们通过时钟不是为了获取当前的系统时间，而是进行程序耗时的时长，此时使用system_clock就不合适了，因为这个时间可以跟随系统的设置发生变化。在C++11中提供的时钟类steady_clock相当于秒表，只要启动就会进行时间的累加，并且不能被修改，非常适合于进行耗时的统计。\nsteady_clock时钟类在底层源码中的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct steady_clock { // wraps QueryPerformanceCounter using rep = long long; using period = nano; using duration = nanoseconds; using time_point = chrono::time_point\u0026lt;steady_clock\u0026gt;; static constexpr bool is_steady = true; // get current time _NODISCARD static time_point now() noexcept { // doesn\u0026#39;t change after system boot const long long _Freq = _Query_perf_frequency(); const long long _Ctr = _Query_perf_counter(); static_assert(period::num == 1, \u0026#34;This assumes period::num == 1.\u0026#34;); const long long _Whole = (_Ctr / _Freq) * period::den; const long long _Part = (_Ctr % _Freq) * period::den / _Freq; return time_point(duration(_Whole + _Part)); } }; 通过以上源码可以了解到在steady_clock类中的一些细节信息：\nrep：时钟周期次数是通过整形来记录的long long period：一个时钟周期是1纳秒nano duration：时间间隔为1纳秒nanoseconds time_point：时间点通过系统时钟做了初始化chrono::time_point\u0026lt;steady_clock\u0026gt; 另外，在这个类中也提供了一个静态的now()方法，用于得到当前的时间点，函数原型如下：\n1 static std::chrono::time_point\u0026lt;std::chrono::steady_clock\u0026gt; now() noexcept; 假设要测试某一段程序的执行效率，可以计算它执行期间消耗的总时长，示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; using namespace std::chrono; int main() { steady_clock::time_point start = steady_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;print 1000 stars ....\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 1000; ++i) { cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; } cout \u0026lt;\u0026lt; endl; steady_clock::time_point last = steady_clock::now(); auto dt = last - start; cout \u0026lt;\u0026lt; \u0026#34;总共耗时: \u0026#34; \u0026lt;\u0026lt; dt.count() \u0026lt;\u0026lt; \u0026#34;纳秒\u0026#34; \u0026lt;\u0026lt; endl; } 3.3 high_resolution_clock high_resolution_clock提供的时钟精度比system_clock要高，它也是不可以修改的。在底层源码中，这个类其实是steady_clock类的别名：\n1 using high_resolution_clock = steady_clock; 因此high_resolution_clock的使用方式和steady_clock是一样的，在此就不再过多进行赘述了。\n4. 转换函数 4.1 duration_cast duration_cast是chrono库提供的一个模板函数，这个函数不属于duration类。通过这个函数可以对duration类对象内部的时钟周期Period，和周期次数的类型Rep进行修改，该函数原型如下：\n1 2 template \u0026lt;class ToDuration, class Rep, class Period\u0026gt; constexpr ToDuration duration_cast(const duration\u0026lt;Rep, Period\u0026gt;\u0026amp; dtn); 如果是对时钟周期进行转换：源时钟周期必须能够整除目的时钟周期（比如：小时到分钟）。 如果是对时钟周期次数的类型进行转换：低等类型默认可以向高等类型进行转换（比如：int 转 double）。 如果时钟周期和时钟周期次数类型都变了，根据第二点进行推导（也就是看时间周期次数类型）。 以上条件都不满足，那么就需要使用 duration_cast 进行显式转换。 我们可以修改一下上面测试程序执行时间的代码，在代码中修改duration对象的属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; using namespace std::chrono; void f() { cout \u0026lt;\u0026lt; \u0026#34;print 1000 stars ....\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 1000; ++i) { cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main() { auto t1 = steady_clock::now(); f(); auto t2 = steady_clock::now(); // 整数时长：时钟周期纳秒转毫秒，要求 duration_cast auto int_ms = duration_cast\u0026lt;milliseconds\u0026gt;(t2 - t1); // 小数时长：不要求 duration_cast duration\u0026lt;double, ratio\u0026lt;1, 1000\u0026gt;\u0026gt; fp_ms = t2 - t1; cout \u0026lt;\u0026lt; \u0026#34;f() took \u0026#34; \u0026lt;\u0026lt; fp_ms.count() \u0026lt;\u0026lt; \u0026#34; ms, \u0026#34; \u0026lt;\u0026lt; \u0026#34;or \u0026#34; \u0026lt;\u0026lt; int_ms.count() \u0026lt;\u0026lt; \u0026#34; whole milliseconds\\n\u0026#34;; } 示例代码输出的结果：\n1 2 3 print 1000 stars .... ****** f() took 40.2547 ms, or 40 whole milliseconds 4.2 time_point_cast time_point_cast也是chrono库提供的一个模板函数，这个函数不属于time_point类。函数的作用是对时间点进行转换，因为不同的时间点对象内部的时钟周期Period，和周期次数的类型Rep可能也是不同的，一般情况下它们之间可以进行隐式类型转换，也可以通过该函数显式地进行转换，函数原型如下：\n1 2 template \u0026lt;class ToDuration, class Clock, class Duration\u0026gt; time_point\u0026lt;Clock, ToDuration\u0026gt; time_point_cast(const time_point\u0026lt;Clock, Duration\u0026gt;\u0026amp; t); 关于函数的使用，示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 using Clock = chrono::system_clock; template \u0026lt;typename Duration\u0026gt;using TimePoint = time_point\u0026lt;Clock, Duration\u0026gt;; void timePointCaseTest() { // 1. 基于秒的时间点 TimePoint\u0026lt;seconds\u0026gt; mPoint(seconds(1)); // 2. 基于毫秒的时间点 TimePoint\u0026lt;milliseconds\u0026gt; milPoint(milliseconds(1234)); // s -\u0026gt; ms 1 TimePoint\u0026lt;milliseconds\u0026gt; ms = mPoint; // ms -\u0026gt; s TimePoint\u0026lt;seconds\u0026gt; ss = time_point_cast\u0026lt;seconds\u0026gt;(milPoint); } 注意事项：关于时间点的转换如果没有精度的损失可以直接进行隐式类型转换，如果会损失精度只能通过显式类型转换，也就是调用time_point_cast函数来完成该操作。\n","date":"2025-03-26T00:00:00Z","image":"https://serennan.github.io/post/cpp-chrono/cover.png","permalink":"https://serennan.github.io/post/cpp-chrono/","title":"【C++11】处理日期和时间的 chrono 库"},{"content":"Qt 中多线程的使用 在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑， 如果只有一个线程去处理，就会导致窗口卡顿，无法处理用户的相关操作。这种情况下就需要使用多线程，其中一个线程处理窗口事件，其他线程进行逻辑运算，多个线程各司其职，不仅可以提高用户体验还可以提升程序的执行效率。\n在qt中使用了多线程，有些事项是需要额外注意的：\n默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新\n子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理\n主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制 1. 线程类 QThread Qt中提供了一个线程类，通过这个类就可以创建子线程了，Qt中一共提供了两种创建子线程的方式，后边会依次介绍其使用方式。先来看一下这个类中提供的一些常用API函数：\n1.1 常用共用成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // QThread 类常用 API // 构造函数 QThread::QThread(QObject *parent = Q_NULLPTR); // 判断线程中的任务是不是处理完毕了 bool QThread::isFinished() const; // 判断子线程是不是在执行任务 bool QThread::isRunning() const; // Qt中的线程可以设置优先级 // 得到当前线程的优先级 Priority QThread::priority() const; void QThread::setPriority(Priority priority); 优先级: QThread::IdlePriority --\u0026gt; 最低的优先级 QThread::LowestPriority QThread::LowPriority QThread::NormalPriority QThread::HighPriority QThread::HighestPriority QThread::TimeCriticalPriority --\u0026gt; 最高的优先级 QThread::InheritPriority --\u0026gt; 子线程和其父线程的优先级相同, 默认是这个 // 退出线程, 停止底层的事件循环 // 退出线程的工作函数 void QThread::exit(int returnCode = 0); // 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是 // 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数 bool QThread::wait(unsigned long time = ULONG_MAX); 1.2 信号槽 1 2 3 4 5 6 7 8 9 10 11 12 13 // 和调用 exit() 效果是一样的 // 调用这个函数之后, 再调用 wait() 函数 [slot] void QThread::quit(); // 启动子线程 [slot] void QThread::start(Priority priority = InheritPriority); // 线程退出, 可能是会马上终止线程, 一般情况下不使用这个函数 [slot] void QThread::terminate(); // 线程中执行的任务完成了, 发出该信号 // 任务函数中的处理逻辑执行完毕了 [signal] void QThread::finished(); // 开始工作之前发出这个信号, 一般不使用 [signal] void QThread::started(); 1.3 静态函数 1 2 3 4 5 6 7 8 // 返回一个指向管理当前执行线程的QThread的指针 [static] QThread *QThread::currentThread(); // 返回可以在系统上运行的理想线程数 == 和当前电脑的 CPU 核心数相同 [static] int QThread::idealThreadCount(); // 线程休眠函数 [static] void QThread::msleep(unsigned long msecs);\t// 单位: 毫秒 [static] void QThread::sleep(unsigned long secs);\t// 单位: 秒 [static] void QThread::usleep(unsigned long usecs);\t// 单位: 微秒 1.4 任务处理函数 1 2 // 子线程要处理什么任务, 需要写到 run() 中 [virtual protected] void QThread::run(); 这个 run() 是一个虚函数，如果想让创建的子线程执行某个任务，需要写一个子类让其继承 QThread ，并且在子类中重写父类的 run() 方法，函数体就是对应的任务处理流程。另外，这个函数是一个受保护的成员函数，不能够在类的外部调用，如果想要让线程执行这个函数中的业务流程，需要通过当前线程对象调用槽函数 start() 启动子线程，当子线程被启动，这个 run() 函数也就在线程内部被调用了。\n2. 使用方式 1 2.1 操作步骤 Qt中提供的多线程的第一种使用方式的特点是： 简单。操作步骤如下：\n需要创建一个线程类的子类，让其继承QT中的线程类 QThread，比如: 1 2 3 4 class MyThread:public QThread { ...... } 重写父类的 run() 方法，在该函数内部编写子线程要处理的具体的业务流程 1 2 3 4 5 6 7 8 9 class MyThread:public QThread { ...... protected: void run() { ........ } } 在主线程中创建子线程对象，new 一个就可以了 1 MyThread * subThread = new MyThread; 启动子线程, 调用 start() 方法 1 subThread-\u0026gt;start(); 不能在类的外部调用 run() 方法启动子线程，在外部调用 start() 相当于让 run() 开始运行\n当子线程别创建出来之后，父子线程之间的通信可以通过信号槽的方式，注意事项:\n在Qt中在子线程中不要操作程序中的窗口类型对象, 不允许, 如果操作了程序就挂了 只有主线程才能操作程序中的窗口对象, 默认的线程就是主线程, 自己创建的就是子线程 2.2 示例代码 举一个简单的数数的例子，假如只有一个线程，让其一直数数，会发现数字并不会在窗口中时时更新，并且这时候如果用户使用鼠标拖动窗口，就会出现无响应的情况，使用多线程就不会出现这样的现象了。\nMyThread.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #pragma once #include \u0026lt;QThread\u0026gt; #include \u0026lt;QVector\u0026gt; class MyThread : public QThread { Q_OBJECT public: explicit MyThread(QObject *parent = nullptr); protected: void run(); signals: // 自定义信号, 传递数据 void curNumber(int num); }; MyThread.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026#34;Mythread.h\u0026#34; #include \u0026lt;QDebug\u0026gt; MyThread::MyThread(QObject *parent) : QThread(parent) {} void MyThread::run() { qDebug() \u0026lt;\u0026lt; \u0026#34;当前线程对象的地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); int num = 0; while (1) { emit curNumber(num++); if (num == 10000000) { break; } QThread::usleep(1); } qDebug() \u0026lt;\u0026lt; \u0026#34;run() 执行完毕, 子线程退出...\u0026#34;; } MainWindow.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;MainWindow.h\u0026#34; #include \u0026#34;Mythread.h\u0026#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui_MainWindow) { ui-\u0026gt;setupUi(this); qDebug() \u0026lt;\u0026lt; \u0026#34;主线程对象地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); // 创建子线程 MyThread *subThread = new MyThread; connect(subThread, \u0026amp;MyThread::curNumber, this, [=](int num) { ui-\u0026gt;label-\u0026gt;setNum(num); }); connect(ui-\u0026gt;startBtn, \u0026amp;QPushButton::clicked, this, [=]() { // 启动子线程 subThread-\u0026gt;start(); }); } MainWindow::~MainWindow() { delete ui; } 这种在程序中添加子线程的方式是非常简单的，但是也有弊端，假设要在一个子线程中处理多个任务，所有的处理逻辑都需要写到run()函数中，这样该函数中的处理逻辑就会变得非常混乱，不太容易维护。\n3. 使用方式 2 3.1 操作步骤 Qt提供的第二种线程的创建方式弥补了第一种方式的缺点，用起来更加灵活，但是这种方式写起来会相对复杂一些，其具体操作步骤如下：\n创建一个新的类，让这个类从 QObejct 派生 1 2 3 4 class MyWork:public QObject { ....... } 在这个类中添加一个公共的成员函数，函数体就是我们要子线程中执行的业务逻辑 1 2 3 4 5 6 7 class MyWork:public QObject { public: ....... // 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加 void working(); } 在主线程中创建一个QThread对象, 这就是子线程的对象 1 QThread* sub = new QThread; 在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象） 1 2 MyWork* work = new MyWork(this); // error MyWork* work = new MyWork; // ok 将MyWork对象移动到创建的子线程对象中, 需要调用QObject类提供的 moveToThread() 方法 1 2 3 4 // void QObject::moveToThread(QThread *targetThread); // 如果给work指定了父对象, 这个函数调用就失败了 // 提示： QObject::moveToThread: Cannot move objects with a parent work-\u0026gt;moveToThread(sub);\t// 移动到子线程中工作 启动子线程，调用 start(), 这时候线程启动了, 但是移动到线程中的对象并没有工作\n调用MyWork类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的\n3.2 示例代码 MyThread.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #pragma once #include \u0026lt;QObject\u0026gt; #include \u0026lt;QVector\u0026gt; class MyWork : public QObject { Q_OBJECT public: explicit MyWork(QObject *parent = nullptr); // 工作函数 void working(); signals: // 自定义信号, 传递数据 void curNumber(int num); }; MyWork.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;MyWork.h\u0026#34; #include \u0026lt;QDebug\u0026gt; #include \u0026lt;QThread\u0026gt; MyWork::MyWork(QObject *parent) : QObject(parent) {} void MyWork::working() { qDebug() \u0026lt;\u0026lt; \u0026#34;当前线程对象的地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); int num = 0; while (1) { emit curNumber(num++); if (num == 10000000) { break; } QThread::usleep(1); } qDebug() \u0026lt;\u0026lt; \u0026#34;run() 执行完毕, 子线程退出...\u0026#34;; } MainWindow.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026#34;MainWindow.h\u0026#34; #include \u0026#34;MyWork.h\u0026#34; #include \u0026lt;QThread\u0026gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui_MainWindow) { ui-\u0026gt;setupUi(this); qDebug() \u0026lt;\u0026lt; \u0026#34;主线程对象地址: \u0026#34; \u0026lt;\u0026lt; QThread::currentThread(); // 创建线程对象 QThread *subThread = new QThread; // 创建工作的类对象 // 不要给创建的对象指定父对象 // 不然会导致错误：QObject::moveToThread: Cannot move objects with a parent MyWork *work = new MyWork; // 将工作的类对象移动到创建的子线程中 work-\u0026gt;moveToThread(subThread); // 启动线程 subThread-\u0026gt;start(); // 让工作的对象开始工作, 点击开始按钮, 开始工作 connect(ui-\u0026gt;startBtn, \u0026amp;QPushButton::clicked, work, \u0026amp;MyWork::working); // 显示数据 connect(work, \u0026amp;MyWork::curNumber, this, [=](int num) { ui-\u0026gt;label-\u0026gt;setNum(num); }); } MainWindow::~MainWindow() { delete ui; } 使用这种多线程方式，假设有多个不相关的业务流程需要被处理，那么就可以创建多个类似于MyWork的类，将业务流程放多类的公共成员函数中，然后将这个业务类的实例对象移动到对应的子线程中moveToThread()就可以了，这样可以让编写的程序更加灵活，可读性更强，更易于维护。\n","date":"2025-03-22T00:00:00Z","image":"https://serennan.github.io/post/qt-thread-1/cover.png","permalink":"https://serennan.github.io/post/qt-thread-1/","title":"【Qt 线程】1 Qt 多线程的使用"},{"content":"Qt 中的基础窗口类 文章中主要介绍了Qt中常用的窗口类, 主要内容包括: 窗口类的基类QWidget, 对话框基类QDialog, 带菜单栏工具栏状态栏的QMainWindow, 消息对话框QMessageBox, 文件对话框QFileDialog, 字体对话框QFontDialog, 颜色对话框QColorDialog, 输入型对话框QInputDialog, 进度条对话框QProgressDialog, 资源文件。\n1. QWidget QWidget类是所有窗口类的父类(控件类是也属于窗口类), 并且QWidget类的父类的QObject, 也就意味着所有的窗口类对象只要指定了父对象, 都可以实现内存资源的自动回收。 在前面入门章节中已经为大家介绍了QWidget的一些特点, 为了让大家能够对这个类有更深入的了解, 下面来说一说这个类常用的一些API函数。\n1.1 设置父对象 1 2 3 4 5 6 7 8 9 // 构造函数 QWidget::QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); // 公共成员函数 // 给当前窗口设置父对象 void QWidget::setParent(QWidget *parent); void QWidget::setParent(QWidget *parent, Qt::WindowFlags f); // 获取当前窗口的父对象, 没有父对象返回 nullptr QWidget *QWidget::parentWidget() const; 1.2 窗口位置 1 2 3 4 5 6 7 8 9 10 11 12 //------------- 窗口位置 ------------- // 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内 QRect QWidget::frameGeometry() const; // 得到相对于当前窗口父窗口的几何信息, 不包括边框 const QRect \u0026amp;geometry() const; // 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框 void setGeometry(int x, int y, int w, int h); void setGeometry(const QRect \u0026amp;); // 移动窗口, 重新设置窗口的位置 void move(int x, int y); void move(const QPoint \u0026amp;); 窗口位置设定和位置获取的测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 获取当前窗口的位置信息 void MainWindow::on_positionBtn_clicked() { QRect rect = this-\u0026gt;frameGeometry(); qDebug() \u0026lt;\u0026lt; \u0026#34;左上角: \u0026#34; \u0026lt;\u0026lt; rect.topLeft() \u0026lt;\u0026lt; \u0026#34;右上角: \u0026#34; \u0026lt;\u0026lt; rect.topRight() \u0026lt;\u0026lt; \u0026#34;左下角: \u0026#34; \u0026lt;\u0026lt; rect.bottomLeft() \u0026lt;\u0026lt; \u0026#34;右下角: \u0026#34; \u0026lt;\u0026lt; rect.bottomRight() \u0026lt;\u0026lt; \u0026#34;宽度: \u0026#34; \u0026lt;\u0026lt; rect.width() \u0026lt;\u0026lt; \u0026#34;高度: \u0026#34; \u0026lt;\u0026lt; rect.height(); } // 重新设置当前窗口的位置以及宽度, 高度 void MainWindow::on_geometryBtn_clicked() { int x = 100 + rand() % 500; int y = 100 + rand() % 500; int width = this-\u0026gt;width() + 10; int height = this-\u0026gt;height() + 10; setGeometry(x, y, width, height); } // 通过 move() 方法移动窗口 void MainWindow::on_moveBtn_clicked() { QRect rect = this-\u0026gt;frameGeometry(); move(rect.topLeft() + QPoint(10, 20)); } Qt 的信号-槽机制允许通过特定的命名模式自动生成槽函数与信号的连接，无需手动使用 connect 语句。格式如下：\n1.3 窗口尺寸 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //------------- 窗口尺寸 ------------- // 获取当前窗口的尺寸信息 QSize size() const // 重新设置窗口的尺寸信息 void resize(int w, int h); void resize(const QSize \u0026amp;); // 获取当前窗口的最大尺寸信息 QSize maximumSize() const; // 获取当前窗口的最小尺寸信息 QSize minimumSize() const; // 设置当前窗口固定的尺寸信息 void QWidget::setFixedSize(const QSize \u0026amp;s); void QWidget::setFixedSize(int w, int h); // 设置当前窗口的最大尺寸信息 void setMaximumSize(const QSize \u0026amp;); void setMaximumSize(int maxw, int maxh); // 设置当前窗口的最小尺寸信息 void setMinimumSize(const QSize \u0026amp;); void setMinimumSize(int minw, int minh); // 获取当前窗口的高度 int height() const; // 获取当前窗口的最小高度 int minimumHeight() const; // 获取当前窗口的最大高度 int maximumHeight() const; // 给窗口设置固定的高度 void QWidget::setFixedHeight(int h); // 给窗口设置最大高度 void setMaximumHeight(int maxh); // 给窗口设置最小高度 void setMinimumHeight(int minh); // 获取当前窗口的宽度 int width() const; // 获取当前窗口的最小宽度 int minimumWidth() const; // 获取当前窗口的最大宽度 int maximumWidth() const; // 给窗口设置固定宽度 void QWidget::setFixedWidth(int w); // 给窗口设置最大宽度 void setMaximumWidth(int maxw); // 给窗口设置最小宽度 void setMinimumWidth(int minw); 1.4 窗口标题和图标 1 2 3 4 5 6 7 8 9 10 11 12 13 //------------- 窗口图标 ------------- // 得到当前窗口的图标 QIcon windowIcon() const; // 构造图标对象, 参数为图片的路径 QIcon::QIcon(const QString \u0026amp;fileName); // 设置当前窗口的图标 void setWindowIcon(const QIcon \u0026amp;icon); //------------- 窗口标题 ------------- // 得到当前窗口的标题 QString windowTitle() const; // 设置当前窗口的标题 void setWindowTitle(const QString \u0026amp;); 1.5 信号 1 2 3 4 5 6 7 // QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy); // 窗口的右键菜单策略 contextMenuPolicy() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号 [signal] void QWidget::customContextMenuRequested(const QPoint \u0026amp;pos); // 窗口图标发生变化, 发射此信号 [signal] void QWidget::windowIconChanged(const QIcon \u0026amp;icon); // 窗口标题发生变化, 发射此信号 [signal] void QWidget::windowTitleChanged(const QString \u0026amp;title); 1.6 槽函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //------------- 窗口显示 ------------- // 关闭当前窗口 [slot] bool QWidget::close(); // 隐藏当前窗口 [slot] void QWidget::hide(); // 显示当前创建以及其子窗口 [slot] void QWidget::show(); // 全屏显示当前窗口, 只对windows有效 [slot] void QWidget::showFullScreen(); // 窗口最大化显示, 只对windows有效 [slot] void QWidget::showMaximized(); // 窗口最小化显示, 只对windows有效 [slot] void QWidget::showMinimized(); // 将窗口回复为最大化/最小化之前的状态, 只对windows有效 [slot] void QWidget::showNormal(); //------------- 窗口状态 ------------- // 判断窗口是否可用 bool QWidget::isEnabled() const; // 非槽函数 // 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件 // 参数true-\u0026gt;可用, false-\u0026gt;不可用 [slot] void QWidget::setEnabled(bool); // 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件 // 参数true-\u0026gt;不可用, false-\u0026gt;可用 [slot] void QWidget::setDisabled(bool disable); // 设置窗口是否可见, 参数为true-\u0026gt;可见, false-\u0026gt;不可见 [slot] virtual void QWidget::setVisible(bool visible); 2. QDialog 2.1 常用API 对话框类是QWidget类的子类, 处理继承自父类的属性之外, 还有一些自己所特有的属性, 常用的一些API函数如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 构造函数 QDialog::QDialog(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); // 模态显示窗口 [virtual slot] int QDialog::exec(); // 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted [virtual slot] void QDialog::accept(); // 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected [virtual slot] void QDialog::reject(); // 关闭对话框并将其结果代码设置为r。finished()信号将发出r; // 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。 [virtual slot] void QDialog::done(int r); [signal] void QDialog::accepted(); [signal] void QDialog::rejected(); [signal] void QDialog::finished(int result); 2.2 常用使用方法 1 2 3 场景介绍: 1. 有两个窗口, 主窗口和一个对话框子窗口 2. 对话框窗口先显示, 根据用户操作选择是否显示主窗口 关于对话框窗口类的操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 对话框窗口中三个普通按钮按下之后对应的槽函数 void MyDialog::on_acceptBtn_clicked() { this-\u0026gt;accept(); // exec()函数返回值为QDialog::Accepted } void MyDialog::on_rejectBtn_clicked() { this-\u0026gt;reject(); // exec()函数返回值为QDialog::Rejected } void MyDialog::on_donBtn_clicked() { // exec()函数返回值为 done() 的参数, 并根据参数发射出对应的信号 this-\u0026gt;done(666); } 根据用户针对对话框窗口的按钮操作, 进行相应的逻辑处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 创建对话框对象 MyDialog dlg; int ret = dlg.exec(); if(ret == QDialog::Accepted) { qDebug() \u0026lt;\u0026lt; \u0026#34;accept button clicked...\u0026#34;; // 显示主窗口 MainWindow* w = new MainWindow; w-\u0026gt;show(); } else if(ret == QDialog::Rejected) { qDebug() \u0026lt;\u0026lt; \u0026#34;reject button clicked...\u0026#34;; // 不显示主窗口 ...... ...... } else { // ret == 666 qDebug() \u0026lt;\u0026lt; \u0026#34;done button clicked...\u0026#34;; // 根据需求进行逻辑处理 ...... ...... } 3. QDialog的子类 3.1 QMessageBox QMessageBox 对话框类是 QDialog 类的子类, 通过这个类可以显示一些简单的提示框, 用于展示警告、错误、问题等信息。关于这个类我们只需要掌握一些静态方法的使用就可以了。\nAPI - 静态函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 显示一个模态对话框, 将参数 text 的信息展示到窗口中 [static] void QMessageBox::about(QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;text); /* 参数: - parent: 对话框窗口的父窗口 - title: 对话框窗口的标题 - text: 对话框窗口中显示的提示信息 - buttons: 对话框窗口中显示的按钮(一个或多个) - defaultButton 1. defaultButton指定按下Enter键时使用的按钮。 2. defaultButton必须引用在参数 buttons 中给定的按钮。 3. 如果defaultButton是QMessageBox::NoButton, QMessageBox会自动选择一个合适的默认值。 */ // 显示一个信息模态对话框 [static] QMessageBox::StandardButton QMessageBox::information( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;text, QMessageBox::StandardButtons buttons = Ok, QMessageBox::StandardButton defaultButton = NoButton); // 显示一个错误模态对话框 [static] QMessageBox::StandardButton QMessageBox::critical( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;text, QMessageBox::StandardButtons buttons = Ok, QMessageBox::StandardButton defaultButton = NoButton); // 显示一个问题模态对话框 [static] QMessageBox::StandardButton QMessageBox::question( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;text, QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), QMessageBox::StandardButton defaultButton = NoButton); // 显示一个警告模态对话框 [static] QMessageBox::StandardButton QMessageBox::warning( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;text, QMessageBox::StandardButtons buttons = Ok, QMessageBox::StandardButton defaultButton = NoButton); 测试代码 测试代码片段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void MainWindow::on_msgbox_clicked() { QMessageBox::about(this, \u0026#34;about\u0026#34;, \u0026#34;这是一个简单的消息提示框!!!\u0026#34;); QMessageBox::critical(this, \u0026#34;critical\u0026#34;, \u0026#34;这是一个错误对话框-critical...\u0026#34;); int ret = QMessageBox::question(this, \u0026#34;question\u0026#34;, \u0026#34;你要保存修改的文件内容吗???\u0026#34;, QMessageBox::Save|QMessageBox::Cancel, QMessageBox::Cancel); if(ret == QMessageBox::Save) { QMessageBox::information(this, \u0026#34;information\u0026#34;, \u0026#34;恭喜你保存成功了, o(*￣︶￣*)o!!!\u0026#34;); } else if(ret == QMessageBox::Cancel) { QMessageBox::warning(this, \u0026#34;warning\u0026#34;, \u0026#34;你放弃了保存, ┭┮﹏┭┮ !!!\u0026#34;); } } 3.2 QFileDialog QFileDialog 对话框类是 QDialog 类的子类, 通过这个类可以选择要打开/保存的文件或者目录。关于这个类我们只需要掌握一些静态方法的使用就可以了。\nAPI - 静态函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 通用参数: - parent: 当前对话框窗口的父对象也就是父窗口 - caption: 当前对话框窗口的标题 - dir: 当前对话框窗口打开的默认目录 - options: 当前对话框窗口的一些可选项,枚举类型, 一般不需要进行设置, 使用默认值即可 - filter: 过滤器, 在对话框中只显示满足条件的文件, 可以指定多个过滤器, 使用 ;; 分隔 - 样式举例: - Images (*.png *.jpg) - Images (*.png *.jpg);;Text files (*.txt) - selectedFilter: 如果指定了多个过滤器, 通过该参数指定默认使用哪一个, 不指定默认使用第一个过滤器 */ // 打开一个目录, 得到这个目录的绝对路径 [static] QString QFileDialog::getExistingDirectory( QWidget *parent = nullptr, const QString \u0026amp;caption = QString(), const QString \u0026amp;dir = QString(), QFileDialog::Options options = ShowDirsOnly); // 打开一个文件, 得到这个文件的绝对路径 [static] QString QFileDialog::getOpenFileName( QWidget *parent = nullptr, const QString \u0026amp;caption = QString(), const QString \u0026amp;dir = QString(), const QString \u0026amp;filter = QString(), QString *selectedFilter = nullptr, QFileDialog::Options options = Options()); // 打开多个文件, 得到这多个文件的绝对路径 [static] QStringList QFileDialog::getOpenFileNames( QWidget *parent = nullptr, const QString \u0026amp;caption = QString(), const QString \u0026amp;dir = QString(), const QString \u0026amp;filter = QString(), QString *selectedFilter = nullptr, QFileDialog::Options options = Options()); // 打开一个目录, 使用这个目录来保存指定的文件 [static] QString QFileDialog::getSaveFileName( QWidget *parent = nullptr, const QString \u0026amp;caption = QString(), const QString \u0026amp;dir = QString(), const QString \u0026amp;filter = QString(), QString *selectedFilter = nullptr, QFileDialog::Options options = Options()); 测试代码 打开一个已存在的本地目录\n1 2 3 4 5 void MainWindow::on_filedlg_clicked() { QString dirName = QFileDialog::getExistingDirectory(this, \u0026#34;打开目录\u0026#34;, \u0026#34;e:\\\\temp\u0026#34;); QMessageBox::information(this, \u0026#34;打开目录\u0026#34;, \u0026#34;您选择的目录是: \u0026#34; + dirName); } 打开一个本地文件\n1 2 3 4 5 6 7 void MainWindow::on_filedlg_clicked() { QString arg(\u0026#34;Text files (*.txt)\u0026#34;); QString fileName = QFileDialog::getOpenFileName( this, \u0026#34;Open File\u0026#34;, \u0026#34;e:\\\\temp\u0026#34;, \u0026#34;Images (*.png *.jpg);;Text files (*.txt)\u0026#34;, \u0026amp;arg); QMessageBox::information(this, \u0026#34;打开文件\u0026#34;, \u0026#34;您选择的文件是: \u0026#34; + fileName); } 打开多个本地文件\n1 2 3 4 5 6 7 8 9 10 { QStringList fileNames = QFileDialog::getOpenFileNames( this, \u0026#34;Open File\u0026#34;, \u0026#34;e:\\\\temp\u0026#34;, \u0026#34;Images (*.png *.jpg);;Text files (*.txt)\u0026#34;); QString names; for (int i = 0; i \u0026lt; fileNames.size(); ++i) { names += fileNames.at(i) + \u0026#34; \u0026#34;; } QMessageBox::information(this, \u0026#34;打开文件(s)\u0026#34;, \u0026#34;您选择的文件是: \u0026#34; + names); } 打开保存文件对话框\n1 2 3 4 5 void MainWindow::on_filedlg_clicked() { QString fileName = QFileDialog::getSaveFileName(this, \u0026#34;保存文件\u0026#34;, \u0026#34;e:\\\\temp\u0026#34;); QMessageBox::information(this, \u0026#34;保存文件\u0026#34;, \u0026#34;您指定的保存数据的文件是: \u0026#34; + fileName); } 3.3 QFontDialog QFontDialog类是QDialog的子类, 通过这个类我们可以得到一个进行字体属性设置的对话框窗口, 和前边介绍的对话框类一样, 我们只需要调用这个类的静态成员函数就可以得到想要的窗口了。\nQFont 字体类 关于字体的属性信息, 在QT框架中被封装到了一个叫QFont的类中, 下边为大家介绍一下这个类的API, 了解一下关于这个类的使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 构造函数 QFont::QFont(); /* 参数: - family: 本地字库中的字体名, 通过 office 等文件软件可以查看 - pointSize: 字体的字号 - weight: 字体的粗细, 有效范围为 0 ~ 99 - italic: 字体是否倾斜显示, 默认不倾斜 */ QFont::QFont(const QString \u0026amp;family, int pointSize = -1, int weight = -1, bool italic = false); // 设置字体 void QFont::setFamily(const QString \u0026amp;family); // 根据字号设置字体大小 void QFont::setPointSize(int pointSize); // 根据像素设置字体大小 void QFont::setPixelSize(int pixelSize); // 设置字体的粗细程度, 有效范围: 0 ~ 99 void QFont::setWeight(int weight); // 设置字体是否加粗显示 void QFont::setBold(bool enable); // 设置字体是否要倾斜显示 void QFont::setItalic(bool enable); // 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名) QString QFont::family() const; bool QFont::italic() const; int QFont::pixelSize() const; int QFont::pointSize() const; bool QFont::bold() const; int QFont::weight() const; 如果一个QFont对象被创建, 并且进行了初始化, 我们可以将这个属性设置给某个窗口, 或者设置给当前应用程序对象。\n1 2 3 4 5 6 7 8 9 10 11 // QWidget 类 // 得到当前窗口使用的字体 const QWidget::QFont\u0026amp; font() const; // 给当前窗口设置字体, 只对当前窗口类生效 void QWidget::setFont(const QFont \u0026amp;); // QApplication 类 // 得到当前应用程序对象使用的字体 [static] QFont QApplication::font(); // 给当前应用程序对象设置字体, 作用于当前应用程序的所有窗口 [static] void QApplication::setFont(const QFont \u0026amp;font, const char *className = nullptr); QFontDialog类的静态API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* 参数: - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址 - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化 - parent: 字体对话框窗口的父对象 - title: 字体对话框的窗口标题 - options: 字体对话框选项, 使用默认属性即可, 一般不设置 */ [static] QFont QFontDialog::getFont( bool *ok, const QFont \u0026amp;initial, QWidget *parent = nullptr, const QString \u0026amp;title = QString(), QFontDialog::FontDialogOptions options = FontDialogOptions()); [static] QFont QFontDialog::getFont(bool *ok, QWidget *parent = nullptr); 测试代码 通过字体对话框选择字体, 并将选择的字体设置给当前窗口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void MainWindow::on_fontdlg_clicked() { #if 1 // 方式1 bool ok; QFont ft = QFontDialog::getFont( \u0026amp;ok, QFont(\u0026#34;微软雅黑\u0026#34;, 12, QFont::Bold), this, \u0026#34;选择字体\u0026#34;); qDebug() \u0026lt;\u0026lt; \u0026#34;ok value is: \u0026#34; \u0026lt;\u0026lt; ok; #else // 方式2 QFont ft = QFontDialog::getFont(NULL); #endif // 将选择的字体设置给当前窗口对象 this-\u0026gt;setFont(ft); } 3.4 QColorDialog QColorDialog类是QDialog的子类, 通过这个类我们可以得到一个选择颜色的对话框窗口, 和前边介绍的对话框类一样, 我们只需要调用这个类的静态成员函数就可以得到想要的窗口了。\n颜色类 QColor 关于颜色的属性信息, 在QT框架中被封装到了一个叫QColor的类中, 下边为大家介绍一下这个类的API, 了解一下关于这个类的使用。 各种颜色都是基于红, 绿, 蓝这三种颜色调配而成的, 并且颜色还可以进行透明度设置, 默认是不透明的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 构造函数 QColor::QColor(Qt::GlobalColor color); QColor::QColor(int r, int g, int b, int a = ...); QColor::QColor(); // 参数设置 red, green, blue, alpha, 取值范围都是 0-255 void QColor::setRed(int red);\t// 红色 void QColor::setGreen(int green);\t// 绿色 void QColor::setBlue(int blue);\t// 蓝色 void QColor::setAlpha(int alpha);\t// 透明度, 默认不透明(255) void QColor::setRgb(int r, int g, int b, int a = 255); int QColor::red() const; int QColor::green() const; int QColor::blue() const; int QColor::alpha() const; void QColor::getRgb(int *r, int *g, int *b, int *a = nullptr) const; 静态API函数 1 2 3 4 5 6 7 8 9 10 11 12 // 弹出颜色选择对话框, 并返回选中的颜色信息 /* 参数: - initial: 对话框中默认选中的颜色, 用于窗口初始化 - parent: 给对话框窗口指定父对象 - title: 对话框窗口的标题 - options: 颜色对话框窗口选项, 使用默认属性即可, 一般不需要设置 */ [static] QColor QColorDialog::getColor( const QColor \u0026amp;initial = Qt::white, QWidget *parent = nullptr, const QString \u0026amp;title = QString(), QColorDialog::ColorDialogOptions options = ColorDialogOptions()); 测试代码 场景描述:\n1. 在窗口上放一个标签控件\n2. 通过颜色对话框选择一个颜色, 将选中的颜色显示到标签控件上\n3. 将选中的颜色的 RGBA 值分别显示出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 void MainWindow::on_colordlg_clicked() { QColor color = QColorDialog::getColor(); QBrush brush(color); QRect rect(0, 0, ui-\u0026gt;color-\u0026gt;width(), ui-\u0026gt;color-\u0026gt;height()); QPixmap pix(rect.width(), rect.height()); QPainter p(\u0026amp;pix); p.fillRect(rect, brush); ui-\u0026gt;color-\u0026gt;setPixmap(pix); QString text = QString(\u0026#34;red: %1, green: %2, blue: %3, 透明度: %4\u0026#34;) .arg(color.red()).arg(color.green()).arg(color.blue()).arg(color.alpha()); ui-\u0026gt;colorlabel-\u0026gt;setText(text); } 3.5 QInputDialog QInputDialog类是QDialog的子类, 通过这个类我们可以得到一个输入对话框窗口, 根据实际需求我们可以在这个输入窗口中输入整形, 浮点型, 字符串类型的数据, 并且还可以显示下拉菜单供使用者选择。 和前边介绍的对话框类一样, 我们只需要调用这个类的静态成员函数就可以得到想要的窗口了。\nAPI - 静态函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 // 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数 /* 参数: - parent: 对话框窗口的父窗口 - title: 对话框窗口显示的标题信息 - label: 对话框窗口中显示的文本信息(用于描述对话框的功能) - value: 对话框窗口中显示的浮点值, 默认为 0 - min: 对话框窗口支持显示的最小数值 - max: 对话框窗口支持显示的最大数值 - decimals: 浮点数的精度, 默认保留小数点以后1位 - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数 - flags: 对话框窗口的窗口属性, 使用默认值即可 */ [static] double QInputDialog::getDouble( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;label, double value = 0, double min = -2147483647, double max = 2147483647, int decimals = 1, bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags()); // 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数 /* 参数: - parent: 对话框窗口的父窗口 - title: 对话框窗口显示的标题信息 - label: 对话框窗口中显示的文本信息(用于描述对话框的功能) - value: 对话框窗口中显示的整形值, 默认为 0 - min: 对话框窗口支持显示的最小数值 - max: 对话框窗口支持显示的最大数值 - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量 - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数 - flags: 对话框窗口的窗口属性, 使用默认值即可 */ [static] int QInputDialog::getInt( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;label, int value = 0, int min = -2147483647, int max = 2147483647, int step = 1, bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags()); // 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息 /* 参数: - parent: 对话框窗口的父窗口 - title: 对话框窗口显示的标题信息 - label: 对话框窗口中显示的文本信息(用于描述对话框的功能) - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项 - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0) - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑 - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数 - flags: 对话框窗口的窗口属性, 使用默认值即可 - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串 - 如果有特殊需求, 可以参数帮助文档进行相关设置 */ [static] QString QInputDialog::getItem( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;label, const QStringList \u0026amp;items, int current = 0, bool editable = true, bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags(), Qt::InputMethodHints inputMethodHints = Qt::ImhNone); // 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息 /* 参数: - parent: 对话框窗口的父窗口 - title: 对话框窗口显示的标题信息 - label: 对话框窗口中显示的文本信息(用于描述对话框的功能) - text: 指定显示到多行输入框中的文本信息, 默认是空字符串 - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数 - flags: 对话框窗口的窗口属性, 使用默认值即可 - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串 - 如果有特殊需求, 可以参数帮助文档进行相关设置 */ [static] QString QInputDialog::getMultiLineText( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;label, const QString \u0026amp;text = QString(), bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags(), Qt::InputMethodHints inputMethodHints = Qt::ImhNone); // 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息 /* 参数: - parent: 对话框窗口的父窗口 - title: 对话框窗口显示的标题信息 - label: 对话框窗口中显示的文本信息(用于描述对话框的功能) - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值 - QLineEdit::Normal: 显示输入的字符。这是默认值 - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。 - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。 - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。 - text: 指定显示到单行输入框中的文本信息, 默认是空字符串 - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数 - flags: 对话框窗口的窗口属性, 使用默认值即可 - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串 - 如果有特殊需求, 可以参数帮助文档进行相关设置 */ [static] QString QInputDialog::getText( QWidget *parent, const QString \u0026amp;title, const QString \u0026amp;label, QLineEdit::EchoMode mode = QLineEdit::Normal, const QString \u0026amp;text = QString(), bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags(), Qt::InputMethodHints inputMethodHints = Qt::ImhNone); 测试代码 整形输入框\n1 2 3 4 5 void MainWindow::on_inputdlg_clicked() { int ret = QInputDialog::getInt(this, \u0026#34;年龄\u0026#34;, \u0026#34;您的当前年龄: \u0026#34;, 10, 1, 100, 2); QMessageBox::information(this, \u0026#34;年龄\u0026#34;, \u0026#34;您的当前年龄: \u0026#34; + QString::number(ret)); } 浮点型输入框\n1 2 3 4 5 void MainWindow::on_inputdlg_clicked() { double ret = QInputDialog::getDouble(this, \u0026#34;工资\u0026#34;, \u0026#34;您的工资: \u0026#34;, 2000, 1000, 6000, 2); QMessageBox::information(this, \u0026#34;工资\u0026#34;, \u0026#34;您的当前工资: \u0026#34; + QString::number(ret)); } 带下拉菜单的输入框\n1 2 3 4 5 6 7 void MainWindow::on_inputdlg_clicked() { QStringList items; items \u0026lt;\u0026lt; \u0026#34;苹果\u0026#34; \u0026lt;\u0026lt; \u0026#34;橙子\u0026#34; \u0026lt;\u0026lt; \u0026#34;橘子\u0026#34; \u0026lt;\u0026lt; \u0026#34;葡萄\u0026#34; \u0026lt;\u0026lt; \u0026#34;香蕉\u0026#34; \u0026lt;\u0026lt; \u0026#34;哈密瓜\u0026#34;; QString item = QInputDialog::getItem(this, \u0026#34;请选择你喜欢的水果\u0026#34;, \u0026#34;你最喜欢的水果:\u0026#34;, items, 1, false); QMessageBox::information(this, \u0026#34;水果\u0026#34;, \u0026#34;您最喜欢的水果是: \u0026#34; + item); } 单行字符串输入框\n1 2 3 4 5 void MainWindow::on_inputdlg_clicked() { QString text = QInputDialog::getText(this, \u0026#34;密码\u0026#34;, \u0026#34;请输入新的密码\u0026#34;, QLineEdit::Password, \u0026#34;helloworld\u0026#34;); QMessageBox::information(this, \u0026#34;密码\u0026#34;, \u0026#34;您设置的密码是: \u0026#34; + text); } 多行字符串输入框\n1 2 3 4 5 void MainWindow::on_inputdlg_clicked() { QString info = QInputDialog::getMultiLineText(this, \u0026#34;表白\u0026#34;, \u0026#34;您最想对漂亮小姐姐说什么呢?\u0026#34;, \u0026#34;呦吼吼...\u0026#34;); QMessageBox::information(this, \u0026#34;知心姐姐\u0026#34;, \u0026#34;您最想对小姐姐说: \u0026#34; + info); } 3.6 QProgressDialog QProgressDialog类是QDialog的子类, 通过这个类我们可以得到一个带进度条的对话框窗口, 这种类型的对话框窗口一般常用于文件拷贝、数据传输等实时交互的场景中。\n常用API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // 构造函数 /* 参数: - labelText: 对话框中显示的提示信息 - cancelButtonText: 取消按钮上显示的文本信息 - minimum: 进度条最小值 - maximum: 进度条最大值 - parent: 当前窗口的父对象 - f: 当前进度窗口的flag属性, 使用默认属性即可, 无需设置 */ QProgressDialog::QProgressDialog( QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); QProgressDialog::QProgressDialog( const QString \u0026amp;labelText, const QString \u0026amp;cancelButtonText, int minimum, int maximum, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags()); // 设置取消按钮显示的文本信息 [slot] void QProgressDialog::setCancelButtonText(const QString \u0026amp;cancelButtonText); // 公共成员函数和槽函数 QString QProgressDialog::labelText() const; void QProgressDialog::setLabelText(const QString \u0026amp;text); // 得到进度条最小值 int QProgressDialog::minimum() const; // 设置进度条最小值 void QProgressDialog::setMinimum(int minimum); // 得到进度条最大值 int QProgressDialog::maximum() const; // 设置进度条最大值 void QProgressDialog::setMaximum(int maximum); // 设置进度条范围(最大和最小值) [slot] void QProgressDialog::setRange(int minimum, int maximum); // 得到进度条当前的值 int QProgressDialog::value() const; // 设置进度条当前的值 void QProgressDialog::setValue(int progress); bool QProgressDialog::autoReset() const; // 当value() = maximum()时，进程对话框是否调用reset()，此属性默认为true。 void QProgressDialog::setAutoReset(bool reset); bool QProgressDialog::autoClose() const; // 当value() = maximum()时，进程对话框是否调用reset()并且隐藏，此属性默认为true。 void QProgressDialog::setAutoClose(bool close); // 判断用户是否按下了取消键, 按下了返回true, 否则返回false bool wasCanceled() const; // 重置进度条 // 重置进度对话框。wascancelled()变为true，直到进程对话框被重置。进度对话框被隐藏。 [slot] void QProgressDialog::cancel(); // 重置进度对话框。如果autoClose()为真，进程对话框将隐藏。 [slot] void QProgressDialog::reset(); // 信号 // 当单击cancel按钮时，将发出此信号。默认情况下，它连接到cancel()槽。 [signal] void QProgressDialog::canceled(); // 设置窗口的显示状态(模态, 非模态) /* 参数: Qt::NonModal -\u0026gt; 非模态 Qt::WindowModal\t-\u0026gt; 模态, 阻塞父窗口 Qt::ApplicationModal -\u0026gt; 模态, 阻塞应用程序中的所有窗口 */ void QWidget::setWindowModality(Qt::WindowModality windowModality); 测试代码 场景描述:\n1. 基于定时器模拟文件拷贝的场景\n2. 点击窗口按钮, 进度条窗口显示, 同时启动定时器\n3. 通过定时器信号, 按照固定频率更新对话框窗口进度条\n4. 当进度条当前值 == 最大值, 关闭定时器, 关闭并析构进度对话框\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void MainWindow::on_progressdlg_clicked() { // 1. 创建进度条对话框窗口对象 QProgressDialog *progress = new QProgressDialog( \u0026#34;正在拷贝数据...\u0026#34;, \u0026#34;取消拷贝\u0026#34;, 0, 100, this); // 2. 初始化并显示进度条窗口 progress-\u0026gt;setWindowTitle(\u0026#34;请稍后\u0026#34;); progress-\u0026gt;setWindowModality(Qt::WindowModal); progress-\u0026gt;show(); // 3. 更新进度条 static int value = 0; QTimer *timer = new QTimer; connect(timer, \u0026amp;QTimer::timeout, this, [=]() { progress-\u0026gt;setValue(value); value++; // 当value \u0026gt; 最大值的时候 if(value \u0026gt; progress-\u0026gt;maximum()) { timer-\u0026gt;stop(); value = 0; delete progress; delete timer; } }); connect(progress, \u0026amp;QProgressDialog::canceled, this, [=]() { timer-\u0026gt;stop(); value = 0; delete progress; delete timer; }); timer-\u0026gt;start(50); } 4. QMainWindow QMainWindow是标准基础窗口中结构最复杂的窗口, 其组成如下:\n提供了菜单栏, 工具栏, 状态栏, 停靠窗口 菜单栏: 只能有一个, 位于窗口的最上方 工具栏: 可以有多个, 默认提供了一个, 窗口的上下左右都可以停靠 状态栏: 只能有一个, 位于窗口最下方 停靠窗口: 可以有多个, 默认没有提供, 窗口的上下左右都可以停靠 TODO 作图\n4.1 菜单栏 添加菜单项\n关于顶级菜单可以直接在UI窗口中双击, 直接输入文本信息即可, 对应子菜单项也可以通过先双击在输入的方式完成添加, 但是这种方式不支持中文的输入。\n常用的添加方式\n一般情况下, 我们都是先在外面创建出QAction对象, 然后再将其拖拽到某个菜单下边, 这样子菜单项的添加就完成了。\n通过代码的方式添加菜单或者菜单项\n1 2 3 4 5 6 7 8 9 10 11 // 给菜单栏添加菜单 QAction *QMenuBar::addMenu(QMenu *menu); QMenu *QMenuBar::addMenu(const QString \u0026amp;title); QMenu *QMenuBar::addMenu(const QIcon \u0026amp;icon, const QString \u0026amp;title); // 给菜单对象添加菜单项(QAction) QAction *QMenu::addAction(const QString \u0026amp;text); QAction *QMenu::addAction(const QIcon \u0026amp;icon, const QString \u0026amp;text); // 添加分割线 QAction *QMenu::addSeparator(); 菜单项 QAction 事件的处理\n单击菜单项, 该对象会发出一个信号 1 2 // 点击QAction对象发出该信号 [signal] void QAction::triggered(bool checked = false); 示例代码\n1 2 3 4 5 // save_action 是某个菜单项对象名, 点击这个菜单项会弹出一个对话框 connect(ui-\u0026gt;save_action, \u0026amp;QAction::triggered, this, [=]() { QMessageBox::information(this, \u0026#34;Triggered\u0026#34;, \u0026#34;菜单栏\u0026#34;); }); 4.2 工具栏 添加工具按钮 窗口中的工具栏我们经常见到, 并不会为此感到陌生, 那么如何往工具栏中添加工具按钮呢? 一共有两种方式, 这里依次为大家进行介绍。\n方式1：先创建QAction对象, 然后拖拽到工具栏中, 和添加菜单项的方式相同\n方式2：如果不通过UI界面直接操作，那么就需要调用相关的API函数了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 在QMainWindow窗口中添加工具栏 void QMainWindow::addToolBar(Qt::ToolBarArea area, QToolBar *toolbar); void QMainWindow::addToolBar(QToolBar *toolbar); QToolBar *QMainWindow::addToolBar(const QString \u0026amp;title); // 将Qt控件放到工具栏中 // 工具栏类: QToolBar // 添加的对象只要是QWidget或者启子类都可以被添加 QAction *QToolBar::addWidget(QWidget *widget); // 添加QAction对象 QAction *QToolBar::addAction(const QString \u0026amp;text); QAction *QToolBar::addAction(const QIcon \u0026amp;icon, const QString \u0026amp;text); // 添加分隔线 QAction *QToolBar::addSeparator() 通过代码的方式对工具栏进行操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); // 添加第二个工具栏 QToolBar *toolbar = new QToolBar(\u0026#34;toolbar\u0026#34;); this-\u0026gt;addToolBar(Qt::LeftToolBarArea, toolbar); toolbar-\u0026gt;addWidget(new QPushButton(\u0026#34;搜索\u0026#34;)); // 给工具栏添加按钮和单行输入框 ui-\u0026gt;toolBar-\u0026gt;addWidget(new QPushButton(\u0026#34;搜索\u0026#34;)); QLineEdit* edit = new QLineEdit; edit-\u0026gt;setMaximumWidth(200); edit-\u0026gt;setFixedWidth(100); ui-\u0026gt;toolBar-\u0026gt;addWidget(edit); // 添加QAction类型的菜单项 ui-\u0026gt;toolBar-\u0026gt;addAction(QIcon(\u0026#34;:/er-dog\u0026#34;), \u0026#34;action\u0026#34;); } 工具栏的属性设置 在UI窗口的树状列表中, 找到工具栏节点, 就可以到的工具栏的属性设置面板了, 这样就可以根据个人需求对工具栏的属性进行设置和修改了。\n在Qt控件的属性窗口中对应了一些属性, 这些属性大部分都应了一个设置函数\n在对应的类中函数名叫什么? 规律: set+属性名 == 函数名 某些属性没有对应的函数, 只能在属性窗口中设置 4.3 状态栏 最下方的信息提示\n一般情况下, 需要在状态栏中添加某些控件, 显示某些属性, 使用最多的就是添加标签 QLabel\n1 2 3 4 5 // 类型: QStatusBar void QStatusBar::addWidget(QWidget *widget, int stretch = 0); [slot] void QStatusBar::clearMessage(); [slot] void QStatusBar::showMessage(const QString \u0026amp;message, int timeout = 0); 相关的操作代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); // 状态栏添加子控件 // 按钮 QPushButton* button = new QPushButton(\u0026#34;按钮\u0026#34;); ui-\u0026gt;statusbar-\u0026gt;addWidget(button); // 标签 QLabel* label = new QLabel(\u0026#34;hello,world\u0026#34;); ui-\u0026gt;statusbar-\u0026gt;addWidget(label); } 也可以通过 showMessage 函数直接显示一些信息：\n1 ui-\u0026gt;statusbar-\u0026gt;showMessage(\u0026#34;show\u0026#34;, 2000); 2000 表示两秒之后信息消失\n要注意如果把 showMessage 放在前面的子控件之前，会产生覆盖，之后通过想显示子控件，需要手动进行显示。\n5秒之后重新显示\n1 2 3 4 QTimer::singleShot(5000, this, [=]() { button-\u0026gt;show(); label-\u0026gt;show(); }); 4.4 停靠窗口 停靠窗口可以通过鼠标拖动停靠到窗口的上、下、左、右，或者浮动在窗口上方。如果需要这种类型的窗口必须手动添加，如果在非QMainWindow类型的窗口中添加了停靠窗口, 那么这个窗口是不能移动和浮动的。 浮动窗口在工具栏中，直接将其拖拽到UI界面上即可。\n停靠窗口也有一个属性面板, 我们可以在其对应属性面板中直接进行设置和修改相关属性。\n5. 资源文件 .qrc 资源文件顾名思义就是一个存储资源的文件，在Qt中引入资源文件好处在于他能提高应用程序的部署效率并且减少一些错误的发生。\n在程序编译过程中， 添加到资源文件中的文件也会以二进制的形式被打包到可执行程序中，这样这些资源就永远和可执行程序捆绑到一起了，不会出现加载资源却找不到的问题。\n虽然资源文件优势很明显，但是它也不是万能的，资源文件中一般添加的都是比较小的资源，比如： 图片，配置文件，MP3 等，如果是类似视频这类比较大的文件就不适合放到资源文件中了。\n比如我们需要给某个窗口设置图标, 代码如下:\n1 2 3 4 5 6 7 8 9 // 创建图标对象 QIcon::QIcon(const QString \u0026amp;fileName); // QWidget类的 公共成员函数 void setWindowIcon(const QIcon \u0026amp;icon); // 给窗口设置图标 // 弊端: 发布的 exe 必须要加载 d:\\\\pic\\\\1.ico 如果当前主机对应的目录中没有图片, 图标就无法被加载 // 发布 exe 需要额外发布图片, 将其部署到某个目录中 setWindowIcon(QIcon(\u0026#34;d:\\\\pic\\\\1.ico\u0026#34;)); 我们可以使用资源文件解决上述的弊端, 这样发布应用程序的时候直接发布程序就可以, 不需要再额外提供图片了。\n下面介绍一下关于资源文件的创建步骤:\n在你的项目根目录下创建一个 resources.qrc 文件，内容如下示例： 1 2 3 4 5 6 \u0026lt;RCC\u0026gt; \u0026lt;qresource prefix=\u0026#34;/images\u0026#34;\u0026gt; \u0026lt;file\u0026gt;images/icon.png\u0026lt;/file\u0026gt; \u0026lt;file\u0026gt;images/background.jpg\u0026lt;/file\u0026gt; \u0026lt;/qresource\u0026gt; \u0026lt;/RCC\u0026gt; 将资源文件添加到CMakeLists.txt 接下来，你需要在 CMakeLists.txt 文件中添加资源文件，以便CMake可以处理它。 假设你的项目结构如下：\n1 2 3 4 5 6 7 my_project/ ├── CMakeLists.txt ├── main.cpp ├── resources.qrc └── images/ ├── icon.png └── background.jpg 在 CMakeLists.txt 中添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cmake_minimum_required(VERSION 3.10) # 设置项目名称 project(MyQtProject) # 查找Qt5模块 find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets) # 添加资源文件 set(CMAKE_AUTORCC ON) set(SOURCES main.cpp resources.qrc ) # 添加可执行文件 add_executable(${PROJECT_NAME} ${SOURCES}) # 链接Qt库 target_link_libraries(${PROJECT_NAME} Qt5::Core Qt5::Gui Qt5::Widgets) 重新构建一下文件，顺利构建说明添加成功\n在qtcreator中添加图标\n这时在选择图标时，可以看到我们添加的文件夹\n","date":"2025-03-19T00:00:00Z","image":"https://serennan.github.io/post/qt-base-5/cover.png","permalink":"https://serennan.github.io/post/qt-base-5/","title":"【Qt 入门】5 基础窗口类"},{"content":"Qt 定时器类 QTimer 在进行窗口程序的处理过程中, 经常要周期性的执行某些操作, 或者制作一些动画效果，看似比较复杂的问题使用定时器就可以完美的解决这些问题， Qt中提供了两种定时器方式一种是使用Qt中的事件处理函数这个在后续章节会给大家做细致的讲解，本节主要给大家介绍一下Qt中的定时器类 QTimer的使用方法。\n要使用它，只需创建一个QTimer类对象，然后调用其 start() 函数开启定时器，此后QTimer对象就会周期性的发出 timeout() 信号。我们先来了解一下这个类的相关API。\n1. public/slot function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 构造函数 // 如果指定了父对象, 创建的堆内存可以自动析构 QTimer::QTimer(QObject *parent = nullptr); // 设置定时器时间间隔为 msec 毫秒 // 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发 void QTimer::setInterval(int msec); // 获取定时器的时间间隔, 返回值单位: 毫秒 int QTimer::interval() const; // 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔 [slot] void QTimer::start(); // 启动或重新启动定时器，超时间隔为msec毫秒。 [slot] void QTimer::start(int msec); // 推荐使用 // 停止定时器。 [slot] void QTimer::stop(); // 设置定时器精度 /* 参数: - Qt::PreciseTimer -\u0026gt; 精确的精度, 毫秒级 - Qt::CoarseTimer -\u0026gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度 - Qt::VeryCoarseTimer -\u0026gt; 非常粗糙的精度, 精度在1秒左右 */ void QTimer::setTimerType(Qt::TimerType atype); Qt::TimerType QTimer::timerType() const;\t// 获取当前定时器的精度 // 如果定时器正在运行，返回true; 否则返回false。 bool QTimer::isActive() const; // 判断定时器是否只触发一次 bool QTimer::isSingleShot() const; // 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false void QTimer::setSingleShot(bool singleShot); 2. signals 这个类的信号只有一个, 当定时器超时时，该信号就会被发射出来。给这个信号通过conect()关联一个槽函数, 就可以在槽函数中处理超时事件了。\n1 [signal] void QTimer::timeout(); 3. static public function 1 2 3 4 5 6 7 8 9 10 11 // 其他同名重载函数可以自己查阅帮助文档 /* 功能: 在msec毫秒后发射一次信号, 并且只发射一次 参数: - msec: 在msec毫秒后发射信号 - receiver: 接收信号的对象地址 - method: 槽函数地址 */ [static] void QTimer::singleShot( int msec, const QObject *receiver, PointerToMemberFunction method); 4. 定时器使用举例 周期性定时器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 创建定时器对象 QTimer* timer = new QTimer(this); // 修改定时器对象的精度 timer-\u0026gt;setTimerType(Qt::PreciseTimer); // 按钮 loopBtn 的点击事件 // 点击按钮启动或者关闭定时器, 定时器启动, 周期性得到当前时间 connect(ui-\u0026gt;loopBtn, \u0026amp;QPushButton::clicked, this, [=]() { // 启动定时器 if(timer-\u0026gt;isActive()) { timer-\u0026gt;stop(); // 关闭定时器 ui-\u0026gt;loopBtn-\u0026gt;setText(\u0026#34;开始\u0026#34;); } else { ui-\u0026gt;loopBtn-\u0026gt;setText(\u0026#34;关闭\u0026#34;); timer-\u0026gt;start(1000); // 1000ms == 1s } }); connect(timer, \u0026amp;QTimer::timeout, this, [=]() { QTime tm = QTime::currentTime(); // 格式化当前得到的系统时间 QString tmstr = tm.toString(\u0026#34;hh:mm:ss.zzz\u0026#34;); // 设置要显示的时间 ui-\u0026gt;curTime-\u0026gt;setText(tmstr); }); 一次性定时器\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 点击按钮 onceBtn 只发射一次信号 // 点击按钮一次, 发射一个信号, 得到某一个时间点的时间 connect(ui-\u0026gt;onceBtn, \u0026amp;QPushButton::clicked, this, [=]() { // 获取2s以后的系统时间, 不创建定时器对象, 直接使用类的静态方法 QTimer::singleShot(2000, this, [=](){ QTime tm = QTime::currentTime(); // 格式化当前得到的系统时间 QString tmstr = tm.toString(\u0026#34;hh:mm:ss.zzz\u0026#34;); // 设置要显示的时间 ui-\u0026gt;onceTime-\u0026gt;setText(tmstr); }); }); ","date":"2025-03-18T00:00:00Z","image":"https://serennan.github.io/post/qt-base-4/cover.png","permalink":"https://serennan.github.io/post/qt-base-4/","title":"【Qt 入门】4 定时器"},{"content":"Qt中的信号槽 1. 信号和槽概述 信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式(发布-订阅模式)。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。\n1.1 信号的本质 信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时候Qt对应的窗口类会发出某个信号，以此对用户的挑选做出反应。\n因此根据上述的描述我们得到一个结论 – 信号的本质就是事件，比如：\n按钮单击、双击 窗口刷新 鼠标移动、鼠标按下、鼠标释放 键盘输入 那么在Qt中信号是通过什么形式呈现给使用者的呢？\n我们对哪个窗口进行操作, 哪个窗口就可以捕捉到这些被触发的事件。 对于使用者来说触发了一个事件，我们就可以得到Qt框架给我们发出的某个特定信号。 信号的呈现形式就是函数， 也就是说某个事件产生了， Qt框架就会调用某个对应的信号函数， 通知使用者。 在QT中信号的发出者是某个实例化的类对象，对象内部可以进行相关事件的检测。\n1.2 槽的本质 在Qt中 槽函数是一类特殊的功能的函数 ，在编码过程中 也可以作为类的普通成员函数来使用 。之所以称之为槽函数是因为它们还有一个职责就是对Qt框架中产生的信号进行处理。\n1 2 举个简单的例子： 女朋友说：“我肚子饿了！”，于是我带她去吃饭。 上边例子中相当于女朋友发出了一个信号， 我收到了信号并其将其处理掉了。\n实例对象 角色 描述 女朋友 信号发出者 信号携带的信息: 我饿了 我 信号接收者 处理女朋友发射的信号: 带他去吃饭 在Qt中槽函数的所有者也是某个类的实例对象。\n1.3 信号和槽的关系 在Qt中信号和槽函数都是独立的个体，本身没有任何联系，但是由于某种特性需求我们可以将二者连接到一起，好比牛郎和织女想要相会必须要有喜鹊为他们搭桥一样。在Qt中我们需要使用 QOjbect 类中的 connect 函数进二者的关联。\n连接信号和槽的 connect() 函数原型如下, 其中 PointerToMemberFunction 是一个指向函数地址的指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 QMetaObject::Connection QObject::connect( const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection); 参数: - sender: 发出信号的对象 - signal: 属于 sender 对象, 信号是一个函数, 这个参数的类型是函数 指针, 信号函数地址 - receiver: 信号接收者 - method: 属于 receiver 对象, 当检测到 sender 发出了signal 信号, receiver 对象调用 method 方法，信号发出之后的处理动作 // 参数 signal 和 method 都是函数地址, 因此简化之后的 connect() 如下: connect(const QObject *sender, \u0026amp;QObject::signal, const QObject *receiver, \u0026amp;QObject::method); 使用connect()进行信号槽连接的注意事项:\nconnect函数相对于做了信号处理动作的注册 调用conenct函数的sender对象的信号并没有产生, 因此receiver对象的method也不会被调用 method槽函数本质是一个回调函数, 调用的时机是信号产生之后, 调用是Qt框架来执行的 connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功 2. 标准信号槽使用 2.1 标准信号/槽 在Qt提供的很多标准类中都可以对用户触发的某些特定事件进行检测, 因此当用户做了这些操作之后, 事件被触发类的内部就会产生对应的信号, 这些信号都是Qt类内部自带的, 因此称之为标准信号。\n同样的，在Qt的很多类内部为我们了提供了很多功能函数，并且这些函数也可以作为触发的信号的处理动作，有这类特性的函数在Qt中称之为标准槽函数。\n系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，这里不过多介绍。\n2.2 使用 掌握标准信号、槽的查找方式之后以及connect()函数的作用之后, 下面通过一个简单的例子给大家讲解一下他们的使用方式。\n1 2 3 4 功能实现： 点击窗口上的按钮, 关闭窗口 功能分析: - 按钮: 信号发出者 -\u0026gt; QPushButton 类型 - 窗口: 信号的接收者和处理者 -\u0026gt; QWidget 类型 需要使用的标准信号槽函数\n1 2 3 4 // 单击按钮发出的信号 [signal] void QAbstractButton::clicked(bool checked = false) // 关闭窗口的槽函数 [slot] bool QWidget::close(); 对于上边的需求只需要一句代码, 只需要写一句代码就能实现了\n1 2 // 单击按钮关闭窗口 connect(ui-\u0026gt;closewindow, \u0026amp;QPushButton::clicked, this, \u0026amp;MainWindow::close); connect()操作一般写在窗口的构造函数中, 相当于在事件产生之前在qt框架中先进行注册, 这样在程序运行过程中假设产生了按钮的点击事件, 框架就会调用信号接收者对象对应的槽函数了, 如果信号不产生, 槽函数也就一直不会被调用。\n3. 自定义信号槽使用 Qt框架提供的信号槽在某些特定场景下是无法满足我们的项目需求的，因此我们还设计自己需要的的信号和槽，同样还是使用connect()对自定义的信号槽进行连接。\n如果想要在QT类中自定义信号槽, 需要满足一些条件, 并且有些事项也需要注意:\n要编写新的类并且让其继承Qt的某些标准类 这个新的子类必须从QObject类或者是QObject子类进行派生 在定义类的头文件中加入 Q_OBJECT 宏 1 2 3 4 5 6 // 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏： class MyMainWindow : public QWidget { Q_OBJECT ...... } 3.1 自定义信号 在Qt中信号的本质是事件, 但是在框架中也是以函数的形式存在的, 只不过信号对应的函数只有声明, 没有定义。如果Qt中的标准信号不能满足我们的需求，可以在程序中进行信号的自定义，当自定义信号对应的事件产生之后，认为的将这个信号发射出去即可（其实就是调用一下这个信号函数）。\n下边给大家阐述一下, 自定义信号的要求和注意事项:\n信号是类的成员函数 返回值必须是 void 类型 信号的名字可以根据实际情况进行指定 参数可以随意指定，信号也支持重载 信号需要使用 signals 关键字进行声明，使用方法类似于 public 等关键字 信号函数只需要声明，不需要定义（没用函数体实现） 在程序中发射自定义信号：发送信号的本质就是调用信号函数 习惯性在信号函数前加关键字：emit，但是可以省略不写 emit 只是显示的声明一下信号要被发射了，没有特殊含义 底层 emit == #define emit 1 2 3 4 5 6 7 8 9 10 11 // 举例: 信号重载 // Qt中的类想要使用信号槽机制必须要从QObject类派生(直接或间接派生都可以) class Test : public QObject { Q_OBJECT signals: void testsignal(); // 参数的作用是数据传递, 谁调用信号函数谁就指定实参 // 实参最终会被传递给槽函数 void testsignal(int a); }; 3.2 自定义槽 槽函数就是信号的处理动作，在Qt中槽函数可以作为普通的成员函数来使用。如果标准槽函数提供的功能满足不了需求，可以自己定义槽函数进行某些特殊功能的实现。自定义槽函数和自定义的普通函数写法是一样的。\n下边给大家阐述一下, 自定义槽的要求和注意事项:\n返回值必须是 void 类型 槽也是函数, 因此也支持重载 槽函数需要指定多少个参数, 需要看连接的信号的参数个数 槽函数的参数是用来接收信号传递的数据的, 信号传递的数据就是信号的参数 1 2 3 举例: 信号函数: void testsig(int a, double b); 槽函数: void testslot(int a, double b); 总结： 槽函数的参数应该和对应的信号的参数个数, 从左到右类型依次对应\n信号的参数可以大于等于槽函数的参数个数 == 信号传递的数据被忽略了\n1 2 信号函数: void testsig(int a, double b); 槽函数: void testslot(int a); Qt中槽函数的类型是多样的 Qt中的槽函数可以是类的成员函数、全局函数、静态函数、Lambda表达式（匿名函数） 槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写) public slots: private slots: –\u0026gt; 这样的槽函数不能在类外部被调用 protected slots: –\u0026gt; 这样的槽函数不能在类外部被调用 1 2 3 4 5 6 7 8 9 10 11 // 槽函数书写格式举例 // 类中的这三个函数都可以作为槽函数来使用 class Test : public QObject { public: void testSlot(); static void testFunc(); public slots: void testSlot(int id); }; 自定义信号槽的使用：\n1 2 还是上边的场景: 女朋友说：“我肚子饿了！”，于是我带她去吃饭。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // class GirlFriend class GirlFriend : public QObject { Q_OBJECT public: explicit GirlFriend(QObject *parent = nullptr); signals: void hungry();\t// 不能表达出想要吃什么 void hungry(QString msg);\t// 可以通过参数表达想要吃什么 }; // class Me class Me : public QObject { Q_OBJECT public: explicit Me(QObject *parent = nullptr); public slots: // 槽函数 void eatMeal(); // 不能知道信号发出者要吃什么 void eatMeal(QString msg); // 可以知道信号发出者要吃什么 }; 4. 信号槽拓展 一个信号可以连接多个槽函数, 发送一个信号有多个处理动作\n需要写多个connect（）连接 信号的接收者可以是一个对象, 也可以是多个对象 一个槽函数可以连接多个信号, 多个不同的信号, 处理动作是相同的\n需要写多个connect（）连接 信号可以连接信号\n信号接收者可以不处理接收的信号, 而是继续发射新的信号，这相当于传递了数据, 并没有对数据进行处理\n1 2 connect(const QObject *sender, \u0026amp;QObject::signal, const QObject *receiver, \u0026amp;QObject::siganl-new); 信号槽是可以断开的\n1 2 disconnect(const QObject *sender, \u0026amp;QObject::signal, const QObject *receiver, \u0026amp;QObject::method); 5. Lambda 表达式 Lambda表达式是 C++ 11 最重要也是最常用的特性之一，是现代编程语言的一个特点，简洁，提高了代码的效率并且可以使程序更加灵活，Qt是完全支持c++语法的， 因此在Qt中也可以使用Lambda表达式。\n5.1 语法格式 Lambda表达式就是一个匿名函数， 语法格式如下：\n1 2 3 4 5 6 [capture](params) opt -\u0026gt; ret {body;}; - capture: 捕获列表 - params: 参数列表 - opt: 函数选项 - ret: 返回值类型 - body: 函数体 关于Lambda表达式的细节介绍:\n捕获列表: 捕获一定范围内的变量 [] - 不捕捉任何变量 [\u0026amp;] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获) [=] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获) 拷贝的副本在匿名函数体内部是只读的 [=, \u0026amp;foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo [bar] - 按值捕获 bar 变量, 同时不捕获其他变量 [\u0026amp;bar] - 按引用捕获 bar 变量, 同时不捕获其他变量 [this] - 捕获当前类中的this指针 让lambda表达式拥有和当前类成员函数同样的访问权限 如果已经使用了 \u0026amp; 或者 =, 默认添加此选项 参数列表: 和普通函数的参数列表一样\nopt 选项 –\u0026gt; 可以省略\nmutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身） exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(); 返回值类型: 标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略 函数体: 函数的实现，这部分不能省略，但函数体可以为空。 5.2 定义和调用 因为Lambda表达式是一个匿名函数, 因此是没有函数声明的, 直接在程序中进行代码的定义即可, 但是如果只定义匿名函数在程序执行过程中是不会被调用的。\n1 2 3 4 5 6 7 8 9 // 匿名函数的定义, 程序执行这个匿名函数是不会被调用的 [](){ qDebug() \u0026lt;\u0026lt; \u0026#34;hello, 我是一个lambda表达式...\u0026#34;; }; // 调用匿名函数 [](){ qDebug() \u0026lt;\u0026lt; \u0026#34;hello, 我是一个lambda表达式...\u0026#34;; }(); 在Lambda表达式的捕获列表中也就是 [] 内部添加不同的关键字, 就可以在函数体中使用外部变量了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 在匿名函数外部定义变量 int a=100, b=200, c=300; // 调用匿名函数 [](){ // 打印外部变量的值 qDebug() \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, c:\u0026#34; \u0026lt;\u0026lt; c; // error, 不能使用任何外部变量 } [\u0026amp;](){ qDebug() \u0026lt;\u0026lt; \u0026#34;hello, 我是一个lambda表达式...\u0026#34;; qDebug() \u0026lt;\u0026lt; \u0026#34;使用引用的方式传递数据: \u0026#34;; qDebug() \u0026lt;\u0026lt; \u0026#34;a+1:\u0026#34; \u0026lt;\u0026lt; a++ \u0026lt;\u0026lt; \u0026#34;, b+c= \u0026#34; \u0026lt;\u0026lt; b+c; }(); // 值拷贝的方式使用外部数据 [=](int m, int n)mutable{ qDebug() \u0026lt;\u0026lt; \u0026#34;hello, 我是一个lambda表达式...\u0026#34;; qDebug() \u0026lt;\u0026lt; \u0026#34;使用拷贝的方式传递数据: \u0026#34;; // 拷贝的外部数据在函数体内部是只读的, 如果不添加 mutable 关键字是不能修改这些只读数据的值的 // 添加 mutable 允许修改的数据是拷贝到函数内部的副本, 对外部数据没有影响 qDebug() \u0026lt;\u0026lt; \u0026#34;a+1:\u0026#34; \u0026lt;\u0026lt; a++ \u0026lt;\u0026lt; \u0026#34;, b+c= \u0026#34; \u0026lt;\u0026lt; b+c; qDebug() \u0026lt;\u0026lt; \u0026#34;m+1: \u0026#34; \u0026lt;\u0026lt; ++m \u0026lt;\u0026lt; \u0026#34;, n: \u0026#34; \u0026lt;\u0026lt; n; }(1, 2); Qt 中的应用\n1 2 3 connect(ui-\u0026gt;hungry, \u0026amp;QPushButton::clicked, this, [=]() { m_girlfriend-\u0026gt;hungry(\u0026#34;意大利面\u0026#34;); }); ","date":"2025-03-17T00:00:00Z","image":"https://serennan.github.io/post/qt-base-3/cover.png","permalink":"https://serennan.github.io/post/qt-base-3/","title":"【Qt 入门】3 信号槽"},{"content":"1. 两数之和 Leetcode 1 题，两数之和,难度 Easy\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案，有效答案只有一个\n这道题的解题思路比较简单，但是要熟悉哈希表和迭代器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int, int\u0026gt; hashtable; for (int i = 0; i \u0026lt; nums.size(); ++i) { auto it = hashtable.find(target - nums[i]); if (it != hashtable.end()) { return {it-\u0026gt;second, i}; } hashtable[nums[i]] = i; } return {}; } }; TODO 其他题\n","date":"2025-03-14T00:00:00Z","image":"https://serennan.github.io/post/leetcode-hashtable/cover.png","permalink":"https://serennan.github.io/post/leetcode-hashtable/","title":"哈希表"},{"content":"由于插件 Qt Configure 帮我们创建的文件全都丢在 src 文件夹下，这时如果创建多个窗口类，工程结构就显得复杂。所以本次博客帮助大家完善一下工程结构。\n特别鸣谢小伙伴 YusJade 帮我解决结构调整带来的问题。\n博客链接：CMake + Qt 无法编译.ui 文件的解决办法\nQt 项目工程结构调整 工程结构 将头文件，源文件和ui文件分别放到对应文件夹：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ├── include │ ├── dialog.h │ ├── mainwindow.h │ └── widget.h ├── src │ ├── dialog.cpp │ ├── main.cpp │ ├── mainwindow.cpp │ └── widget.cpp ├── ui │ ├── dialog.ui │ ├── mainwindow.ui │ └── widget.ui CMakeLists.txt 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 cmake_minimum_required(VERSION 3.20) # CMake install : https://cmake.org/download/ project(mainwindow LANGUAGES CXX) set(CMAKE_INCLUDE_CURRENT_DIR ON) set(CMAKE_PREFIX_PATH \u0026#34;/usr/local/Qt/Qt6.5.3/6.5.3/gcc_64\u0026#34;) # Qt Kit Dir set(CMAKE_AUTOUIC ON) set(CMAKE_AUTOMOC ON) set(CMAKE_AUTORCC ON) set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED ON) find_package(Qt6 COMPONENTS Widgets REQUIRED) # Qt COMPONENTS # aux_source_directory(./src srcs) set(SOURCE ${CMAKE_SOURCE_DIR}/src/main.cpp ${CMAKE_SOURCE_DIR}/src/mainwindow.cpp ${CMAKE_SOURCE_DIR}/src/widget.cpp ${CMAKE_SOURCE_DIR}/src/dialog.cpp ) set(INCLUDE ${CMAKE_SOURCE_DIR}/include/dialog.h ${CMAKE_SOURCE_DIR}/include/mainwindow.h ${CMAKE_SOURCE_DIR}/include/widget.h ) set(CMAKE_AUTOUIC_SEARCH_PATHS ${CMAKE_SOURCE_DIR}/ui) # 需要添加这个 set(UI_FILES ${CMAKE_SOURCE_DIR}/ui/dialog.ui ${CMAKE_SOURCE_DIR}/ui/mainwindow.ui ${CMAKE_SOURCE_DIR}/ui/widget.ui ) add_compile_options(\u0026#34;$\u0026lt;$\u0026lt;C_COMPILER_ID:MSVC\u0026gt;:/utf-8\u0026gt;\u0026#34;) add_compile_options(\u0026#34;$\u0026lt;$\u0026lt;CXX_COMPILER_ID:MSVC\u0026gt;:/utf-8\u0026gt;\u0026#34;) add_executable(${PROJECT_NAME} WIN32 ${SOURCE} ${INCLUDE} # 需要把包含了 ui 文件的头文件加进来 ${UI_FILES} ) target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/include ) target_link_libraries(${PROJECT_NAME} PRIVATE Qt6::Widgets) # Qt5 Shared Library ","date":"2025-03-12T00:00:00Z","image":"https://serennan.github.io/post/qt-structure/cover.png","permalink":"https://serennan.github.io/post/qt-structure/","title":"【Qt 配置】工程结构调整"},{"content":"Qt中的基础数据类型 1. QByteArray 在Qt中QByteArray可以看做是c语言中 char*的升级版本。我们在使用这种类型的时候可通过这个类的构造函数申请一块动态内存，用于存储我们需要处理的字符串数据。\n下面给大家介绍一下这个类中常用的一些API函数，大家要养成遇到问题主动查询帮助文档的好习惯。\n构造函数 1 2 3 4 5 6 7 // 构造空对象, 里边没有数据 QByteArray::QByteArray(); // 将data中的size个字符进行构造, 得到一个字节数组对象 // 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data) QByteArray::QByteArray(const char *data, int size = -1); // 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组 QByteArray::QByteArray(int size, char ch); 数据操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 在尾部追加数据 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray \u0026amp;QByteArray::append(const QByteArray \u0026amp;ba); void QByteArray::push_back(const QByteArray \u0026amp;other); // 头部添加数据 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray \u0026amp;QByteArray::prepend(const QByteArray \u0026amp;ba); void QByteArray::push_front(const QByteArray \u0026amp;other); // 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始) // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray \u0026amp;QByteArray::insert(int i, const QByteArray \u0026amp;ba); // 删除数据 // 从大字符串中删除len个字符, 从第pos个字符的位置开始删除 QByteArray \u0026amp;QByteArray::remove(int pos, int len); // 从字符数组的尾部删除 n 个字节 void QByteArray::chop(int n); // 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除) void QByteArray::truncate(int pos); // 将对象中的数据清空, 使其为null void QByteArray::clear(); // 字符串替换 // 将字节数组中的 子字符串 before 替换为 after // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray \u0026amp;QByteArray::replace(const QByteArray \u0026amp;before, const QByteArray \u0026amp;after); 子字符串查找和判断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false bool QByteArray::contains(const QByteArray \u0026amp;ba) const; bool QByteArray::contains(const char *ba) const; // 判断字节数组中是否包含子字符 ch, 包含返回true, 否则返回false bool QByteArray::contains(char ch) const; // 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false bool QByteArray::startsWith(const QByteArray \u0026amp;ba) const; bool QByteArray::startsWith(const char *ba) const; // 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false bool QByteArray::startsWith(char ch) const; // 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false bool QByteArray::endsWith(const QByteArray \u0026amp;ba) const; bool QByteArray::endsWith(const char *ba) const; // 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false bool QByteArray::endsWith(char ch) const; 遍历 1 2 3 4 5 6 7 8 9 // 使用迭代器 iterator QByteArray::begin(); iterator QByteArray::end(); // 使用数组的方式进行遍历 // i的取值范围 0 \u0026lt;= i \u0026lt; size() // 用的更多 char QByteArray::at(int i) const; char QByteArray::operator[](int i) const; 查看字节数 1 2 3 4 5 6 7 8 9 10 // 返回字节数组对象中字符的个数 int QByteArray::length() const; int QByteArray::size() const; int QByteArray::count() const; // 返回字节数组对象中 子字符串ba 出现的次数 int QByteArray::count(const QByteArray \u0026amp;ba) const; int QByteArray::count(const char *ba) const; // 返回字节数组对象中 字符串ch 出现的次数 int QByteArray::count(char ch) const; 类型转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 将QByteArray类型的字符串 转换为 char* 类型 char *QByteArray::data(); const char *QByteArray::data() const; // int, short, long, float, double -\u0026gt; QByteArray // 其他重载的同名函数可参考Qt帮助文档, 此处略 QByteArray \u0026amp;QByteArray::setNum(int n, int base = 10); QByteArray \u0026amp;QByteArray::setNum(short n, int base = 10); QByteArray \u0026amp;QByteArray::setNum(qlonglong n, int base = 10); QByteArray \u0026amp;QByteArray::setNum(float n, char f = \u0026#39;g\u0026#39;, int prec = 6); QByteArray \u0026amp;QByteArray::setNum(double n, char f = \u0026#39;g\u0026#39;, int prec = 6); [static] QByteArray QByteArray::number(int n, int base = 10); [static] QByteArray QByteArray::number(qlonglong n, int base = 10); [static] QByteArray QByteArray::number(double n, char f = \u0026#39;g\u0026#39;, int prec = 6); // QByteArray -\u0026gt; int, short, long, float, double int QByteArray::toInt(bool *ok = Q_NULLPTR, int base = 10) const; short QByteArray::toShort(bool *ok = Q_NULLPTR, int base = 10) const; long QByteArray::toLong(bool *ok = Q_NULLPTR, int base = 10) const; float QByteArray::toFloat(bool *ok = Q_NULLPTR) const; double QByteArray::toDouble(bool *ok = Q_NULLPTR) const; // std::string -\u0026gt; QByteArray [static] QByteArray QByteArray::fromStdString(const std::string \u0026amp;str); // QByteArray -\u0026gt; std::string std::string QByteArray::toStdString() const; // 所有字符转换为大写 QByteArray QByteArray::toUpper() const; // 所有字符转换为小写 QByteArray QByteArray::toLower() const; 2. QString QString也是封装了字符串, 但是内部的编码为utf8, UTF-8属于Unicode字符集, 它固定使用多个字节（window为2字节, linux为3字节）来表示一个字符，这样可以将世界上几乎所有语言的常用字符收录其中。\n下面给大家介绍一下这个类中常用的一些API函数。\n构造函数 1 2 3 4 5 6 7 // 构造一个空字符串对象 QString::QString(); // 将 char* 字符串 转换为 QString 类型 QString::QString(const char *str); // 将 QByteArray 转换为 QString 类型 QString::QString(const QByteArray \u0026amp;ba); // 其他重载的同名构造函数可参考Qt帮助文档, 此处略 数据操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 尾部追加数据 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QString \u0026amp;QString::append(const QString \u0026amp;str); QString \u0026amp;QString::append(const char *str); QString \u0026amp;QString::append(const QByteArray \u0026amp;ba); void QString::push_back(const QString \u0026amp;other); // 头部添加数据 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QString \u0026amp;QString::prepend(const QString \u0026amp;str); QString \u0026amp;QString::prepend(const char *str); QString \u0026amp;QString::prepend(const QByteArray \u0026amp;ba); void QString::push_front(const QString \u0026amp;other); // 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始) // 其他重载的同名函数可参考Qt帮助文档, 此处略 QString \u0026amp;QString::insert(int position, const QString \u0026amp;str); QString \u0026amp;QString::insert(int position, const char *str); QString \u0026amp;QString::insert(int position, const QByteArray \u0026amp;str); // 删除数据 // 从大字符串中删除len个字符, 从第pos个字符的位置开始删除 QString \u0026amp;QString::remove(int position, int n); // 从字符串的尾部删除 n 个字符 void QString::chop(int n); // 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除) void QString::truncate(int position); // 将对象中的数据清空, 使其为null void QString::clear(); // 字符串替换 // 将字节数组中的 子字符串 before 替换为 after // 参数 cs 为是否区分大小写, 默认区分大小写 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QString \u0026amp;QString::replace(const QString \u0026amp;before, const QString \u0026amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive); 子字符串查找和判断 1 2 3 4 5 6 7 8 9 10 11 // 参数 cs 为是否区分大小写, 默认区分大小写 // 其他重载的同名函数可参考Qt帮助文档, 此处略 // 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false bool QString::contains(const QString \u0026amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; // 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false bool QString::startsWith(const QString \u0026amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; // 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false bool QString::endsWith(const QString \u0026amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; 遍历 1 2 3 4 5 6 7 8 // 使用迭代器 iterator QString::begin(); iterator QString::end(); // 使用数组的方式进行遍历 // i的取值范围 0 \u0026lt;= position \u0026lt; size() const QChar QString::at(int position) const const QChar QString::operator[](int position) const; 查看字节数 1 2 3 4 5 6 7 8 // 返回字节数组对象中字符的个数 (字符个数和字节个数是不同的概念) int QString::length() const; int QString::size() const; int QString::count() const; // 返回字节串对象中 子字符串 str 出现的次数 // 参数 cs 为是否区分大小写, 默认区分大小写 int QString::count(const QStringRef \u0026amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; 类型转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 将int, short, long, float, double 转换为 QString 类型 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QString \u0026amp;QString::setNum(int n, int base = 10); QString \u0026amp;QString::setNum(short n, int base = 10); QString \u0026amp;QString::setNum(long n, int base = 10); QString \u0026amp;QString::setNum(float n, char format = \u0026#39;g\u0026#39;, int precision = 6); QString \u0026amp;QString::setNum(double n, char format = \u0026#39;g\u0026#39;, int precision = 6); [static] QString QString::number(long n, int base = 10); [static] QString QString::number(int n, int base = 10); [static] QString QString::number(double n, char format = \u0026#39;g\u0026#39;, int precision = 6); // 将 QString 转换为 int, short, long, float, double 类型 int QString::toInt(bool *ok = Q_NULLPTR, int base = 10) const; short QString::toShort(bool *ok = Q_NULLPTR, int base = 10) const; long QString::toLong(bool *ok = Q_NULLPTR, int base = 10) const float QString::toFloat(bool *ok = Q_NULLPTR) const; double QString::toDouble(bool *ok = Q_NULLPTR) const; // 将标准C++中的 std::string 类型 转换为 QString 类型 [static] QString QString::fromStdString(const std::string \u0026amp;str); // 将 QString 转换为 标准C++中的 std::string 类型 std::string QString::toStdString() const; // QString -\u0026gt; QByteArray // 转换为本地编码, 跟随操作系统 QByteArray QString::toLocal8Bit() const; // 转换为 Latin-1 编码的字符串 不支持中文 QByteArray QString::toLatin1() const; // 转换为 utf8 编码格式的字符串 (常用) QByteArray QString::toUtf8() const; // 所有字符转换为大写 QString QString::toUpper() const; // 所有字符转换为小写 QString QString::toLower() const; 字符串格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 其他重载的同名函数可参考Qt帮助文档, 此处略 QString QString::arg(const QString \u0026amp;a, int fieldWidth = 0, QChar fillChar = QLatin1Char( \u0026#39; \u0026#39; )) const; QString QString::arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( \u0026#39; \u0026#39; )) const; // 示例程序 int i; // 假设该变量表示当前文件的编号 int total; // 假设该变量表示文件的总个数 QString fileName; // 假设该变量表示当前文件的名字 // 使用以上三个变量拼接一个动态字符串 QString status = QString(\u0026#34;Processing file %1 of %2: %3\u0026#34;) .arg(i).arg(total).arg(fileName); 3. QVariant QVariant这个类很神奇，或者说方便。很多时候，需要几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而QVariant则可以统统搞定。\nQVariant 这个类型充当着最常见的数据类型的联合。QVariant 可以保存很多Qt的数据类型，包括QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、 QPalette、QPen、QPixmap、QPoint、QRect、QRegion、QSize和QString，并且还有C++基本类型，如 int、float等。\n标准类型 将标准类型转换为 QVariant 类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 这类转换需要使用QVariant类的构造函数, 由于比较多, 大家可自行查阅Qt帮助文档, 在这里简单写几个 QVariant::QVariant(int val); QVariant::QVariant(bool val); QVariant::QVariant(double val); QVariant::QVariant(const char *val); QVariant::QVariant(const QByteArray \u0026amp;val); QVariant::QVariant(const QString \u0026amp;val); ...... // 使用设置函数也可以将支持的类型的数据设置到QVariant对象中 // 这里的 T 类型, 就是QVariant支持的类型 void QVariant::setValue(const T \u0026amp;value); // 该函数行为和 setValue() 函数完全相同 [static] QVariant QVariant::fromValue(const T \u0026amp;value); // 例子: #if 1 QVariant v; v.setValue(5); #else QVariant v = QVariant::fromValue(5); #endif int i = v.toInt(); // i is now 5 QString s = v.toString(); // s is now \u0026#34;5\u0026#34; 判断 QVariant 中封装的实际数据类型\n1 QVariant::typeId() == QMetaType::type 将QVariant对象转换为实际的数据类型\n1 2 3 4 5 6 7 8 9 // 如果要实现该操作, 可以使用QVariant类提供的 toxxx() 方法, 全部转换可以参考Qt帮助文档 // 在此举列举几个常用函数: bool QVariant::toBool() const; QByteArray QVariant::toByteArray() const; double QVariant::toDouble(bool *ok = Q_NULLPTR) const; float QVariant::toFloat(bool *ok = Q_NULLPTR) const; int QVariant::toInt(bool *ok = Q_NULLPTR) const; QString QVariant::toString() const; ...... 演示代码 头文件\n1 QVariant dataPlus(QVariant a, QVariant b); 源文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026#34;MainWindow.h\u0026#34; #include \u0026lt;qcontainerinfo.h\u0026gt; #include \u0026lt;qdebug.h\u0026gt; #include \u0026lt;qglobal.h\u0026gt; #include \u0026lt;qobjectdefs.h\u0026gt; #include \u0026lt;qvariant.h\u0026gt; MainWindow::MainWindow(QWidget* parent) : QMainWindow(parent) , ui(new Ui_MainWindow) { ui-\u0026gt;setupUi(this); int value = dataPlus(10, 20).toInt(); QString str = dataPlus(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;).toString(); qDebug() \u0026lt;\u0026lt; \u0026#34;Int :\u0026#34; \u0026lt;\u0026lt; value; qDebug() \u0026lt;\u0026lt; \u0026#34;String :\u0026#34; \u0026lt;\u0026lt; str; } MainWindow::~MainWindow() { delete ui; } QVariant MainWindow::dataPlus(QVariant a, QVariant b) { QVariant ans; if (a.typeId() == QMetaType::Int \u0026amp;\u0026amp; b.typeId() == QMetaType::Int) { ans = QVariant(a.toInt() + b.toInt()); } else if (a.typeId() == QMetaType::QString \u0026amp;\u0026amp; b.typeId() == QMetaType::QString) { ans.setValue(a.toString() + b.toString()); } return ans; } 我用的是qt6，有些函数已被弃用，所以具体代码和视频讲解的有些不同\n自定义类型 除了标准类型, 我们自定义的类型也可以使用QVariant类进行封装, 被QVariant存储的数据类型需要有一个默认的构造函数和一个拷贝构造函数。为了实现这个功能，首先必须使用Q_DECLARE_METATYPE()宏。通常会将这个宏放在类的声明所在头文件的下面， 原型为：\n1 Q_DECLARE_METATYPE(Type) 使用的具体步骤如下:\n在头文件中声明 1 2 3 4 5 6 7 struct Person { int id; QString name; }; // 自定义类型注册 Q_DECLARE_METATYPE(Person) 在源文件中定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Person p; p.id = 10; p.name = \u0026#34;person\u0026#34;; #if 0 QVariant v; v.setValue(p); #else QVariant v = QVariant::fromValue(p); #endif // 提取出 v 对象中的数据 if (v.canConvert\u0026lt;Person\u0026gt;()) { Person tmp = v.value\u0026lt;Person\u0026gt;(); qDebug() \u0026lt;\u0026lt; tmp.id \u0026lt;\u0026lt; tmp.name; } canConvert函数官方文档：\n1 2 3 4 5 6 7 8 QVariant v = 42; v.canConvert\u0026lt;int\u0026gt;(); // return true v.canConvert\u0026lt;QString\u0026gt;(); // return true MyCustomStruct s; v.setValue(s); v.canConvert\u0026lt;int\u0026gt;(); // return false v.canConvert\u0026lt;MyCustomStruct\u0026gt;(); // return true ","date":"2025-03-12T00:00:00Z","image":"https://serennan.github.io/post/qt-base-2/cover.png","permalink":"https://serennan.github.io/post/qt-base-2/","title":"【Qt 入门】2 基础数据类型"},{"content":"Qt 入门 这一系列Qt知识的笔记是根据爱编程的大丙所写，写的很详细，也有对应的视频讲解。\n我也根据视频写了对应的练习代码，仓库地址：QtLearn\n第一个Qt项目 这里我为了与视频文件名对应，重新创了一个项目，项目名字是 mainwindow\nmain.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;mainwindow.h\u0026#34; #include \u0026lt;QApplication\u0026gt; #pragma comment(lib, \u0026#34;user32.lib\u0026#34;) int main(int argc, char *argv[]) { // 创建应用程序对象, 在一个Qt项目中实例对象有且仅有一个 // 类的作用: 检测触发的事件, 进行事件循环并处理 QApplication a(argc, argv); // 创建窗口对象 mainwindow w; // 显示窗口 w.show(); // 阻塞函数，应用程序对象开始事件循环，保证应用程序不退出 return a.exec(); } mainwindow.ui 在Qt中每一个窗口都对应一个可编辑的可视化界面（*.ui）, 这个界面对应的是一个xml格式的文件, 一般情况下不需要在xml格式下对这个文件进行编辑, 关于这个文件结构了解即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;ui version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;class\u0026gt;mainwindow\u0026lt;/class\u0026gt; \u0026lt;widget class=\u0026#34;QMainWindow\u0026#34; name=\u0026#34;mainwindow\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;geometry\u0026#34;\u0026gt; \u0026lt;rect\u0026gt; \u0026lt;x\u0026gt;0\u0026lt;/x\u0026gt; \u0026lt;y\u0026gt;0\u0026lt;/y\u0026gt; \u0026lt;width\u0026gt;800\u0026lt;/width\u0026gt; \u0026lt;height\u0026gt;600\u0026lt;/height\u0026gt; \u0026lt;/rect\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;windowTitle\u0026#34;\u0026gt; \u0026lt;string\u0026gt;mainwindow\u0026lt;/string\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;widget class=\u0026#34;QWidget\u0026#34; name=\u0026#34;centralwidget\u0026#34;/\u0026gt; \u0026lt;widget class=\u0026#34;QMenuBar\u0026#34; name=\u0026#34;menubar\u0026#34;/\u0026gt; \u0026lt;widget class=\u0026#34;QStatusBar\u0026#34; name=\u0026#34;statusbar\u0026#34;/\u0026gt; \u0026lt;/widget\u0026gt; \u0026lt;resources/\u0026gt; \u0026lt;connections/\u0026gt; \u0026lt;/ui\u0026gt; mainwindow.h 这个文件是窗口界面对应的类的头文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #pragma once #include \u0026#34;ui_mainwindow.h\u0026#34; #include \u0026lt;QMainWindow\u0026gt; // Qt 标准窗口类头文件 class mainwindow : public QMainWindow { Q_OBJECT; // 这个宏是为了能够使用Qt中的信号槽机制 public: mainwindow(QWidget *parent = nullptr); ~mainwindow(); private: Ui_mainwindow *ui; // 定义指针指向窗口的 UI 对象 }; mainwindow.cpp 这个文件是窗口界面对应的类的源文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;mainwindow.h\u0026#34; mainwindow::mainwindow(QWidget* parent) : QMainWindow(parent) , ui(new Ui_mainwindow) // 基于 mainwindow.ui 创建一个实例对象 { // 将 mainwindow.ui 的示例对象和当前类的对象进行关联 ui-\u0026gt;setupUi(this); } mainwindow::~mainwindow() { delete ui; } Qt 窗口类 基础窗口类 常用的窗口类有3个\n在创建Qt窗口的时候, 需要让自己的窗口类继承上述三个窗口类的其中一个\nQWidget\n所有窗口类的基类\nQt中的控件(按钮, 输入框, 单选框…)也属于窗口, 基类都是 QWidget\n可以内嵌到其他窗口中: 没有边框 可以不内嵌单独显示: 独立的窗口, 有边框\nQDialog\n对话框类, 后边的章节会具体介绍这个窗口 不能内嵌到其他窗口中\nQMainWindow\n有工具栏, 状态栏, 菜单栏, 后边的章节会具体介绍这个窗口不能内嵌到其他窗口中 QWidget 所有窗口的基类\n内嵌窗口\n依附于某一个大的窗口, 作为了大窗口的一部分 大窗口就是这个内嵌窗口的父窗口 父窗口显示的时候, 内嵌的窗口也就被显示出来了 不内嵌窗口\n这类窗口有边框, 有标题栏 需要调用函数才可以显示 代码 由于我们使用的是 cmake 构建项目，即使使用的是Qtcreator，也没法跟视频一样直接添加一个新文件，所以我们只能手动添加。\n不过依然可以在 VScode使用Qtconfigure快速构建一个新的项目，命名为widget好了，但是需要做一些修改：\nwidget.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #pragma once #include \u0026#34;ui_widget.h\u0026#34; #include \u0026lt;QWidget\u0026gt; class widget : public QWidget // 继承 QWidget 而不是 QMainWindow { Q_OBJECT public: widget(QWidget *parent = nullptr); ~widget(); private: Ui_widget *ui; }; widget.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026#34;widget.h\u0026#34; widget::widget(QWidget *parent) : QWidget(parent), // 初始化列表也要记得修改类型 ui(new Ui_widget) { ui-\u0026gt;setupUi(this); } widget::~widget() { delete ui; } widget.ui\n1 \u0026lt;widget class=\u0026#34;QWidget\u0026#34; name=\u0026#34;newwindow\u0026#34;\u0026gt; 要修改成 QWidget\nmainwindow.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026#34;mainwindow.h\u0026#34; #include \u0026#34;src/newwindow.h\u0026#34; mainwindow::mainwindow(QWidget *parent) : QMainWindow(parent), ui(new Ui_mainwindow) // 基于 mainwindow.ui 创建一个实例对象 { // 将 mainwindow.ui 的示例对象和当前类的对象进行关联 ui-\u0026gt;setupUi(this); // 一般在 qt 的构造函数中进行初始化操作（窗口，数据，...） // 显示当前窗口的时候，显示另外一个窗口 NewWindow #if 0 // 创建窗口对象，没有给 w 对象指定父对象 newwindow *w = new newwindow; w-\u0026gt;show(); #else // 创建窗口对象，没有给 w 对象指定父对象 // newwindow(QWidget* parent = nullptr); newwindow *w = new newwindow(this); #endif } mainwindow::~mainwindow() { delete ui; } QDialog 对话框窗口类\n有模态和非模态两种\n不能内嵌\n代码 1 2 3 4 5 6 7 8 9 10 11 12 #if 0 // 创建对话框窗口 dialog *dlg = new dialog(this); // 非模态 dlg-\u0026gt;show(); #else // 创建对话框窗口 dialog *dlg = new dialog(this); // 模态,exec() // 阻塞程序运行 dlg-\u0026gt;exec(); #endif 使用模态时，启动程序发现只有两个子窗口，主窗口没显示，这是因为 exec() 函数阻塞程序运行，导致主窗口的构造函数没有运行完。\n且这时候我们无法关闭 widget 窗口，只有当我们把dialog窗口关闭时，widget窗口才能被聚焦，且主窗口也会显示。\nQMainWindow 具有菜单栏，工具栏，状态栏\n工程结构调整 太多窗口类堆在src文件夹下可能难以维护，所以可以看这篇文章调整一下工程结构： 【Qt配置】工程结构调整\n","date":"2025-03-09T00:00:00Z","image":"https://serennan.github.io/post/qt-base-1/cover.png","permalink":"https://serennan.github.io/post/qt-base-1/","title":"【Qt 入门】1 入门"},{"content":"VS 配置 Qt6 教程 雷神后面的视频是要开发一个图形界面，这里我使用vscode + qt + cmake来开发。\n1. 安装qt6 这里网上很多教程，推荐一个 CSDN 上的教程：Qt6入门教程 2：Qt6下载与安装\n主要区别是我下载的是 linux版本\n以及选择组件时，我使用的是6.5.3版本\n2. 安装插件 vscode安装好 Qt Tools 和 Qt Configure 这两个插件，并配置一下Qt Configure。\n注意这里的Qt Dir 存放的是安装好的qt的根目录，我这里多一个 Qt文件夹是因为我下载了多个版本的qt\n3. 启动项目 打开一个空文件夹，按下shift + ctrl + p 输入指令：\n1 QtConfigure:New Project 然后根据提示，项目名字 -\u0026gt; qt 组件 -\u0026gt; cmake -\u0026gt; 是否生成 ui 文件\n然后会生成下面这些文件\n1 2 3 4 5 6 7 . ├── CMakeLists.txt └── src ├── ffmpeg_qt.cpp ├── ffmpeg_qt.h ├── ffmpeg_qt.ui └── main.cpp 注意这里打开 CMakeLists.txt 文件会发现用的是 Qt5 的东西\n但我下载的是 Qt6 ，所以这里得改成 Qt6\n接下来用 CMake 来配置项目，按下shift + ctrl + p 输入指令：\n1 CMake：Configure with CMake Debugger 配置完运行项目\n出现窗口说明配置成功\n4. 单独修改ui界面 右键 ui 文件选择 Edit in Qt Designer 可以修改 ui 文件\n拖入一个按钮检验一下，保存并退出，再去查看ui文件会发现已经帮我们加上相应的代码，重新运行项目\n问题 如果没有出现窗口，可能还需要安装一个 VcXsrv\n后续再找时间写一个安装教程，这里先放一个别人的视频教程：\n","date":"2025-03-08T00:00:00Z","image":"https://serennan.github.io/post/qt-configure/cover.png","permalink":"https://serennan.github.io/post/qt-configure/","title":"【Qt 配置】 VS + Qt6"},{"content":"本文参考：我写了一首诗，把滑动窗口算法变成了默写题\n算法逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 int left = 0, right = 0; while (right \u0026lt; s.size()) { // 增大窗口 window.add(s[right]); right++; while (window needs shrink) { // 缩小窗口 window.remove(s[left]); left++; } } 这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。\n其实最主要的是细节问题：比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。\n代码框架 下面是一套滑动窗口算法的代码框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 滑动窗口算法框架 */ void slidingWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(\u0026#34;window: [%d, %d)\\n\u0026#34;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) { // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 ... } } } 其中两处 \u0026hellip; 表示的更新窗口数据的地方，直接往里面填就行\n而且，这两个 \u0026hellip; 处的操作分别是右移和左移窗口更新操作，会发现它们操作是完全对称的。\n下面四道 LeetCode 原题来套这个框架\n一 最小覆盖子串 LeetCode 76 题，最小覆盖子串，难度 Hard：\n就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。\n如果使用暴力解法，代码大概是这样的：\n1 2 3 4 for (int i = 0; i \u0026lt; s.size(); i++) for (int j = i + 1; j \u0026lt; s.size(); j++) if s[i:j] 包含 t 的所有字母: 更新答案 思路虽然简单，但是算法复杂度大于 O(N2)\n滑动窗口算法的思路是这样：\n1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。\n2、我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。\n3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。\n下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和「窗口」中的相应字符的出现次数。\n初始状态：\n增加 right，直到窗口 [left, right) 包含了 T 中所有字符：\n现在开始增加 left，缩小窗口 [left, right)：\n直到窗口中的字符串不再符合要求，left 不再继续移动：\n之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。\n上述过程就是滑动串口的算法思想，现在来看这个滑动窗口代码框架如何使用：\n首先，初始化 window 和 need 两个哈希表，记录窗口中的字符和需要凑齐的字符：\n1 2 unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; 然后，使用 left 和 right 变量初始化窗口的两端，不要忘了，区间 [left, right) 是左闭右开的，所以初始情况下窗口没有包含任何元素：\n1 2 3 4 5 int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { // 开始滑动 } 其中 valid 变量表示窗口中满足 need 条件的字符个数，如果 valid 和 need.size 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 T。\n现在开始套模板，只需要思考以下四个问题：\n当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？\n什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？\n当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？\n我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？ 如果一个字符进入窗口，应该增加 window 计数器；如果一个字符将移出窗口的时候，应该减少 window 计数器；当 valid 满足 need 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。\n这里示例就用前面的图：\n1 2 S {E, B, B, A, N, C, F} T {A, B, C} 完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 string minWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; // need {A : 1, B : 1, C : 1} for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引及长度 int start = 0, len = INT_MAX; while (right \u0026lt; s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; // window{A : 1, B : 1, C : 0} valid = 2 if (window[c] == need[c]) { valid++; } } // 判断左侧窗口是否要收缩 while (valid == need.size()) { // 在这里更新最小覆盖子串 if (right - left \u0026lt; len) { start = left; len = right - left; } // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) { valid--; } window[d]--; } } } // 返回最小覆盖子串 return len == INT_MAX ? \u0026#34;\u0026#34; : s.substr(start, len); } 需要注意的是，当我们发现某个字符在 window 的数量满足了 need 的需要，就要更新 valid，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。\n当 valid == need.size() 时，说明 T 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。\n移动 left 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。\n二 字符串排列 LeetCode 567 题，字符串排列，难度 Medium：\n注意输入的 s1 是可以包含重复字符的。\n这种题目，是明显的滑动窗口算法，相当给你一个 S 和一个 T，请问你 S 中是否存在一个子串，包含 T 中所有字符且不包含其他字符？\n先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 判断 s 中是否存在 t 的排列 bool checkInclusion(string t, string s) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) { valid++; } } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 在这里判断是否找到了合法的子串 if (valid == need.size()) return true; char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) { valid--; } window[d]--; } } } // 未找到符合条件的子串 return false; } 对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：\n本题移动 left 缩小窗口的时机是窗口大小大于 t.size() 时，应为排列嘛，显然长度应该是一样的。\n当发现 valid == need.size() 时，就说明窗口中就是一个合法的排列，所以立即返回 true。 至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。\n三 找所有字母异位词 这是 LeetCode 第 438 题，找到字符串中所有字母异位词，难度 Medium：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 vector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; vector\u0026lt;int\u0026gt; res; // 记录结果 while (right \u0026lt; s.size()) { char c = s[right]; right++; // 进行窗口内数据的一系列更新 if (need.count(c)) { window[c]++; if (window[c] == need[c]) { valid++; } } // 判断左侧窗口是否要收缩 while (right - left \u0026gt;= t.size()) { // 当窗口符合条件时，把起始索引加入 res if (valid == need.size()) res.push_back(left); char d = s[left]; left++; // 进行窗口内数据的一系列更新 if (need.count(d)) { if (window[d] == need[d]) { valid--; } window[d]--; } } } return res; } 四 最长无重复子串 这是 LeetCode 第 3 题，最长无重复子串，难度 Medium：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u0026lt;char, int\u0026gt; window,need; int len = 0; int left = 0, right = 0; while(right \u0026lt; s.size()) { char c = s[right]; window[c]++; right++; while(window[c] \u0026gt; 1) { char d = s[left]; left++; window[d]--; } len = max(len,right - left); } return len; } }; 注意长度更新得在完成收缩之后。\n","date":"2025-03-05T00:00:00Z","image":"https://serennan.github.io/post/leetcode-window/cover.png","permalink":"https://serennan.github.io/post/leetcode-window/","title":"滑动窗口"},{"content":"Static 用法 本博客参照：CPlusPlusThings\n加上了一些自己的理解\n当与不同类型一起使用时，static关键字具有不同的含义。我们可以使用static关键字：\n静态变量： 函数中的变量，类中的变量\n静态类的成员： 类对象和类中的函数\n现在让我们详细看一下静态的这些用法\n静态变量 函数中的静态变量\n当变量声明为static时，空间将在程序的生命周期内分配。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。这对于在C / C ++或需要存储先前函数状态的任何其他应用程序非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void demo() { // static variable static int count = 0; cout \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // value is updated and // will be carried to next // function calls count++; } int main() { for (int i = 0; i \u0026lt; 5; i++) demo(); return 0; } 输出：\n1 0 1 2 3 4 可以在上面的程序中看到变量count被声明为static。因此，它的值通过函数调用来传递。每次调用函数时，都不会对变量计数进行初始化。\n类中的静态变量 初始化 由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量由对象共享。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // variables inside a class #include \u0026lt;iostream\u0026gt; using namespace std; class Apple { public: static int i; Apple(){ // Do nothing }; }; int Apple::i = 0; // 要在类外初始化 int main() { Apple obj1; Apple obj2; obj1.i = 2; obj2.i = 3; // prints value of i cout \u0026lt;\u0026lt; obj1.i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; obj2.i; } 输出：\n1 3 3 静态对象 就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。\n对象是非静态的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; class Apple { int i; public: Apple() { i = 0; cout \u0026lt;\u0026lt; \u0026#34;Inside Constructor\\n\u0026#34;; } ~Apple() { cout \u0026lt;\u0026lt; \u0026#34;Inside Destructor\\n\u0026#34;; } }; int main() { int x = 0; if (x == 0) { Apple obj; } cout \u0026lt;\u0026lt; \u0026#34;End of main\\n\u0026#34;; } 输出：\n1 2 3 Inside Constructor Inside Destructor End of main 在上面的程序中，对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。 如果我们将对象声明为静态，现在让我们看看输出的变化。\n对象是静态的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; class Apple { int i; public: Apple() { i = 0; cout \u0026lt;\u0026lt; \u0026#34;Inside Constructor\\n\u0026#34;; } ~Apple() { cout \u0026lt;\u0026lt; \u0026#34;Inside Destructor\\n\u0026#34;; } }; int main() { int x = 0; if (x == 0) { static Apple obj; } cout \u0026lt;\u0026lt; \u0026#34;End of main\\n\u0026#34;; } 输出：\n1 2 3 Inside Constructor End of main Inside Destructor 可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。\n静态函数 就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。允许使用对象和 . 来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; class Apple { public: void A() { _static = 1; non_static = 1; B(); cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } static void B() { _static = 1; non_static = 1; // error A(); // error cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } private: int non_static; static int _static; }; // main function int main() { Apple a; a.A(); Apple :: B(); } 静态成员函数仅能访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。\n限定访问范围 static还有限定访问范围的作用（类似于匿名名字空间）\n1 2 3 4 5 6 7 8 // source1.cpp extern void sayHello(); const char *msg = \u0026#34;Hello World!\\n\u0026#34;; int main() { sayHello(); return 0; } 1 2 3 4 5 6 7 // source2.cpp #include \u0026lt;cstdio\u0026gt; extern char *msg; void sayHello() { printf(\u0026#34;%s\u0026#34;, msg); } 编译指令：\n1 2 3 g++ -c source1.cpp -o source1.o g++ -c source2.cpp -o source2.o g++ source1.o source2.o -o hello_program g++对于上面两个代码文件是可以正常编译并且打印Hello World!，但如果给source1.cpp中的msg加上static，则会导致undefined reference to \u0026lsquo;msg\u0026rsquo;的编译错误：\n1 2 3 4 5 6 7 8 // source1.cpp extern void sayHello(); static const char* msg = \u0026#34;Hello World!\\n\u0026#34;; int main() { sayHello(); return 0; } static关键字将变量的作用域限制在其定义的编译单元内部。这样，msg变量只能在source1.cpp中使用，对其他文件不可见。\n","date":"2025-03-04T00:00:00Z","image":"https://serennan.github.io/post/cpp_static/cover.png","permalink":"https://serennan.github.io/post/cpp_static/","title":"【C++ 基础进阶】 Static"},{"content":"脱离开发环境的独立播放器 视频链接 main() 函数参数 main()函数的参数 argc argv：全称为ARGument Counter 和 ARGument Vector。其中argv存储了来自于命令行的参数；而argc存储了参数的个数。\n例如在命令行中输入“ffmpeg -i test.mkv test.ts ”，则argc取值为4， 而argv[]数组取值如下：\nargv[0]=\u0026ldquo;ffmpeg\u0026rdquo; argv[1]=\u0026quot;-i\u0026quot; argv[2]=\u0026ldquo;test.mkv\u0026rdquo; argv[3]=\u0026ldquo;test.ts\u0026rdquo; 动态链接库 windows 后缀是dll，linux后缀是so\n动态链接库不能被编译进应用程序。因而使用应用程序的时候必须在相同目录下保存用到的动态链接库文件\nCMakeLists.txt其实已经链接好动态库了\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 #include \u0026#34;SDL2/SDL_keycode.h\u0026#34; extern \u0026#34;C\u0026#34; { #include \u0026lt;SDL2/SDL.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavutil/imgutils.h\u0026gt; #include \u0026lt;libswscale/swscale.h\u0026gt; } const int bpp = 12; int screen_w = 500, screen_h = 500; const int pixel_w = 320, pixel_h = 180; unsigned char buffer[pixel_w * pixel_h * bpp / 8]; // SDL_USEREVENT是SDL库中预定义的一个用户事件起始值 // 刷新事件 #define REFRESH_EVENT (SDL_USEREVENT + 1) // 中断事件 #define BREAK_EVENT (SDL_USEREVENT + 2) // 暂停事件 #define PAUSE_EVENT (SDL_USEREVENT + 3) // 线程退出标志 int thread_exit = 0; // 暂停标志 bool pause = false; int refresh_video(void *opaque) { thread_exit = 0; pause = false; while (!thread_exit) { if (!pause) { SDL_Event event; event.type = REFRESH_EVENT; SDL_PushEvent(\u0026amp;event); } SDL_Delay(40); } thread_exit = 0; pause = false; // 推送一个退出主线程的事件 SDL_Event event; event.type = BREAK_EVENT; SDL_PushEvent(\u0026amp;event); SDL_Delay(40); return 0; } int main(int argc, char *argv[]) { AVFormatContext *pFormatCtx = NULL; int videoindex = -1; AVCodecContext *pCodecCtx = NULL; const AVCodec *pCodec = NULL; AVFrame *pFrame = NULL, *pFrameYUV = NULL; unsigned char *out_buffer = NULL; AVPacket *packet = NULL; int ret = 0; struct SwsContext *img_convert_ctx = NULL; if (argc != 2) { printf(\u0026#34;输入格式错误！程序名 文件名\u0026#34;); return 1; } const char *filepath = argv[1]; FILE *fp_yuv = fopen(\u0026#34;output.yuv\u0026#34;, \u0026#34;wb+\u0026#34;); // 初始化FFmpeg库 avformat_network_init(); // 打开输入文件 if (avformat_open_input(\u0026amp;pFormatCtx, filepath, NULL, NULL) != 0) { printf(\u0026#34;Couldn\u0026#39;t open input stream.\\n\u0026#34;); return -1; } // 获取流信息 if (avformat_find_stream_info(pFormatCtx, NULL) \u0026lt; 0) { printf(\u0026#34;Couldn\u0026#39;t find stream information.\\n\u0026#34;); return -1; } // 查找视频流 for (int i = 0; i \u0026lt; pFormatCtx-\u0026gt;nb_streams; i++) { if (pFormatCtx-\u0026gt;streams[i]-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { videoindex = i; break; } } if (videoindex == -1) { printf(\u0026#34;Didn\u0026#39;t find a video stream.\\n\u0026#34;); return -1; } // 获取解码器 pCodec = avcodec_find_decoder(pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar-\u0026gt;codec_id); if (pCodec == NULL) { printf(\u0026#34;Codec not found.\\n\u0026#34;); return -1; } // 创建解码器上下文 pCodecCtx = avcodec_alloc_context3(pCodec); if (!pCodecCtx) { printf(\u0026#34;Could not allocate video codec context\\n\u0026#34;); return -1; } // 复制流参数到解码器上下文 if (avcodec_parameters_to_context(pCodecCtx, pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar) \u0026lt; 0) { printf(\u0026#34;Could not copy codec parameters to context\\n\u0026#34;); return -1; } // 打开解码器 if (avcodec_open2(pCodecCtx, pCodec, NULL) \u0026lt; 0) { printf(\u0026#34;Could not open codec.\\n\u0026#34;); return -1; } pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); out_buffer = (unsigned char *)av_malloc( av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1)); av_image_fill_arrays(pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1); packet = av_packet_alloc(); // 输出文件信息 printf(\u0026#34;--------------- File Information ----------------\\n\u0026#34;); av_dump_format(pFormatCtx, 0, filepath, 0); printf(\u0026#34;-------------------------------------------------\\n\u0026#34;); img_convert_ctx = sws_getContext(pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, pCodecCtx-\u0026gt;pix_fmt, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); //==================SDL================== // 初始化 SDL 库 if (SDL_Init(SDL_INIT_VIDEO)) { printf(\u0026#34;Could not initialize SDL - %s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个窗口 SDL_Window *screen; // SDL 2.0 Support for multiple windows screen_w = pCodecCtx-\u0026gt;width; screen_h = pCodecCtx-\u0026gt;height; screen = SDL_CreateWindow(\u0026#34;Simplest Video Play SDL2\u0026#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, screen_w, screen_h, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE); if (!screen) { printf(\u0026#34;SDL: could not create window - exiting:%s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个渲染器，将窗口与渲染器关联 SDL_Renderer *sdlRenderer = SDL_CreateRenderer(screen, -1, 0); Uint32 pixformat = 0; // IYUV: Y + U + V (3 planes) // YV12: Y + V + U (3 planes) // 设置像素格式 // SDL_PIXELFORMAT_IYUV 表示使用 YUV420 pixformat = SDL_PIXELFORMAT_IYUV; // 创建纹理，用于存储视频数据 SDL_Texture *sdlTexture = SDL_CreateTexture(sdlRenderer, pixformat, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height); SDL_Rect sdlRect; // 创建一个子线程，用于定时触发视频刷新事件 // 第一个参数是函数指针 SDL_Thread *refresh_thread = SDL_CreateThread(refresh_video, NULL, NULL); SDL_Event event; while (1) { SDL_WaitEvent(\u0026amp;event); if (event.type == REFRESH_EVENT) { while (1) { if ((av_read_frame(pFormatCtx, packet) \u0026lt; 0)) thread_exit = 1; if (packet-\u0026gt;stream_index == videoindex) break; } ret = avcodec_send_packet(pCodecCtx, packet); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending a packet for decoding\\n\u0026#34;); return -1; } while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; // U V 是分量，宽高各压缩一半，所以大小是 Y 的 1/4 SDL_UpdateTexture(sdlTexture, NULL, pFrameYUV-\u0026gt;data[0], pFrameYUV-\u0026gt;linesize[0]); // FIX: If window is resize sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; SDL_RenderClear(sdlRenderer); SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, \u0026amp;sdlRect); SDL_RenderPresent(sdlRenderer); printf(\u0026#34;Succeed to decode 1 frame!\\n\u0026#34;); } av_packet_unref(packet); } // SDL_WINDOWEVENT 当窗口大小改变时，更新屏幕宽度和高度 else if (event.type == SDL_WINDOWEVENT) { // window SDL_GetWindowSize(screen, \u0026amp;screen_w, \u0026amp;screen_h); } // 当用户关闭窗口时，设置退出标志使子线程退出 else if (event.type == SDL_QUIT) { thread_exit = 1; } // 当接收到退出事件时，退出主循环并释放资源 // 这个退出事件由子线程提供 else if (event.type == BREAK_EVENT) { break; } else if (event.type == SDL_KEYDOWN) { if (event.key.keysym.sym == SDLK_SPACE) { pause = !pause; } if (event.key.keysym.sym == SDLK_ESCAPE) { thread_exit = 1; } } } // 刷新解码器 avcodec_send_packet(pCodecCtx, NULL); while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; fwrite(pFrameYUV-\u0026gt;data[0], 1, y_size, fp_yuv); // Y fwrite(pFrameYUV-\u0026gt;data[1], 1, y_size / 4, fp_yuv); // U fwrite(pFrameYUV-\u0026gt;data[2], 1, y_size / 4, fp_yuv); // V printf(\u0026#34;Flush Decoder: Succeed to decode 1 frame!\\n\u0026#34;); } sws_freeContext(img_convert_ctx); fclose(fp_yuv); av_frame_free(\u0026amp;pFrameYUV); av_frame_free(\u0026amp;pFrame); av_packet_free(\u0026amp;packet); avcodec_free_context(\u0026amp;pCodecCtx); avformat_close_input(\u0026amp;pFormatCtx); return 0; } 指令：\n1 ./main [视频文件] 断点的时候可以在 launch.json 加入预输入指令\n1 \u0026#34;args\u0026#34;: [\u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;, \u0026#34;arg3\u0026#34;] ","date":"2025-03-03T00:00:00Z","image":"https://serennan.github.io/post/leixiaohua-note-5/cover.jpg","permalink":"https://serennan.github.io/post/leixiaohua-note-5/","title":"【雷霄骅课程笔记】5 FFmpeg + SDL 视频播放器进阶"},{"content":"FFmpeg 和 SDL 整合实现视频播放器 视频链接 整合方式 FFmpeg 解码器实现了：视频文件 -\u0026gt; YUV SDL 视频显示实现了：YUV -\u0026gt; 屏幕 整合：FFmpeg + SDL = 视频文件 -\u0026gt; 屏幕 代码运行 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 extern \u0026#34;C\u0026#34; { #include \u0026lt;SDL2/SDL.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavutil/imgutils.h\u0026gt; #include \u0026lt;libswscale/swscale.h\u0026gt; } const int bpp = 12; int screen_w = 500, screen_h = 500; const int pixel_w = 320, pixel_h = 180; unsigned char buffer[pixel_w * pixel_h * bpp / 8]; // SDL_USEREVENT是SDL库中预定义的一个用户事件起始值 // 刷新事件 #define REFRESH_EVENT (SDL_USEREVENT + 1) // 中断事件 #define BREAK_EVENT (SDL_USEREVENT + 2) // 线程退出标志 int thread_exit = 0; int refresh_video(void *opaque) { thread_exit = 0; while (!thread_exit) { SDL_Event event; event.type = REFRESH_EVENT; SDL_PushEvent(\u0026amp;event); SDL_Delay(40); } thread_exit = 0; // 推送一个退出主线程的事件 SDL_Event event; event.type = BREAK_EVENT; SDL_PushEvent(\u0026amp;event); return 0; } int main(int argc, char *argv[]) { AVFormatContext *pFormatCtx = NULL; int videoindex = -1; AVCodecContext *pCodecCtx = NULL; const AVCodec *pCodec = NULL; AVFrame *pFrame = NULL, *pFrameYUV = NULL; unsigned char *out_buffer = NULL; AVPacket *packet = NULL; int ret = 0; struct SwsContext *img_convert_ctx = NULL; char filepath[] = \u0026#34;../video/Titanic.ts\u0026#34;; FILE *fp_yuv = fopen(\u0026#34;output.yuv\u0026#34;, \u0026#34;wb+\u0026#34;); // 初始化FFmpeg库 avformat_network_init(); // 打开输入文件 if (avformat_open_input(\u0026amp;pFormatCtx, filepath, NULL, NULL) != 0) { printf(\u0026#34;Couldn\u0026#39;t open input stream.\\n\u0026#34;); return -1; } // 获取流信息 if (avformat_find_stream_info(pFormatCtx, NULL) \u0026lt; 0) { printf(\u0026#34;Couldn\u0026#39;t find stream information.\\n\u0026#34;); return -1; } printf(\u0026#34;时长：%ld\\n\u0026#34;, pFormatCtx-\u0026gt;duration); // 查找视频流 for (int i = 0; i \u0026lt; pFormatCtx-\u0026gt;nb_streams; i++) { if (pFormatCtx-\u0026gt;streams[i]-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { videoindex = i; break; } } if (videoindex == -1) { printf(\u0026#34;Didn\u0026#39;t find a video stream.\\n\u0026#34;); return -1; } // 获取解码器 pCodec = avcodec_find_decoder(pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar-\u0026gt;codec_id); if (pCodec == NULL) { printf(\u0026#34;Codec not found.\\n\u0026#34;); return -1; } // 创建解码器上下文 pCodecCtx = avcodec_alloc_context3(pCodec); if (!pCodecCtx) { printf(\u0026#34;Could not allocate video codec context\\n\u0026#34;); return -1; } // 复制流参数到解码器上下文 if (avcodec_parameters_to_context(pCodecCtx, pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar) \u0026lt; 0) { printf(\u0026#34;Could not copy codec parameters to context\\n\u0026#34;); return -1; } // 打开解码器 if (avcodec_open2(pCodecCtx, pCodec, NULL) \u0026lt; 0) { printf(\u0026#34;Could not open codec.\\n\u0026#34;); return -1; } pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); out_buffer = (unsigned char *)av_malloc( av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1)); av_image_fill_arrays(pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1); packet = av_packet_alloc(); // 输出文件信息 printf(\u0026#34;--------------- File Information ----------------\\n\u0026#34;); av_dump_format(pFormatCtx, 0, filepath, 0); printf(\u0026#34;-------------------------------------------------\\n\u0026#34;); img_convert_ctx = sws_getContext(pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, pCodecCtx-\u0026gt;pix_fmt, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); //==================SDL================== // 初始化 SDL 库 if (SDL_Init(SDL_INIT_VIDEO)) { printf(\u0026#34;Could not initialize SDL - %s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个窗口 SDL_Window *screen; // SDL 2.0 Support for multiple windows screen_w = pCodecCtx-\u0026gt;width; screen_h = pCodecCtx-\u0026gt;height; screen = SDL_CreateWindow(\u0026#34;Simplest Video Play SDL2\u0026#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, screen_w, screen_h, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE); if (!screen) { printf(\u0026#34;SDL: could not create window - exiting:%s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个渲染器，将窗口与渲染器关联 SDL_Renderer *sdlRenderer = SDL_CreateRenderer(screen, -1, 0); Uint32 pixformat = 0; // IYUV: Y + U + V (3 planes) // YV12: Y + V + U (3 planes) // 设置像素格式 // SDL_PIXELFORMAT_IYUV 表示使用 YUV420 pixformat = SDL_PIXELFORMAT_IYUV; // 创建纹理，用于存储视频数据 SDL_Texture *sdlTexture = SDL_CreateTexture(sdlRenderer, pixformat, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height); SDL_Rect sdlRect; // 创建一个子线程，用于定时触发视频刷新事件 // 第一个参数是函数指针 SDL_Thread *refresh_thread = SDL_CreateThread(refresh_video, NULL, NULL); SDL_Event event; while (1) { SDL_WaitEvent(\u0026amp;event); if (event.type == REFRESH_EVENT) { while (1) { if ((av_read_frame(pFormatCtx, packet) \u0026lt; 0)) thread_exit = 1; if (packet-\u0026gt;stream_index == videoindex) break; } ret = avcodec_send_packet(pCodecCtx, packet); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending a packet for decoding\\n\u0026#34;); return -1; } while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; // U V 是分量，宽高各压缩一半，所以大小是 Y 的 1/4 SDL_UpdateTexture(sdlTexture, NULL, pFrameYUV-\u0026gt;data[0], pFrameYUV-\u0026gt;linesize[0]); // FIX: If window is resize sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; SDL_RenderClear(sdlRenderer); SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, \u0026amp;sdlRect); SDL_RenderPresent(sdlRenderer); printf(\u0026#34;Succeed to decode 1 frame!\\n\u0026#34;); } av_packet_unref(packet); } // SDL_WINDOWEVENT 当窗口大小改变时，更新屏幕宽度和高度 else if (event.type == SDL_WINDOWEVENT) { // window SDL_GetWindowSize(screen, \u0026amp;screen_w, \u0026amp;screen_h); } // 当用户关闭窗口时，设置退出标志使子线程退出 else if (event.type == SDL_QUIT) { thread_exit = 1; } // 当接收到退出事件时，退出主循环并释放资源 // 这个退出事件由子线程提供 else if (event.type == BREAK_EVENT) { break; } } // 刷新解码器 avcodec_send_packet(pCodecCtx, NULL); while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; fwrite(pFrameYUV-\u0026gt;data[0], 1, y_size, fp_yuv); // Y fwrite(pFrameYUV-\u0026gt;data[1], 1, y_size / 4, fp_yuv); // U fwrite(pFrameYUV-\u0026gt;data[2], 1, y_size / 4, fp_yuv); // V printf(\u0026#34;Flush Decoder: Succeed to decode 1 frame!\\n\u0026#34;); } sws_freeContext(img_convert_ctx); fclose(fp_yuv); av_frame_free(\u0026amp;pFrameYUV); av_frame_free(\u0026amp;pFrame); av_packet_free(\u0026amp;packet); avcodec_free_context(\u0026amp;pCodecCtx); avformat_close_input(\u0026amp;pFormatCtx); return 0; } CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 cmake_minimum_required(VERSION 3.10) project(MyProject VERSION 1.0) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_BUILD_TYPE DEBUG) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 添加头文件路径 include_directories(${PROJECT_SOURCE_DIR}/include) # 添加库文件路径 link_directories(${PROJECT_SOURCE_DIR}/lib) # 添加可执行文件 add_executable(main src/testPlayer.cpp) # 链接 FFmpeg 库 target_link_libraries(main avutil avcodec avformat swscale ) # 链接 SDL 库 target_link_libraries(main SDL2 SDL2main ) 代码分析 这段代码主要是整合我们前面所写的解码器和 SDL 视频播放器\n主要注意下面的几点\n1. 纹理数据 在创建纹理和更新纹理时，要给视频的数据，换成前面解码出来的视频数据就行\n1 2 3 4 5 6 // 创建纹理，用于存储视频数据 SDL_Texture *sdlTexture = SDL_CreateTexture(sdlRenderer, pixformat, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height); // 更新纹理 SDL_UpdateTexture(sdlTexture, NULL, pFrameYUV-\u0026gt;data[0], pFrameYUV-\u0026gt;linesize[0]); 2. 循环读取一帧数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 while (1) { SDL_WaitEvent(\u0026amp;event); if (event.type == REFRESH_EVENT) { while (1) { if ((av_read_frame(pFormatCtx, packet) \u0026lt; 0)) thread_exit = 1; if (packet-\u0026gt;stream_index == videoindex) break; } ... } ... } 外层循环如果使用 while(av_read_frame(pFormatCtx, packet) \u0026gt;= 0) 可能导致的问题：\n解码流程混乱： 原代码采用事件驱动模型，由独立线程定时触发刷新事件，保证按正确帧率解码和渲染。\n修改后的外层 while (av_read_frame(...)) 循环破坏了原有同步机制，导致：\n过快读取 Packet ：可能连续发送多个 Packet 到解码器，未等待 SDL 渲染完成 未处理 B 帧依赖：H.264 的 B 帧需要前后参考帧，若解码顺序错误，导致参考帧丢失（reference picture missing） SDL事件处理冲突： 外层循环强制不断读取 Packet ，可能覆盖正在处理的数据，导致多线程竞争 SDL_WaitEvent 在内层阻塞时，外层循环可能持续读取，导致 Packet 堆积或处理顺序错乱 代码也可以改成这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 while (1) { SDL_WaitEvent(\u0026amp;event); if (event.type == REFRESH_EVENT) { while (av_read_frame(pFormatCtx, packet) \u0026gt;= 0) { if (packet-\u0026gt;stream_index == videoindex) { ... } ... } ... } ... } 可能更清楚一点\n","date":"2025-03-02T00:00:00Z","image":"https://serennan.github.io/post/leixiaohua-note-4/cover.jpg","permalink":"https://serennan.github.io/post/leixiaohua-note-4/","title":"【雷霄骅课程笔记】4 FFmpeg + SDL 视频播放器"},{"content":"Const 用法 本博客参照：CPlusPlusThings\n加上了一些自己的理解。\n1. const 含义 常类型是指使用类型修饰符 const 说明的类型，常类型的变量或对象的值是不能被更新的。\n2. const 作用 定义常量\n1 const int a = 100; 类型检查\nconst 常量支持所有类型 其他情况下它只是一个 const 限定的变量，不要将与常量混淆。 防止修改，起保护作用，增加程序健壮性\n1 2 3 void f(const int i) { i++; // error! } 节省空间，避免不必要的内存分配\nconst 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像 #define 一样给出的是立即数 const 定义的常量在程序运行过程中只有一份拷贝，而 #define 定义的常量在内存中有若干个拷贝 3. const 对象默认为文件局部变量 非 const 变量默认为 extern。要使 const 变量能够在其他文件中访问，必须在文件中显式地指定它为 extern\n未被 const 修饰的变量在不同文件的访问 1 2 // file1.cpp int ext; 1 2 3 4 5 6 7 // file2.cpp #include\u0026lt;iostream\u0026gt; extern int ext; int main() { std::cout \u0026lt;\u0026lt; (ext + 10) \u0026lt;\u0026lt; std::endl; } const 常量在不同文件的访问 1 2 // extern_file1.cpp extern const int ext = 12; // 定义时要显示声明为 extern ，且要初始化 1 2 3 4 5 6 // extern_file2.cpp #include\u0026lt;iostream\u0026gt; extern const int ext; int main() { std::cout \u0026lt;\u0026lt; ext \u0026lt;\u0026lt; std::endl; } 小结：\n可以发现未被 const 修饰的变量不需要 extern 显式声明。而 const 常量需要显式声明 extern，并且需要做初始化。因为常量在定义后就不能被修改，所以定义时必须初始化\n4. 定义常量 1 2 3 4 const int b = 10; b = 0; // error: assignment of read-only variable ‘b’ const std::string s = \u0026#34;helloworld\u0026#34;; const int i, j = 0; // error: uninitialized const ‘i’ 上述有两个错误:\nb 为常量，不可更改 i 为常量，必须进行初始化。（因为常量在定义后就不能被修改，所以定义时必须初始化） 5. 指针与 const 与指针相关的 const 有四种:\n1 2 3 4 const char *a; // 指向 const 对象的指针 char const *a; // 同上 char *const a; // 指向类型对象的 const 指针 const char *const a; // 指向 const 对象的 const 指针 小结：\n如果 const 位于 * 的左侧，则 const 是用来修饰指针所指向的变量，即指针指向为常量；\n如果 const 位于 * 的右侧，const 就是修饰指针本身，即指针本身是常量\n另一种解读方式\n利用英文从右边往左边读，并以 to 为分界，to 之前为描述指针的特性，to 之后为描述目标的特性\n1 2 3 4 const char *p; // p is a pointer to const char char const *p; // 同上 char *const p; // p is a const pointer to char const char *const p; // p is a const pointer to const char 当指针被加上 const 特性，则指针不可改变指向的地址；\n当指向的目标特性为 char，则内容可以通过指针被修改，如: *char = 'y';\n当指向的目标特性为 const char，则内容不可通过指针修改。\n（1） 指向常量的指针 1 2 const int *ptr; *ptr = 10; // error ptr 是一个指向 int 类型 const 对象的指针，const 定义的是 int 类型，也就是 ptr 所指向的对象类型，而不是 ptr 本身，所以 ptr 可以不用赋初始值。但是不能通过 ptr 去修改所指对象的值。\n除此之外，也不能使用 void* 指针保存 const 对象的地址，必须使用 const void* 类型的指针保存 const 对象的地址。\n1 2 3 const int p = 10; const void *vp = \u0026amp;p; void *vp = \u0026amp;p; // error 另外一个重点是：允许把非 const 对象的地址赋给指向 const 对象的指针\n将非 const 对象的地址赋给 const 对象的指针:\n1 2 3 4 const int *ptr; int val = 3; ptr = \u0026amp;val; // ok *ptr = 1; // error 我们不能通过 ptr 指针来修改 val 的值，即使它指向的是非 const 对象\n我们不能使用指向 const 对象的指针修改基础对象，然而如果该指针指向了非 const 对象，可用其他方式修改其所指的对象。可以修改 const 指针所指向的值的，但是不能通过 const 对象指针来进行而已。如下修改：\n1 2 3 4 int *ptr1 = \u0026amp;val; int val = 3; *ptr1 = 4; cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; endl; 小结：\n对于指向常量的指针，不能通过指针来修改对象的值\n不能使用 void* 指针保存 const 对象的地址，必须使用 const void* 类型的指针保存const对象的地址\n允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改 （2） 常指针 const指针必须进行初始化，且const指针指向的值能修改，但指向不能修改。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int num = 0, num1 = 1; int *const ptr = \u0026amp;num; // const指针必须初始化 且const指针的指向不能修改 ptr = \u0026amp;num1; // error const指针不能修改指向 cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; endl; } 代码出现编译错误：const指针不能修改指向\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int num = 0, num1 = 1; int *const ptr = \u0026amp;num; // const指针必须初始化 且const指针的指向不能修改 *ptr = 1; // ok 修改指向的值 cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; endl; } 代码无事发生，正常输出1\n最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int* -\u0026gt; int *的错误：\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { const int num = 0; int *const ptr = \u0026amp;num; // error! const int* -\u0026gt; int* cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; endl; } 上述若改为 const int *ptr或者改为const int *const ptr都可以：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { const int num = 10; const int *const ptr = \u0026amp;num; // const int *ptr = \u0026amp;num; cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; endl; } 小结：\nconst 指针必须初始化，且指向的值能修改，指向不能修改 const 指针能指向非 const 对象，但是 const 对象必须用 const 指针 （3）指向常量的常指针 理解完前两种情况，下面这个情况就比较好理解了：\n1 2 const int p = 3; const int * const ptr = \u0026amp;p; ptr是一个const指针，然后指向了一个int 类型的const对象\n6.函数中使用const const修饰函数返回值 这个跟const修饰普通变量以及指针的含义基本相同：\n（1）const int\n1 const int func1(); 这个本身无意义，因为参数返回本身就是赋值给其他的变量。\n（2）const int*\n1 const int* func2(); 指针指向的内容不变。\n（3）int *const\n1 int *const func3(); 指针本身不可变。\nconst修饰函数参数 （1）传递过来的参数及指针本身在函数内不可变，无意义\n1 2 void func(const int var); // 传递过来的参数不可变 void func(int *const var); // 指针本身不可变 表明参数在函数体内不能被修改，但此处没有太多意义，var本身就是形参，加const只是保证在函数内不会改变。包括传入的形参是指针也是一样，加不加 const 对函数外效果都一样。\n输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。\n（2）参数指针所指内容为常量不可变\n1 void StringCopy(char *dst, const char *src); 其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; void change(int *dst, const int *src) { *dst = 2; // *src = 2; // error } int main() { int a = 1; int b = 1; int *ptr1 = \u0026amp;a; int *ptr2 = \u0026amp;b; change(ptr1, ptr2); cout \u0026lt;\u0026lt; \u0026#34;ptr1 -\u0026gt; \u0026#34; \u0026lt;\u0026lt; *ptr1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;ptr2 -\u0026gt; \u0026#34; \u0026lt;\u0026lt; *ptr2 \u0026lt;\u0026lt; endl; } （3）参数为引用，为了增加效率同时防止修改。\n1 void func(const A \u0026amp;a) 对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。\n为了提高效率，可以将函数声明改为void func(A \u0026amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。\n但是函数void func(A \u0026amp;a) 存在一个缺点：\n“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A \u0026amp;a)。\n以此类推，是否应将void func(int x) 改写为void func(const int \u0026amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。\n小结：\n对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A \u0026amp;a)\n对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int \u0026amp;x) 以上解决了两个面试问题：\n如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别； 如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。 7.类中使用const 在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。\n使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。\n初始化 对于类中的const成员变量必须通过初始化列表进行初始化，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 class Apple{ private: int people[100]; public: Apple(int i); const int apple_number; }; Apple::Apple(int i):apple_number(i) { } 访问 const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; class Apple { private: int num; public: Apple(int i); const int apple_number; int add(int num); int take() const; }; Apple::Apple(int i) : apple_number(i) {} int Apple::add(int num) { add(num); return 0; } int Apple::take() const { add(1); // error return this-\u0026gt;num; } int main() { Apple a(2); a.add(10); a.take(); cout \u0026lt;\u0026lt; a.take() \u0026lt;\u0026lt; endl; const Apple b(3); b.add(100); // error b.take(); return 0; } 代码有两个错误：\nconst成员函数只能访问const成员函数\n此时报错，上面 take() 方法中调用了一个add()方法，而add()方法并非const修饰，所以运行报错\nconst 对象只能访问 const 成员函数\n对象 a 能访问 add() 和 take()。而对象 b 用const修饰，无法访问add()方法，只能访问take() 其他初始化方法 我们除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法：\n第一：将常量定义与static结合：\n1 static const int apple_number 第二：在外面初始化：\n1 const int Apple::apple_number = 10; 当然，如果你使用c++11进行编译，直接可以在定义出初始化，可以直接写成：\n1 2 3 static const int apple_number = 10; // 或者 const int apple_number = 10; 这两种都在c++11中支持\n编译的时候加上-std=c++11即可\n这里提到了static，下面简单的说一下：\n在C++中，非const的static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。\n在类中声明：\n1 static int ap; 在类实现文件中使用：\n1 int Apple :: ap = 666 对于此项，c++11不能进行声明并初始化，也就是上述使用方法。\n练习 常成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; using namespace std; class R { public: R(int r1, int r2) { R1 = r1; R2 = r2; } // const区分成员重载函数 void print(); void print() const; private: int R1, R2; }; /* 常成员函数说明格式：类型说明符 函数名（参数表）const; 这里，const是函数类型的一个组成部分，因此在实现部分也要带const关键字。 const关键字可以被用于参与对重载函数的区分 通过常对象只能调用它的常成员函数 */ void R::print() { cout \u0026lt;\u0026lt; \u0026#34;普通调用\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; R1 \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; R2 \u0026lt;\u0026lt; endl; } // 实例化也需要带上 void R::print() const { cout \u0026lt;\u0026lt; \u0026#34;常对象调用\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; R1 \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; R2 \u0026lt;\u0026lt; endl; } int main() { R a(5, 4); a.print(); // 调用void print() // 通过常对象只能调用它的常成员函数 const R b(20, 52); b.print(); // 调用void print() const return 0; } 常对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; void display(const double \u0026amp;r); class A { public: A(int i, int j) { x = i; y = j; } private: int x, y; }; int main() { double d(9.5); display(d); A const a(3, 4); // a 是常对象，不能被更新 return 0; } void display(const double \u0026amp;r) // 常引用做形参，在函数中不能更新 r 所引用的对象。 { cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; } ","date":"2025-02-28T00:00:00Z","image":"https://serennan.github.io/post/cpp_const/cover.png","permalink":"https://serennan.github.io/post/cpp_const/","title":"【C++ 基础进阶】 Const"},{"content":"介绍Mermaid并分享优化配置的博客内容：\nMermaid 流程图优化配置指南 Mermaid 是一个强大的流程图绘制工具，支持多种图表类型，包括流程图、类图、状态图等。但在实际使用中，官方默认配置可能存在一些问题，比如节点文字过长导致显示不整齐、图表放大后文字模糊等。\n经过反复研究和优化，我整理出一套 Mermaid 的优化解决方案，完美解决这些痛点问题。以下是主要的优化功能：\n自动调整节点宽度：根据文字内容自动调整节点宽度，避免文字截断 文字自动换行：支持长文字自动换行显示 字体大小适配：不同的场景自动调整字体大小 流程图缩放：支持鼠标滚轮缩放，随时切换显示比例 偏移滚动：放大后支持拖拽查看图表任意区域 拖拽放大：点击进入放大模式，双击或 ESC 退出 移动端优化：自动适配手机和平板等移动设备 功能展示 flowchart TD A[\"程序启动\"] A --\u003e B[\"主线程\"] A --\u003e C[\"刷新线程 (refresh_video)\"] 节点自动调整\n节点宽度根据内容自动调整，避免文字溢出或过于 crowed\n文字换行支持\n长文字自动换行，保持内容清晰易读\n平滑缩放\n支持滚轮缩放（Ctrl + 滚轮），放大后仍然保持清晰\n拖拽查看\n放大后可以拖拽查看任意区域，操作流畅\n快捷操作\n单击：进入放大模式 滚轮：缩放图表 拖拽：平移视角 双击/ESC：退出放大模式 配置指南 我使用的是 stack 主题，不同主题文件结构可能不同\n创建 layouts/_default/_markup/render-codeblock-mermaid.html ： 1 2 3 4 5 \u0026lt;div class=\u0026#34;mermaid-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{ .Inner | safeHTML }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 修改 layouts/_default/baseof.html ： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34; dir=\u0026#34;{{ default `ltr` .Language.LanguageDirection }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{- partial \u0026#34;head/head.html\u0026#34; . -}} {{- block \u0026#34;head\u0026#34; . -}}{{ end }} \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;{{ block `body-class` . }}{{ end }}\u0026#34;\u0026gt; {{- partial \u0026#34;head/colorScheme\u0026#34; . -}} {{/* The container is wider when there\u0026#39;s any activated widget */}} {{- $hasWidget := false -}} {{- range .Site.Params.widgets -}} {{- if gt (len .) 0 -}} {{- $hasWidget = true -}} {{- end -}} {{- end -}} \u0026lt;div class=\u0026#34;container main-container flex on-phone--column {{ if $hasWidget }}extended{{ else }}compact{{ end }}\u0026#34;\u0026gt; {{- block \u0026#34;left-sidebar\u0026#34; . -}} {{ partial \u0026#34;sidebar/left.html\u0026#34; . }} {{- end -}} {{- block \u0026#34;right-sidebar\u0026#34; . -}}{{ end }} \u0026lt;main class=\u0026#34;main full-width\u0026#34;\u0026gt; {{- block \u0026#34;main\u0026#34; . }}{{- end }} \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; {{ partial \u0026#34;footer/include.html\u0026#34; . }} {{ partial \u0026#34;article/components/mermaid.html\u0026#34; . }} \u0026lt;!-- 新增这一行 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 具体的路径主要看你放在哪，我就放在文章文件夹下了\n3. 创建 layouts/partials/article/components/mermaid.html，：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 {{- if .Page.Params.mermaid -}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ \u0026#34;css/mermaid.css\u0026#34; | relURL }}\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; mermaid.initialize({ startOnLoad: true, flowchart: { htmlLabels: false, useMaxWidth: false, nodeSpacing: 50, rankSpacing: 50, defaultRenderer: \u0026#39;svg\u0026#39; }, theme: \u0026#39;default\u0026#39;, securityLevel: \u0026#39;loose\u0026#39;, themeVariables: { nodeBorder: \u0026#39;#000\u0026#39;, mainBkg: \u0026#39;#fff\u0026#39;, nodeTextColor: \u0026#39;#000\u0026#39;, fontSize: \u0026#39;14px\u0026#39; } }); \u0026lt;/script\u0026gt; \u0026lt;!-- 遮罩层 --\u0026gt; \u0026lt;div class=\u0026#34;mermaid-overlay\u0026#34; id=\u0026#34;mermaidOverlay\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { // 自动调整节点尺寸 const adjustNodeSize = () =\u0026gt; { document.querySelectorAll(\u0026#39;.mermaid .node\u0026#39;).forEach(node =\u0026gt; { const rect = node.querySelector(\u0026#39;rect\u0026#39;); const text = node.querySelector(\u0026#39;text\u0026#39;); if (rect \u0026amp;\u0026amp; text) { const bbox = text.getBBox(); const padding = 16; const minWidth = parseFloat(rect.getAttribute(\u0026#39;width\u0026#39;)) || 160; const newWidth = Math.max(bbox.width + padding, minWidth); rect.setAttribute(\u0026#39;width\u0026#39;, newWidth); } }); }; // 初始化调整 adjustNodeSize(); window.addEventListener(\u0026#39;resize\u0026#39;, adjustNodeSize); // 为每个mermaid图表创建独立控制器 document.querySelectorAll(\u0026#39;.mermaid-container\u0026#39;).forEach(container =\u0026gt; { let currentScale = 1; let initialClickX = null, initialClickY = null; let dragOffsetX = 0, dragOffsetY = 0; let isDragging = false; let dragStartX = 0, dragStartY = 0; let isZoomed = false; const mermaidElement = container.querySelector(\u0026#39;.mermaid\u0026#39;); const overlay = document.getElementById(\u0026#39;mermaidOverlay\u0026#39;); const originalParent = container.parentElement; const originalNextSibling = container.nextElementSibling; // 应用变换 const applyScale = () =\u0026gt; { if (isZoomed \u0026amp;\u0026amp; initialClickX !== null \u0026amp;\u0026amp; initialClickY !== null) { const containerRect = container.getBoundingClientRect(); const centerX = containerRect.width / 2; const centerY = containerRect.height / 2; const baseTranslateX = centerX - initialClickX * currentScale; const baseTranslateY = centerY - initialClickY * currentScale; const translateX = baseTranslateX + dragOffsetX; const translateY = baseTranslateY + dragOffsetY; mermaidElement.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentScale})`; } else { mermaidElement.style.transform = `scale(${currentScale})`; } }; // 进入放大模式 const handleContainerClick = (e) =\u0026gt; { if (!isZoomed) { isZoomed = true; container.classList.add(\u0026#39;zoomed\u0026#39;); overlay.style.display = \u0026#39;flex\u0026#39;; overlay.appendChild(container); const containerRect = container.getBoundingClientRect(); initialClickX = e.clientX - containerRect.left; initialClickY = e.clientY - containerRect.top; dragOffsetX = 0; dragOffsetY = 0; const scaleX = window.innerWidth / containerRect.width; const scaleY = window.innerHeight / containerRect.height; currentScale = Math.min(scaleX, scaleY, 5); applyScale(); } }; // 退出放大模式 const exitZoom = () =\u0026gt; { if (isZoomed) { isZoomed = false; container.classList.remove(\u0026#39;zoomed\u0026#39;); overlay.style.display = \u0026#39;none\u0026#39;; if (originalNextSibling) { originalParent.insertBefore(container, originalNextSibling); } else { originalParent.appendChild(container); } currentScale = 1; initialClickX = null; initialClickY = null; dragOffsetX = 0; dragOffsetY = 0; applyScale(); } }; // 滚轮事件处理 const handleWheel = (e) =\u0026gt; { if (isZoomed) { e.preventDefault(); const sensitivity = 0.0006; const delta = e.deltaY || e.wheelDelta; const scaleDelta = 1 + (-delta * sensitivity); currentScale = Math.min(Math.max(0.3, currentScale * scaleDelta), 5); applyScale(); } else if (e.ctrlKey) { e.preventDefault(); const sensitivity = 0.0006; const delta = e.deltaY || e.wheelDelta; const scaleDelta = 1 + (-delta * sensitivity); currentScale = Math.min(Math.max(0.3, currentScale * scaleDelta), 5); applyScale(); } }; // 事件绑定 container.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { if (!isZoomed) handleContainerClick(e); }); container.addEventListener(\u0026#39;dblclick\u0026#39;, exitZoom); container.addEventListener(\u0026#39;wheel\u0026#39;, handleWheel); // 拖拽处理 container.addEventListener(\u0026#39;mousedown\u0026#39;, (e) =\u0026gt; { if (isZoomed) { isDragging = true; dragStartX = e.clientX; dragStartY = e.clientY; container.style.cursor = \u0026#39;grabbing\u0026#39;; } }); const handleMouseMove = (e) =\u0026gt; { if (isDragging) { const deltaX = e.clientX - dragStartX; const deltaY = e.clientY - dragStartY; dragOffsetX += deltaX; dragOffsetY += deltaY; dragStartX = e.clientX; dragStartY = e.clientY; applyScale(); } }; const handleMouseUp = () =\u0026gt; { isDragging = false; container.style.cursor = \u0026#39;grab\u0026#39;; }; document.addEventListener(\u0026#39;mousemove\u0026#39;, handleMouseMove); document.addEventListener(\u0026#39;mouseup\u0026#39;, handleMouseUp); }); // 全局ESC按键监听 document.addEventListener(\u0026#39;keydown\u0026#39;, (e) =\u0026gt; { if (e.key === \u0026#39;Escape\u0026#39;) { document.querySelectorAll(\u0026#39;.mermaid-container\u0026#39;).forEach(container =\u0026gt; { if (container.classList.contains(\u0026#39;zoomed\u0026#39;)) { container.dispatchEvent(new Event(\u0026#39;dblclick\u0026#39;)); } }); } }); }); \u0026lt;/script\u0026gt; {{- end -}} 修改 assets/scss/style.scss： 1 @import \u0026#34;partials/mermaid.scss\u0026#34;; 具体还是看你把 css 文件放在哪\n5. 创建 assets/scss/partials/mermaid.scss：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 /* 核心容器 */ .mermaid-container { position: relative; margin: 2rem 0; border-radius: 12px; overflow: auto; padding: 1.5rem; transition: transform 0.3s cubic-bezier(0.22, 0.61, 0.36, 1); user-select: none; } /* Mermaid 图表样式 */ .mermaid { transition: transform 0.25s cubic-bezier(0.22, 0.61, 0.36, 1); will-change: transform; backface-visibility: hidden; transform-origin: top left; text-align: center; line-height: 1.5; } /* 节点样式增强 */ .mermaid .node rect { rx: 8px; ry: 8px; filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.1)); min-width: 160px !important; /* 强制最小宽度 */ min-height: 60px !important; /* 强制最小高度 */ } .mermaid .node text { pointer-events: none; alignment-baseline: middle; text-anchor: middle; white-space: pre-wrap !important; /* 允许换行 */ word-wrap: break-word !important; overflow: visible !important; font-size: 14px !important; max-width: 150px !important; /* 限制文字最大宽度 */ padding: 8px !important; /* 添加内边距 */ } /* 边标签样式 */ .mermaid .edgeLabels foreignObject { background: var(--card, #fff); border-radius: 4px; padding: 2px 8px; display: block; text-align: center; min-width: 80px !important; white-space: pre-wrap !important; word-wrap: break-word !important; } /* 移动端优化 */ @media (max-width: 768px) { .mermaid-container { margin: 1rem -1rem; border-radius: 0; } .mermaid .node rect { min-width: 120px !important; min-height: 40px !important; } .mermaid .node text { font-size: 12px !important; max-width: 100px !important; } } /* 遮罩层 */ .mermaid-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(69, 71, 71, 0.5); backdrop-filter: blur(4px); z-index: 1000; display: none; justify-content: center; align-items: center; cursor: zoom-out; } /* 放大状态下的容器 */ .mermaid-container.zoomed { position: absolute; top: 50%; left: 50%; width: 100vw; height: 100vh; margin: 0; padding: 1.5rem; transform: translate(-50%, -50%); cursor: grab; transition: transform 0.3s cubic-bezier(0.22, 0.61, 0.36, 1); z-index: 1001; } .mermaid-container.zoomed:active { cursor: grabbing; } .mermaid-container.zoomed .mermaid { transform-origin: center center; cursor: default; overflow: visible; } ","date":"2025-02-27T00:00:00Z","image":"https://serennan.github.io/post/hugo-mermaid/cover.jpg","permalink":"https://serennan.github.io/post/hugo-mermaid/","title":"【Hugo】引入mermaid"},{"content":"SDL 视频播放器-进阶 视频链接 SDL 中事件和多线程 SDL 多线程 多个函数同时运行\n函数\nSDL_CreateThread()：创建一个线程 数据结构\nSDL_Thread：线程的句柄 SDL 事件 在SDL中，事件是用于处理用户输入和系统通知的机制\n函数\nSDL_WaitEvent()：等待一个事件\nSDL_PushEvent()：发送一个事件 数据结构 SDL_Event：代表一个事件 流程图 flowchart TD A[主线程] --\u003e B[初始化] B --\u003e C[创建子线程] C --\u003e D[进入主事件循环] subgraph 子线程 C --\u003e E[进入循环] E --\u003e F{检查退出标志} F -- 否 --\u003e G[推送REFRESH_EVENT] G --\u003e H[延时40ms] H --\u003e F F -- 是 --\u003e I[推送BREAK_EVENT] end D --\u003e J{等待事件} J --\u003e|REFRESH_EVENT| K[读取YUV数据] K --\u003e L[更新纹理] L --\u003e M[渲染到窗口] J --\u003e|SDL_WINDOWEVENT| N[更新窗口尺寸] J --\u003e|SDL_QUIT| O[设置退出标志] J --\u003e|BREAK_EVENT| P[退出循环] O --\u003e|通知子线程| F I --\u003e|触发| P 主线程：负责处理所有 SDL 事件（窗口关闭，窗口大小改变，视频刷新等）\n函数介绍 SDL_CreateThread()：创建一个线程\nSDL_WaitEvent()：等待事件 SDL_GetWindowSize()：获取窗口大小\n这里第一个参数 screen 是播放的窗口大小, 第二第三个参数 screen_w 和 screen_h 是获得的宽高，这里获得了宽高能直接赋值给前面的刷新事件使用，用来渲染新的窗口 代码运行 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include \u0026lt;stdio.h\u0026gt; extern \u0026#34;C\u0026#34; { #include \u0026#34;SDL2/SDL.h\u0026#34; }; const int bpp = 12; int screen_w = 500, screen_h = 500; const int pixel_w = 320, pixel_h = 180; unsigned char buffer[pixel_w * pixel_h * bpp / 8]; // SDL_USEREVENT是SDL库中预定义的一个用户事件起始值 // 刷新事件 #define REFRESH_EVENT (SDL_USEREVENT + 1) // 中断事件 #define BREAK_EVENT (SDL_USEREVENT + 2) // 线程退出标志 int thread_exit = 0; int refresh_video(void *opaque) { thread_exit = 0; while (!thread_exit) { SDL_Event event; event.type = REFRESH_EVENT; SDL_PushEvent(\u0026amp;event); SDL_Delay(40); } thread_exit = 0; // 推送一个退出主线程的事件 SDL_Event event; event.type = BREAK_EVENT; SDL_PushEvent(\u0026amp;event); return 0; } int main(int argc, char *argv[]) { // 初始化 SDL 库 if (SDL_Init(SDL_INIT_VIDEO)) { printf(\u0026#34;Could not initialize SDL - %s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个窗口 SDL_Window *screen; // SDL 2.0 Support for multiple windows screen = SDL_CreateWindow(\u0026#34;Simplest Video Play SDL2\u0026#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, screen_w, screen_h, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE); if (!screen) { printf(\u0026#34;SDL: could not create window - exiting:%s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个渲染器，将窗口与渲染器关联 SDL_Renderer *sdlRenderer = SDL_CreateRenderer(screen, -1, 0); Uint32 pixformat = 0; // IYUV: Y + U + V (3 planes) // YV12: Y + V + U (3 planes) // 设置像素格式 // SDL_PIXELFORMAT_IYUV 表示使用 YUV420 pixformat = SDL_PIXELFORMAT_IYUV; // 创建纹理，用于存储视频数据 SDL_Texture *sdlTexture = SDL_CreateTexture(sdlRenderer, pixformat, SDL_TEXTUREACCESS_STREAMING, pixel_w, pixel_h); // 打开 YUV 文件 FILE *fp = NULL; fp = fopen(\u0026#34;../video/test_yuv420p_320x180.yuv\u0026#34;, \u0026#34;rb+\u0026#34;); if (fp == NULL) { printf(\u0026#34;cannot open this file\\n\u0026#34;); return -1; } SDL_Rect sdlRect; // 创建一个子线程，用于定时触发视频刷新事件 // 第一个参数是函数指针 SDL_Thread *refresh_thread = SDL_CreateThread(refresh_video, NULL, NULL); SDL_Event event; while (1) { // 等待事件 SDL_WaitEvent(\u0026amp;event); if (event.type == REFRESH_EVENT) { if (fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp) != pixel_w * pixel_h * bpp / 8) { // Loop fseek(fp, 0, SEEK_SET); fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp); } SDL_UpdateTexture(sdlTexture, NULL, buffer, pixel_w); // FIX: If window is resize sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w/2; sdlRect.h = screen_h/2; SDL_RenderClear(sdlRenderer); SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, \u0026amp;sdlRect); SDL_RenderPresent(sdlRenderer); } // SDL_WINDOWEVENT 当窗口大小改变时，更新屏幕宽度和高度 else if (event.type == SDL_WINDOWEVENT) { // window SDL_GetWindowSize(screen, \u0026amp;screen_w, \u0026amp;screen_h); } // 当用户关闭窗口时，设置退出标志使子线程退出 else if (event.type == SDL_QUIT) { thread_exit = 1; } // 当接收到退出事件时，退出主循环并释放资源 // 这个退出事件由子线程提供 else if (event.type == BREAK_EVENT) { break; } } SDL_Quit(); return 0; } CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 指定 CMake 的最低版本要求 cmake_minimum_required(VERSION 3.10) # 设置项目名称和版本 project(MyProject VERSION 1.0) # 设置 C++ 标准 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_BUILD_TYPE Debug) # 依赖 compile_commands.json 文件来理解项目的编译环境 set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 添加头文件路径 include_directories(${PROJECT_SOURCE_DIR}/include) # 添加库文件路径 link_directories(${PROJECT_SOURCE_DIR}/lib) # 添加可执行文件 add_executable(main src/videoPlayer.cpp) # 链接 FFmpeg 库 target_link_libraries(main avcodec avformat avutil) # 链接 SDL2 库· target_link_libraries(main SDL2 SDL2main) 练习 空格暂停功能 这里还添加了加速功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 #include \u0026#34;SDL2/SDL_events.h\u0026#34; #include \u0026#34;SDL2/SDL_keycode.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; extern \u0026#34;C\u0026#34; { #include \u0026#34;SDL2/SDL.h\u0026#34; }; const int bpp = 12; int screen_w = 500, screen_h = 500; const int pixel_w = 320, pixel_h = 180; unsigned char buffer[pixel_w * pixel_h * bpp / 8]; // SDL_USEREVENT是SDL库中预定义的一个用户事件起始值 // 刷新事件 #define REFRESH_EVENT (SDL_USEREVENT + 1) // 中断事件 #define BREAK_EVENT (SDL_USEREVENT + 2) // 暂停事件 #define PAUSE_EVENT (SDL_USEREVENT + 3) // 线程退出标志 int thread_exit = 0; // 暂停标志 bool video_paused = false; bool video_fast = false; int refresh_video(void *opaque) { thread_exit = 0; while (!thread_exit) { SDL_Event event; if (!video_fast \u0026amp;\u0026amp; !video_paused) { event.type = REFRESH_EVENT; SDL_PushEvent(\u0026amp;event); SDL_Delay(40); } else if(video_paused) { event.type = PAUSE_EVENT; SDL_PushEvent(\u0026amp;event); } else if (video_fast) { event.type = REFRESH_EVENT; SDL_PushEvent(\u0026amp;event); SDL_Delay(1); } } // 确保线程成功退出 thread_exit = 0; // 推送一个退出主线程的事件 SDL_Event event; event.type = BREAK_EVENT; SDL_PushEvent(\u0026amp;event); return 0; } int main(int argc, char *argv[]) { // 初始化 SDL 库 if (SDL_Init(SDL_INIT_VIDEO)) { printf(\u0026#34;Could not initialize SDL - %s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个窗口 SDL_Window *screen; // SDL 2.0 Support for multiple windows screen = SDL_CreateWindow(\u0026#34;Simplest Video Play SDL2\u0026#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, screen_w, screen_h, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE); if (!screen) { printf(\u0026#34;SDL: could not create window - exiting:%s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建一个渲染器，将窗口与渲染器关联 SDL_Renderer *sdlRenderer = SDL_CreateRenderer(screen, -1, 0); Uint32 pixformat = 0; // IYUV: Y + U + V (3 planes) // YV12: Y + V + U (3 planes) // 设置像素格式 // SDL_PIXELFORMAT_IYUV 表示使用 YUV420 pixformat = SDL_PIXELFORMAT_IYUV; // 创建纹理，用于存储视频数据 SDL_Texture *sdlTexture = SDL_CreateTexture(sdlRenderer, pixformat, SDL_TEXTUREACCESS_STREAMING, pixel_w, pixel_h); // 打开 YUV 文件 FILE *fp = NULL; fp = fopen(\u0026#34;../video/test_yuv420p_320x180.yuv\u0026#34;, \u0026#34;rb+\u0026#34;); if (fp == NULL) { printf(\u0026#34;cannot open this file\\n\u0026#34;); return -1; } SDL_Rect sdlRect; // 创建一个子线程，用于定时触发视频刷新事件 // 第一个参数是函数指针 SDL_Thread *refresh_thread = SDL_CreateThread(refresh_video, NULL, NULL); SDL_Event event; while (1) { // 等待事件 SDL_WaitEvent(\u0026amp;event); if (event.type == REFRESH_EVENT) { if (fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp) != pixel_w * pixel_h * bpp / 8) { // Loop fseek(fp, 0, SEEK_SET); fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp); } SDL_UpdateTexture(sdlTexture, NULL, buffer, pixel_w); // FIX: If window is resize sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; SDL_RenderClear(sdlRenderer); SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, \u0026amp;sdlRect); SDL_RenderPresent(sdlRenderer); } // SDL_WINDOWEVENT 当窗口大小改变时，更新屏幕宽度和高度 else if (event.type == SDL_WINDOWEVENT) { // window SDL_GetWindowSize(screen, \u0026amp;screen_w, \u0026amp;screen_h); } // 当用户关闭窗口时，设置退出标志使子线程退出 else if (event.type == SDL_QUIT) { thread_exit = 1; } // 当接收到退出事件时，退出主循环并释放资源 // 这个退出事件由子线程提供 else if (event.type == BREAK_EVENT) { break; } else if (event.type == PAUSE_EVENT) { // 什么都不做，等待响应 } else if (event.type == SDL_KEYDOWN) { if (event.key.keysym.sym == SDLK_SPACE) { video_paused = !video_paused; } if (event.key.keysym.sym == SDLK_ESCAPE) { thread_exit = 1; } if (event.key.keysym.sym == SDLK_BACKSPACE) { video_fast = !video_fast; } } } SDL_Quit(); return 0; } 黑白显示 在调用SDL_UpdateTexture之前，我添加代码来修改 U 和 V 分量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if (fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp) != pixel_w * pixel_h * bpp / 8) { // Loop fseek(fp, 0, SEEK_SET); fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp); } // 修改UV分量为中性值（128）以实现黑白效果 int y_size = pixel_w * pixel_h; unsigned char* u_plane = buffer + y_size; unsigned char* v_plane = buffer + y_size + (y_size / 4); // IYUV格式下U和V各占1/4 // 将所有U分量设置为128 memset(u_plane, 0x80, y_size / 4); // 将所有V分量设置为128 memset(v_plane, 0x80, y_size / 4); y_size 是 Y 的大小 u_plane 是 U 的起始位置（加上 Y 的大小） v_plane 是 V 的起始位置（加上 Y 和 U 的大小） memset 用于将一块内存区域填充成指定的字符，原型：\n1 void *memset(void *str, int c, size_t n); str: 要填充的内存地址 c: 填充的字符 n: 要填充的字符数量 在 YUV 颜色空间中，通过将 U 和 V 分量设置为中性值（通常是128，即0x80）来实现黑白显示，是基于以下原理：\nYUV 含义: Y (Luminance) : 表示图像的亮度信息 U (Chrominance) : 表示颜色的蓝色偏移 V (Chrominance) : 表示颜色的红色偏移 中性值： 在大多数 YUV 格式中， U 和 V 的中性值是 128（十六进制 0x80 ）。当 U = 128 且 V = 128 时，表示没有蓝色或红色的偏移，即纯灰度信号 YUV 到 RGB 的转换过程：\n1 2 3 R = Y + V - 128 G = Y - (U/2 + V/2) + 128 B = Y + U - 128 当 U = 128 且 V = 128 时：\n1 2 3 R = Y + 0 G = Y + 0 B = Y + 0 因此，R = G = B = Y ，生成灰度图像\n","date":"2025-02-25T00:00:00Z","image":"https://serennan.github.io/post/leixiaohua-note-3/cover.jpg","permalink":"https://serennan.github.io/post/leixiaohua-note-3/","title":"【雷霄骅课程笔记】3 SDL 视频播放器-进阶"},{"content":"SDL 视频播放 视频链接 SDL 介绍 SDL 视频显示流程 流程图 函数介绍 函数名 功能描述 SDL_Init() 初始化SDL系统 SDL_CreateWindow() 创建窗口 SDL_Window SDL_CreateRenderer() 创建渲染器 SDL_Renderer SDL_CreateTexture() 创建纹理 SDL_Texture SDL_UpdateTexture() 设置纹理的数据 SDL_RenderCopy() 将纹理的数据拷贝给渲染器 SDL_RenderPresent() 显示 SDL_Delay() 工具函数，用于延时 SDL_Quit() 退出SDL系统 SDL 视频显示的数据结构 解释：\nSDL_Texture：纹理，一个纹理对应一个 YUV 一个窗口不一定只有一个纹理，可以放很多个 SDL_Rect ： SDL 中的一个结构体，用于描述一个矩形的位置和尺寸 SDL_Renderer：渲染器，把纹理的数据给窗口 SDL_Window：窗口 代码运行 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #include \u0026lt;stdio.h\u0026gt; extern \u0026#34;C\u0026#34; { #include \u0026#34;SDL2/SDL.h\u0026#34; }; const int bpp = 12; // 窗口的宽度和高度 int screen_w = 1000, screen_h = 1000; // 视频像素的宽度和高度 const int pixel_w = 320, pixel_h = 180; // 用于存储一帧 YUV 数据的缓冲区 unsigned char buffer[pixel_w * pixel_h * bpp / 8]; int main(int argc, char *argv[]) { // 初始化 SDL 库 if (SDL_Init(SDL_INIT_VIDEO)) { printf(\u0026#34;Could not initialize SDL - %s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建窗口 SDL_Window *screen; // SDL 2.0 Support for multiple windows // title 窗口标题，x y 窗口位置，w h 窗口大小 // flags 标志包括允许改变窗口大小（SDL_WINDOW_RESIZABLE）和使用OpenGL（SDL_WINDOW_OPENGL screen = SDL_CreateWindow(\u0026#34;Simplest Video Play SDL2\u0026#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_UNDEFINED, screen_w, screen_h, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE); if (!screen) { printf(\u0026#34;SDL: could not create window - exiting:%s\\n\u0026#34;, SDL_GetError()); return -1; } // 创建渲染器，将窗口与渲染器关联 // index 使用默认的渲染驱动，flags 标志为 0 （不使用加速功能） SDL_Renderer *sdlRenderer = SDL_CreateRenderer(screen, -1, 0); Uint32 pixformat = 0; // IYUV: Y + U + V (3 planes) // YV12: Y + V + U (3 planes) // 设置像素格式 // SDL_PIXELFORMAT_IYUV 表示使用 YUV420 pixformat = SDL_PIXELFORMAT_IYUV; // 创建纹理，用于存储视频数据 // pixformat 使用之前设置的像素格式 IYUV，access 纹理访问模式为流式访问（适合频繁更新纹理数据） // w h 纹理宽度和高度 SDL_Texture *sdlTexture = SDL_CreateTexture(sdlRenderer, pixformat, SDL_TEXTUREACCESS_STREAMING, pixel_w, pixel_h); FILE *fp = NULL; fp = fopen(\u0026#34;../video/test_yuv420p_320x180.yuv\u0026#34;, \u0026#34;rb+\u0026#34;); if (fp == NULL) { printf(\u0026#34;cannot open this file\\n\u0026#34;); return -1; } SDL_Rect sdlRect; while (1) { // 从文件中读取一帧 YUV 数据到 buffer 中 if (fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp) != pixel_w * pixel_h * bpp / 8) { // 重新定位文件指针实现循环播放 fseek(fp, 0, SEEK_SET); fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp); } // 更新纹理中的数据，将 buffer 中的内容传递给纹理 // pitch 每行像素占用的字节数 SDL_UpdateTexture(sdlTexture, NULL, buffer, pixel_w); // 设置渲染区域 // 这表示这个矩形从屏幕的左上角(0, 0)开始，宽度和高度与屏幕相同，即覆盖整个屏幕 sdlRect.x = 10; sdlRect.y = 10; sdlRect.w = screen_w - 20; sdlRect.h = screen_h - 20; // 清楚渲染器 SDL_RenderClear(sdlRenderer); // 复制纹理到渲染器 SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, \u0026amp;sdlRect); // 呈现渲染结果 // 将渲染器中的后缓冲区内容呈现到前缓冲区，即更新屏幕显示内容 SDL_RenderPresent(sdlRenderer); // 延迟以控制帧率 SDL_Delay(40); } SDL_Quit(); return 0; } 这里讲一下循环中读取数据到 buffer\n1 if (fread(buffer, 1, pixel_w * pixel_h * bpp / 8, fp) != pixel_w 第二个参数是每个元素的字节数，第三个参数是要读取的元素数量\n成功读取的话是返回读取的元素数量\n元素数量是视频宽度 * 视频高度 * 每像素占用的位数（bpp） bpp （Bits Per Pixel）的计算如下：\nY（亮度）平面：每个像素占8位。 U（色度）平面：每个像素占8位，但水平和垂直方向各下采样一倍，因此每个宏像素的 U 和 V 各占4位。 V（色度）平面：同上。 所以总共有：\nY 平面：width × height × 8 位 U 平面：(width/2) × (height/2) × 8 位 V 平面：(width/2) × (height/2) × 8 位 总位数为：\nwidth × height × 8 + (width/2) × (height/2) × 8 × 2 = width × height × (8 + 2 + 2) = width × height × 12 位\n因此，每个像素平均占用12位。\nCMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 指定 CMake 的最低版本要求 cmake_minimum_required(VERSION 3.10) # 设置项目名称和版本 project(MyProject VERSION 1.0) # 设置 C++ 标准 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_BUILD_TYPE Debug) # 依赖 compile_commands.json 文件来理解项目的编译环境 set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 添加头文件路径 include_directories(${PROJECT_SOURCE_DIR}/include) # 添加库文件路径 link_directories(${PROJECT_SOURCE_DIR}/lib) # 添加可执行文件 add_executable(main src/videoPlayer.cpp) # 链接 FFmpeg 库 target_link_libraries(main avcodec avformat avutil) # 链接 SDL2 库· target_link_libraries(main SDL2 SDL2main) ","date":"2025-02-24T00:00:00Z","image":"https://serennan.github.io/post/leixiaohua-note-2/cover.jpg","permalink":"https://serennan.github.io/post/leixiaohua-note-2/","title":"【雷霄骅课程笔记】2 SDL 视频播放器"},{"content":"视频解码器 视频链接 FFmpeg 介绍 FFmpeg 库 FFmpeg 一共包含 8 个库：\navcodec: 编解码（最重要的库）* avformat: 封装格式处理 * avfilter: 滤镜特效处理 avdevice: 各种设备的输入输出 avutil: 工具库（大部分库都需要这个库的支持）* postproc: 后加工 swresample: 音频采样数据格式转换 swscale: 视频像素数据格式转换 * 其中 * 表示本次课程中会涉及到的库\nFFmpeg 解码流程 流程图 函数介绍 函数名 功能描述 avformat_open_input 打开输入文件并创建 AVFormatContext avformat_find_stream_info 获取流信息 avcodec_find_decoder 查找解码器 avcodec_alloc_context3 分配解码器上下文 avcodec_parameters_to_context 复制编解码器参数 avcodec_open2 打开解码器 av_read_frame 读取数据包 avcodec_send_packet 发送数据包到解码器 avcodec_receive_frame 接收解码后的帧 sws_scale 像素格式转换 fwrite 写入转换后的帧数据 av_packet_unref 释放数据包 avcodec_free_context 释放解码器上下文 avformat_close_input 关闭输入流 FFmpeg 解码的数据结构 AV 表示 Audio Video\nAVFormatContext: 用于处理封装格式的上下文，包含视频最外层的信息\nAVInputFormat: 输入格式\nAVStream: 是一个数组，包含多个流，但是一般就包含视频流和音频流，第 0 个是视频流，第 1 个是音频流\nAVCodecContext: 编解码器上下文\nAVCodec: 编解码器，指明编码器的类型（h.264之类的）\nAVPacket: 压缩编码后的数据包 AVFrame: 解码后的数据包\nAVPacket 解码完为 AVFrame\nAVFormatContext 用于处理封装格式的上下文，包含视频最外层的信息\niformat: 输入视频的 AVInputFormat nb_streams: 输入视频的 AVStream 个数 streams: 输入视频的 AVStream 数组 duration: 输入视频的时长（以微秒为单位） bit_rate: 输入视频的码率 AVInputFormat 输入格式\nname: 输入视频的格式名称 long_name: 输入视频格式的长名称 extensions: 输入视频格式的扩展名 id: 输入视频格式的 ID 一些封装格式处理的接口函数 AVStream 是一个数组，包含多个流，但是一般就包含视频流和音频流，第 0 个是视频流，第 1 个是音频流\nid: 输入视频流的 ID codecpar: 输入视频流的 AVCodecContext time_base: 输入视频流的时间基 r_frame_rate: 输入视频流的帧率 time_base 是一个分数，表示时间基，用于将时间戳转换为实际时间。 r_frame_rate 是一个分数，表示帧率，用于计算帧间隔时间。\nAVCodecContext 编解码器上下文\ncodec：编解码器的 AVCodec width, height: 图像的宽高 pix_fmt: 图像的像素格式 sample_rate: 音频的采样率 channels: 音频的声道数 sample_fmt: 音频的采样格式 codec_type: 编解码器的类型（视频、音频等） codec_id: 编解码器的 ID AVCodec 编解码器，指明编码器的类型（h.264之类的）\nname: 编解码器的名称 long_name: 编解码器的全称 id: 编解码器的 ID 一些编解码的接口函数 AVPacket 压缩编码后的数据包，理解成装 h264 数据的盒子\npts: 显示时间戳 dts: 解码时间戳 data: 压缩编码的数据 size: 数据的大小 stream_index: 所属的 AVStream （音频流还是视频流） AVFrame 解码后的数据包，理解成装 yuv 数据的盒子\ndata: 解码后的图像数据（音频采样数据） linesize: 对视频来说是图像中的一行像素的大小；对音频来说是整个音频帧的大小 width, height: 视频帧的宽和高 key_frame: 是否是关键帧 pict_type: 帧类型（I, B, P 帧） 补充小知识 解码后的数据为什么要经过 sws_scale 转换？ 解码后 YUV 数据格式的视频像素数据保存在 AVFrame 的 data[0]，data[1]，data[2]，但是这些像素值并不是连续存储的，每行有效像素之后存储的是无效像素。 以亮度 Y 数据为例，data[0] 中一共包含了 linesize[0] * height 个数据。但是出于优化等方面考虑，linesize[0] 可能大于 width 。因此需要使用 sws_scale 进行转换。\n转换后去除了无效数据，width 和 linesize[0] 就相等了。\n代码运行 雷神给的这些代码，在资源释放上有些问题（资源的释放都集中在最后，如果程序提前终止，那就导致资源没有释放），但这里先不考虑这些。\n代码 头文件 lib 和库文件 include 的配置在前面博客说到，可以复制到这个项目中（上一个博客我讲的是放在 usr/local/ffmpeg ） 这里代码和雷神视频中的代码略有不同，修改了很多：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 #include \u0026lt;stdio.h\u0026gt; #define __STDC_CONSTANT_MACROS #ifdef _WIN32 // Windows extern \u0026#34;C\u0026#34; { #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/imgutils.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; }; #else // Linux... #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif #include \u0026lt;libavcodec/avcodec.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavutil/imgutils.h\u0026gt; #include \u0026lt;libswscale/swscale.h\u0026gt; #ifdef __cplusplus }; #endif #endif int main(int argc, char *argv[]) { AVFormatContext *pFormatCtx = NULL; int videoindex = -1; AVCodecContext *pCodecCtx = NULL; const AVCodec *pCodec = NULL; AVFrame *pFrame = NULL, *pFrameYUV = NULL; unsigned char *out_buffer = NULL; AVPacket *packet = NULL; int ret = 0; struct SwsContext *img_convert_ctx = NULL; char filepath[] = \u0026#34;../video/input.mkv\u0026#34;; FILE *fp_yuv = fopen(\u0026#34;output.yuv\u0026#34;, \u0026#34;wb+\u0026#34;); // 初始化FFmpeg库 avformat_network_init(); // 打开输入文件 if (avformat_open_input(\u0026amp;pFormatCtx, filepath, NULL, NULL) != 0) { printf(\u0026#34;Couldn\u0026#39;t open input stream.\\n\u0026#34;); return -1; } // 获取流信息 if (avformat_find_stream_info(pFormatCtx, NULL) \u0026lt; 0) { printf(\u0026#34;Couldn\u0026#39;t find stream information.\\n\u0026#34;); return -1; } printf(\u0026#34;时长：%ld\\n\u0026#34;, pFormatCtx-\u0026gt;duration); // 查找视频流 for (int i = 0; i \u0026lt; pFormatCtx-\u0026gt;nb_streams; i++) { if (pFormatCtx-\u0026gt;streams[i]-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { videoindex = i; break; } } if (videoindex == -1) { printf(\u0026#34;Didn\u0026#39;t find a video stream.\\n\u0026#34;); return -1; } // 获取解码器 pCodec = avcodec_find_decoder(pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar-\u0026gt;codec_id); if (pCodec == NULL) { printf(\u0026#34;Codec not found.\\n\u0026#34;); return -1; } // 创建解码器上下文 pCodecCtx = avcodec_alloc_context3(pCodec); if (!pCodecCtx) { printf(\u0026#34;Could not allocate video codec context\\n\u0026#34;); return -1; } // 复制流参数到解码器上下文 if (avcodec_parameters_to_context(pCodecCtx, pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar) \u0026lt; 0) { printf(\u0026#34;Could not copy codec parameters to context\\n\u0026#34;); return -1; } // 打开解码器 if (avcodec_open2(pCodecCtx, pCodec, NULL) \u0026lt; 0) { printf(\u0026#34;Could not open codec.\\n\u0026#34;); return -1; } pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); out_buffer = (unsigned char *)av_malloc( av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1)); av_image_fill_arrays(pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1); packet = av_packet_alloc(); // 输出文件信息 printf(\u0026#34;--------------- File Information ----------------\\n\u0026#34;); av_dump_format(pFormatCtx, 0, filepath, 0); printf(\u0026#34;-------------------------------------------------\\n\u0026#34;); img_convert_ctx = sws_getContext(pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, pCodecCtx-\u0026gt;pix_fmt, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); while (av_read_frame(pFormatCtx, packet) \u0026gt;= 0) { if (packet-\u0026gt;stream_index == videoindex) { ret = avcodec_send_packet(pCodecCtx, packet); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending a packet for decoding\\n\u0026#34;); return -1; } while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; // U V 是分量，宽高各压缩一半，所以大小是 Y 的 1/4 fwrite(pFrameYUV-\u0026gt;data[0], 1, y_size, fp_yuv); // Y fwrite(pFrameYUV-\u0026gt;data[1], 1, y_size / 4, fp_yuv); // U fwrite(pFrameYUV-\u0026gt;data[2], 1, y_size / 4, fp_yuv); // V printf(\u0026#34;Succeed to decode 1 frame!\\n\u0026#34;); } } av_packet_unref(packet); } // 刷新解码器 avcodec_send_packet(pCodecCtx, NULL); while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; fwrite(pFrameYUV-\u0026gt;data[0], 1, y_size, fp_yuv); // Y fwrite(pFrameYUV-\u0026gt;data[1], 1, y_size / 4, fp_yuv); // U fwrite(pFrameYUV-\u0026gt;data[2], 1, y_size / 4, fp_yuv); // V printf(\u0026#34;Flush Decoder: Succeed to decode 1 frame!\\n\u0026#34;); } sws_freeContext(img_convert_ctx); fclose(fp_yuv); av_frame_free(\u0026amp;pFrameYUV); av_frame_free(\u0026amp;pFrame); av_packet_free(\u0026amp;packet); avcodec_free_context(\u0026amp;pCodecCtx); avformat_close_input(\u0026amp;pFormatCtx); return 0; } CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 cmake_minimum_required(VERSION 3.10) project(MyProject VERSION 1.0) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_BUILD_TYPE DEBUG) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 添加头文件路径 include_directories(${PROJECT_SOURCE_DIR}/include) # 添加库文件路径 link_directories(${PROJECT_SOURCE_DIR}/lib) # 添加可执行文件 add_executable(main src/decoder.cpp) # 链接 FFmpeg 库 target_link_libraries(main avcodec avformat avutil swscale ) 手动编译一遍：\n1 2 3 4 5 mkdir build cd build cmake .. make ./main 如果成功输出，则说明配置成功\n没成功的话要注意看一下源码的路径和播放视频的路径是否正确\n我这里源码放在 src/decoder.cpp，播放视频放在video/input.mkv\n调试 在左侧工具栏找到运行和调试工具\n点击创建 launch.json 文件，选择C++(GDB/LLDB)\n在launch.json文件中添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;(gdb) Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/build/main\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}/build\u0026#34;, \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;cmake-build-debug\u0026#34; } ] } 按下 f5 即可调试\n这里可能会遇到两个问题：\n在源码位置按下 f5 后，会提示找不到找不到你链接的库\n这里可能原因是没执行你的 CMakeLists.txt 文件，换成点击左侧工具栏的启动按键就行\n提示找不到输入文件，可以试试去掉 json 中 cwd 字段的 /build：\n1 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; 后续博客就不讲调试的文件书写了，基本都差不多\n练习 获取解码前的 h264 文件 注意这里只获取 MPEG-TS ，AVI 格式的文件，如果是别的文件，无法直接获取\n这样重新编码后，就可以获取到解码前的 h264 文件了。\n代码分析 打开文件 1 FILE *fp_h264 = fopen(\u0026#34;test264.h264\u0026#34;, \u0026#34;wb+\u0026#34;); 循环从媒体文件中读取一帧数据，并将其存储在 AVPacket 结构体中。 1 while (av_read_frame(pFormatCtx, packet) \u0026gt;= 0) 这个函数会读取下一个可用的数据包，无论是音频、视频还是其他类型的流 判断是否为视频帧 1 if (packet-\u0026gt;stream_index == videoindex) 获取数据 1 fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, fp_h264); 关闭文件，释放资源 注意事项 输入文件一定要是 ts 或 avi 格式！\n因为 mp4 和 flv 格式需要解析 moov 结构，而 ts 和 avi 格式可以直接解析 h264 数据\n我就是一开始没注意，导致浪费了很多时间\n获取完数据记得释放资源和关闭文件\n获取解码后的 yuv 文件 打开文件 1 FILE *fp_yuv = fopen(\u0026#34;testyuv.yuv\u0026#34;, \u0026#34;wb+\u0026#34;); 循环从媒体文件中读取一帧数据，并将其存储在 AVPacket 结构体中。 1 while (av_read_frame(pFormatCtx, packet) \u0026gt;= 0) 判断当前帧是否为视频流 1 if (packet-\u0026gt;stream_index == video_index) 解码一帧视频数据 1 avcodec_send_packet(pCodecCtx, packet); 这个函数会将 AVPacket 中的压缩数据发送给解码器进行解码 接收解码后的数据 1 2 ret == avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; 这个函数会从解码器中接收解码后的原始数据，并存储在 AVFrame 结构体中 AVERROR(EAGAIN) 是FFmpeg库中的一个错误码，表示当前没有足够的数据可供解码，需要等待更多数据到来才能继续解码。这种情况通常发生在数据流尚未准备好或缓冲区为空时 AVERROR_EOF 表示已经到达数据流的末尾（End of File），没有更多的数据可供解码 处理解码后的数据 1 2 3 4 5 6 7 img_convert_ctx = sws_getContext(pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, pCodecCtx-\u0026gt;pix_fmt, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); 前面补充知识有提到，解码后的数据格式的视频像素值不是连续存储，而是按行存储的，会多出一些无效像素，导致像素的 width 和 linesize 不一致，要用 sws_scale 函数进行转换\nsws_getContext 函数\n用途：创建图像转换上下文 (SwsContext) 参数说明： pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height：原始视频帧的宽度和高度 pCodecCtx-\u0026gt;pix_fmt：原始视频帧的像素格式 AV_PIX_FMT_YUV420P：目标像素格式，此处为 YUV420P SWS_BICUBIC：缩放算法，使用双三次插值 sws_scale 函数\n用途：执行实际的图像格式转换 参数说明： img_convert_ctx：之前创建的图像转换上下文 (const unsigned char *const *)pFrame-\u0026gt;data：原始视频帧的数据 pFrame-\u0026gt;linesize：原始视频帧的每行字节数 0：从原始帧的第 0 行开始转换 pCodecCtx-\u0026gt;height：原始视频帧的高度 pFrameYUV-\u0026gt;data：目标帧的数据缓冲区，用于存储转换后的 YUV420P 数据 pFrameYUV-\u0026gt;linesize：目标帧的每行字节数 保存 YUV 数据到文件 1 2 3 4 5 int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; fwrite(pFrameYUV-\u0026gt;data[0], 1, y_size, fp_yuv); // Y // U V 是分量，宽高各压缩一半，所以大小是 Y 的 1/4 fwrite(pFrameYUV-\u0026gt;data[1], 1, y_size / 4, fp_yuv); // U fwrite(pFrameYUV-\u0026gt;data[2], 1, y_size / 4, fp_yuv); // V 关闭文件，释放资源 完整代码 代码优化了一些，也把一些要求输出的信息写在里面了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 #include \u0026lt;stdio.h\u0026gt; #define __STDC_CONSTANT_MACROS #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif #include \u0026lt;libavcodec/avcodec.h\u0026gt; #include \u0026lt;libavcodec/bsf.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavutil/imgutils.h\u0026gt; #include \u0026lt;libswscale/swscale.h\u0026gt; #ifdef __cplusplus } #endif int main(int argc, char *argv[]) { AVFormatContext *pFormatCtx = NULL; int videoindex = -1; AVCodecContext *pCodecCtx = NULL; const AVCodec *pCodec = NULL; AVFrame *pFrame = NULL, *pFrameYUV = NULL; unsigned char *out_buffer = NULL; AVPacket *packet = NULL; int ret = 0; struct SwsContext *img_convert_ctx = NULL; char filepath[] = \u0026#34;../video/Titanic.ts\u0026#34;; // 初始化FFmpeg库 avformat_network_init(); // 打开输入文件 if (avformat_open_input(\u0026amp;pFormatCtx, filepath, NULL, NULL) != 0) { printf(\u0026#34;Couldn\u0026#39;t open input stream.\\n\u0026#34;); return -1; } // 获取流信息 if (avformat_find_stream_info(pFormatCtx, NULL) \u0026lt; 0) { printf(\u0026#34;Couldn\u0026#39;t find stream information.\\n\u0026#34;); return -1; } // 输出封装格式参数 FILE *fp = fopen(\u0026#34;output.txt\u0026#34;, \u0026#34;wb+\u0026#34;); fprintf(fp, \u0026#34;封装格式参数：\\n\u0026#34;); fprintf(fp, \u0026#34; 封装格式：%s\\n 比特率：%ld\\n 时长：%ld\\n\u0026#34;, pFormatCtx-\u0026gt;iformat-\u0026gt;name, pFormatCtx-\u0026gt;bit_rate, pFormatCtx-\u0026gt;duration); // 查找视频流 for (int i = 0; i \u0026lt; pFormatCtx-\u0026gt;nb_streams; i++) { if (pFormatCtx-\u0026gt;streams[i]-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { videoindex = i; break; } } if (videoindex == -1) { printf(\u0026#34;Didn\u0026#39;t find a video stream.\\n\u0026#34;); return -1; } // 输出视频编码参数 fprintf(fp, \u0026#34;视频编码参数：\\n\u0026#34;); fprintf(fp,\u0026#34; 编码方式：%s\\n 宽*高：%d * %d\\n\u0026#34;, avcodec_get_name(pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar-\u0026gt;codec_id),pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar-\u0026gt;width,pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar-\u0026gt;height); // 获取解码器 pCodec = avcodec_find_decoder(pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar-\u0026gt;codec_id); if (pCodec == NULL) { printf(\u0026#34;Codec not found.\\n\u0026#34;); return -1; } // 创建解码器上下文 pCodecCtx = avcodec_alloc_context3(pCodec); if (!pCodecCtx) { printf(\u0026#34;Could not allocate video codec context\\n\u0026#34;); return -1; } // 复制流参数到解码器上下文 if (avcodec_parameters_to_context(pCodecCtx, pFormatCtx-\u0026gt;streams[videoindex]-\u0026gt;codecpar) \u0026lt; 0) { printf(\u0026#34;Could not copy codec parameters to context\\n\u0026#34;); return -1; } // 打开解码器 if (avcodec_open2(pCodecCtx, pCodec, NULL) \u0026lt; 0) { printf(\u0026#34;Could not open codec.\\n\u0026#34;); return -1; } pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); out_buffer = (unsigned char *)av_malloc( av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1)); av_image_fill_arrays(pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, 1); packet = av_packet_alloc(); // 输出文件信息 printf(\u0026#34;--------------- File Information ----------------\\n\u0026#34;); av_dump_format(pFormatCtx, 0, filepath, 0); printf(\u0026#34;-------------------------------------------------\\n\u0026#34;); img_convert_ctx = sws_getContext(pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, pCodecCtx-\u0026gt;pix_fmt, pCodecCtx-\u0026gt;width, pCodecCtx-\u0026gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); FILE *fp_h264 = fopen(\u0026#34;1test264.h264\u0026#34;, \u0026#34;wb+\u0026#34;); FILE *fp_yuv = fopen(\u0026#34;1testyuv.yuv\u0026#34;, \u0026#34;wb+\u0026#34;); fprintf(fp, \u0026#34;--------每一个解码前视频帧大小和解码后帧类型：-------------\\n\u0026#34;); while (av_read_frame(pFormatCtx, packet) \u0026gt;= 0) { if (packet-\u0026gt;stream_index == videoindex) { // 获取解码前的 H.264 码流数据 fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, fp_h264); // 获取解码前视频帧参数 fprintf(fp, \u0026#34;帧大小:%d\\n\u0026#34;,packet-\u0026gt;size); ret = avcodec_send_packet(pCodecCtx, packet); if (ret \u0026lt; 0) { printf(\u0026#34;Error sending a packet for decoding\\n\u0026#34;); return -1; } while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; fwrite(pFrameYUV-\u0026gt;data[0], 1, y_size, fp_yuv); // Y // U V 是分量，所以大小是 Y 的 1/4 fwrite(pFrameYUV-\u0026gt;data[1], 1, y_size / 4, fp_yuv); // U fwrite(pFrameYUV-\u0026gt;data[2], 1, y_size / 4, fp_yuv); // V printf(\u0026#34;Succeed to decode 1 frame!\\n\u0026#34;); if (pFrame-\u0026gt;pict_type == AV_PICTURE_TYPE_I) { fprintf(fp, \u0026#34;帧类型：I帧\\n\u0026#34;); } else if (pFrame-\u0026gt;pict_type == AV_PICTURE_TYPE_P) { fprintf(fp, \u0026#34;帧类型：P帧\\n\u0026#34;); } else if (pFrame-\u0026gt;pict_type == AV_PICTURE_TYPE_B) { fprintf(fp, \u0026#34;帧类型：B帧\\n\u0026#34;); } else { fprintf(fp, \u0026#34;帧类型：未知帧\\n\u0026#34;); } } } av_packet_unref(packet); } fclose(fp); fclose(fp_h264); fclose(fp_yuv); // 刷新解码器 avcodec_send_packet(pCodecCtx, NULL); while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(pCodecCtx, pFrame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break; else if (ret \u0026lt; 0) { printf(\u0026#34;Error during decoding\\n\u0026#34;); return -1; } sws_scale(img_convert_ctx, (const unsigned char *const *)pFrame-\u0026gt;data, pFrame-\u0026gt;linesize, 0, pCodecCtx-\u0026gt;height, pFrameYUV-\u0026gt;data, pFrameYUV-\u0026gt;linesize); int y_size = pCodecCtx-\u0026gt;width * pCodecCtx-\u0026gt;height; fwrite(pFrameYUV-\u0026gt;data[0], 1, y_size, fp_yuv); // Y fwrite(pFrameYUV-\u0026gt;data[1], 1, y_size / 4, fp_yuv); // U fwrite(pFrameYUV-\u0026gt;data[2], 1, y_size / 4, fp_yuv); // V printf(\u0026#34;Flush Decoder: Succeed to decode 1 frame!\\n\u0026#34;); } sws_freeContext(img_convert_ctx); // 这里的释放顺序要注意，先释放AVFrame，再释放AVPacket，最后释放AVCodecContext和AVFormatContext av_frame_free(\u0026amp;pFrameYUV); av_frame_free(\u0026amp;pFrame); av_packet_free(\u0026amp;packet); avcodec_free_context(\u0026amp;pCodecCtx); avformat_close_input(\u0026amp;pFormatCtx); return 0; } 资源释放问题后面会再出博客写，因为涉及到各种细节\n","date":"2025-02-18T00:00:00Z","image":"https://serennan.github.io/post/leixiaohua-note-1/cover.jpg","permalink":"https://serennan.github.io/post/leixiaohua-note-1/","title":"【雷霄骅课程笔记】1 FFmpeg 视频解码器"},{"content":"图片加载问题 问题描述 有时会遇到在本地图片能成功加载，但部署到服务器上却不能成功显示。\n我在弄代码折叠图片时遇到了这个问题\n在 html 文件上加载图片的代码语句是\n1 img.src = \u0026#39;{{ (resources.Get \u0026#34;img/codeMore.png\u0026#34;).Permalink }}\u0026#39;; 在本地成功加载\n但是到发布到服务端就不行了\n根本问题是服务端的图片加载路径出错\n按 f12 调出开发者工具查看（或者右键对应位置，点击检查，能快速跳转），会发现图片加载路径不是图片相对路径\n解决方案 将加载图片的代码语句改成\n1 img.src = \u0026#39;{{ (resources.Get \u0026#34;img/codeMore.png\u0026#34;).RelPermalink }}\u0026#39;; 把最后的 Permalink 改成 RelPermalink\n重新加载，会发现服务端正确显示\n重新用开发者工具检查加载路径\n正确显示图片相对位置\n","date":"2025-02-10T00:00:00Z","image":"https://serennan.github.io/post/hugo-problem/cover.jpg","permalink":"https://serennan.github.io/post/hugo-problem/","title":"【Hugo】常见问题"},{"content":"vscode 配置 FFmpeg 视频链接 这里的配置教程是另一处的，不是雷神的\n课程简介 雷神的课程主要使用 Visual Studio 进行演示，但由于我个人不太习惯使用 VS，因此我选择了在 WSL 环境下使用 VSCode 和 CMake 来进行学习和实践\nwindows 环境总是出现各种不必要的麻烦，而且其实 linux 环境对音视频开发者更友好\n配置过程些许复杂，但只要按照步骤来，不会有太大问题，有问题可以留言，我会尽力解答\n我使用的资料都是比较新的（2025年2月），所以博客的一些代码和流程什么的可能和雷神介绍的有些不同\nFFmpeg 配置 前提准备 安装好 Ubuntu 和 VSCode, 并且配置好 WSL 和 VSCode 的连接\n这里网上很多教程，就不多说了\n编译安装 创建安装目录：\n1 sudo mkdir -p /usr/local/ffmpeg 下载 FFmpeg 源码： 我这里都是用最新的 FFmpeg 源码\n点击链接：下载地址\n目前最新版是 7.1 ，而且我是 ubuntu 环境\n下载压缩包之后进行解压：（具体解压指令可以问问 ai ）\n1 tar -xv ffmpeg-7.1.tar.xz 解压完之后要进入目录：\n1 cd ffmpeg-7.1 然后进行配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ./configure \\ 0 (20.192s) \u0026lt; 14:23:34 --prefix=\u0026#39;/usr/local/ffmpeg\u0026#39; \\ --enable-gpl \\ --enable-nonfree \\ --enable-ffplay \\ --enable-libfdk-aac \\ --enable-libmp3lame \\ --enable-libx264 \\ --enable-libx265 \\ --enable-filter=delogo \\ --enable-debug \\ --disable-optimizations \\ --enable-libspeex \\ --enable-shared \\ --enable-pthreads \\ --enable-version3 \\ --enable-hardcoded-tables \\ --extra-cflags=\u0026#34;-I/usr/local/ffmpeg/include\u0026#34; \\ --extra-ldflags=\u0026#34;-L/usr/local/ffmpeg/lib\u0026#34; 这里可能会不断报错，显示缺各种库，那根据提示去安装对应库就行\n下载：\n1 2 3 4 sudo apt-get install libasound2-dev sudo apt-get install libpulse-dev sudo apt-get install libx11-dev sudo apt-get install xorg-dev 配置：\n1 ./configure --prefix=/usr/local/ffmpeg --enable-shared --enable-video-x11 --enable-x11-shared --enable-video-x11-vm ffplay 一直无法播放视频的话（因为我是用的wsl2），尝试在终端配置文件加上 SDL_RENDER_DRIVER=software\n在 fish 终端配置文件加\n1 set -x SDL_RENDER_DRIVER software 具体怎么加可以问问 ai\nCMake配置 安装 CMake 安装插件 CMake Tools\n书写 CMakeLists.txt 在 CMakeLists.txt 下写入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 指定 CMake 的最低版本要求 cmake_minimum_required(VERSION 3.10) # 设置项目名称和版本 project(MyProject VERSION 1.0) # 设置 C++ 标准 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) # 依赖 compile_commands.json 文件来理解项目的编译环境 set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # 设置 FFmpeg 库的路径 set(FFmpeg_DIR /usr/local/ffmpeg) # 添加项目中的头文件目录 include_directories(${FFmpeg_DIR}/include) # 添加库文件目录 link_directories(${FFmpeg_DIR}/lib) # 添加可执行文件（就是源码的位置） add_executable(main src/testffmpeg.cpp) # 链接 FFmpeg 库 target_link_libraries(main avcodec avformat avutil) 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 #define __STDC_CONSTANT_MACROS extern \u0026#34;C\u0026#34; { #include \u0026#34;libavcodec/avcodec.h\u0026#34; }; int main(int argc, char *argv[]) { printf(\u0026#34;%s\u0026#34;, avcodec_configuration()); return 0; } 编译 输入指令\n1 2 3 4 cd build cmake .. make ./main 如果成功输出，说明配置成功\n常见问题 解释器 如果成功输出了发现源文件仍然显示找不到头文件，可能是没安装好解释器，我使用的是 clangd，linux 环境安装很简单，问一下 ai 就行\n安装完成之后，clangd 会依赖 compile_commands.json 文件来理解项目的编译环境\n","date":"2025-02-10T00:00:00Z","image":"https://serennan.github.io/post/leixiaohua-note-0/cover.jpg","permalink":"https://serennan.github.io/post/leixiaohua-note-0/","title":"【雷霄骅课程笔记】0 配置"},{"content":"哈希表 map map是 C++ 标准库中的一个关联容器，用于存储键值对，键是唯一的，且按键的升序排列。\nm[key] = value：将键 key 对应的值设置为 value。 m.insert({key, value})：将键值对 {key, value} 插入到 map 中。 m.erase(key)：从 map 中删除键为 key 的元素。 m.count(key)：返回 map 中键为 key 的元素个数。 m.find(key)：返回指向 map 中键为 key 的元素的迭代器，如果 key 不存在则返回 m.end()。 m.lower_bound(key)：返回指向 map 中第一个不小于 key 的元素的迭代器。 m.upper_bound(key)：返回指向 map 中第一个大于 key 的元素的迭代器。 unordered_map unordered_map 是 C++ 标准库中的一个关联容器，用于存储键值对，键是唯一的。\numap[key] = value：将键 key 对应的值设置为 value。 umap.insert({key, value})：将键值对 {key, value} 插入到 unordered_map 中。 umap.erase(key)：从 unordered_map 中删除键为 key 的元素。 umap.count(key)：返回 unordered_map 中键为 key 的元素个数。 umap.find(key)：返回指向 unordered_map 中键为 key 的元素的迭代器，如果 key 不存在则返回 umap.end()。 umap.size()：返回 unordered_map 中元素的个数。 set set 是 C++ 标准库中的一个关联容器，用于存储唯一的元素。\n1 set\u0026lt;int\u0026gt; nums; nums.insert(x)：将元素 x 插入到集合 nums 中。 nums.erase(x)：从集合 nums 中删除元素 x。 nums.count(x)：返回集合 nums 中元素 x 的个数。 nums.find(x)：返回指向集合 nums 中元素 x 的迭代器，如果 x 不存在则返回 nums.end()。 nums.lower_bound(x)：返回指向集合 nums 中第一个不小于 x 的元素的迭代器。 emplace_back emplace_back 是 C++ 标准库中 std::vector、std::deque、std::list 等容器的一个成员函数，用于在容器的末尾直接构造一个元素，而不是先创建一个临时对象再插入。这样可以避免不必要的拷贝或移动操作，提高效率。\nqueue queue 是 C++ 标准库中的一个容器适配器，用于实现先进先出（FIFO）的队列。\n1 queue\u0026lt;int\u0026gt; q; q.push(x)：将元素 x 入队。 q.pop()：将队首元素出队。 q.front()：返回队首元素的引用。 q.back()：返回队尾元素的引用。 q.empty()：检查队列是否为空，返回布尔值。 q.size()：返回队列中元素的个数。 priority_queue priority_queue 是 C++ 标准库中的一个容器适配器，用于实现优先队列。\n1 priority_queue\u0026lt;int\u0026gt; pq; pq.push(x)：将元素 x 入队，并按优先级排序。 pq.pop()：将优先级最高的元素出队。 pq.top()：返回优先级最高的元素的引用。 pq.empty()：检查优先队列是否为空，返回布尔值。 pq.size()：返回优先队列中元素的个数。 stack stack 是 C++ 标准库中的一个容器适配器，用于实现后进先出（LIFO）的栈。\n1 stack\u0026lt;int\u0026gt; s; s.push(x)：将元素 x 压入栈顶。 s.pop()：弹出栈顶元素。 s.top()：返回栈顶元素的引用。 s.empty()：检查栈是否为空，返回布尔值。 s.size()：返回栈中元素的个数。 ","date":"2025-01-10T00:00:00Z","image":"https://serennan.github.io/post/leetcode-function/function.jpg","permalink":"https://serennan.github.io/post/leetcode-function/","title":"常用函数"},{"content":"前缀和 前缀和的定义： 给定数组 nums，我们可以定义前缀和数组 prefix_sum，使得 prefix_sum[i] = nums[0] + nums[1] + ... + nums[i-1]。 这样，对于任何子数组 [l, r]，其和可以通过以下公式计算：\n1 sum(l, r) = prefix_sum[r + 1] - prefix_sum[l] 典型题 437. 路径总和 III\n560. 和为 K 的子数组\n滑动窗口 滑动窗口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 滑动窗口算法框架 */ void slidingWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while (right \u0026lt; s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 右移窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(\u0026#34;window: [%d, %d)\\n\u0026#34;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) { // d 是将移出窗口的字符 char d = s[left]; // 左移窗口 left++; // 进行窗口内数据的一系列更新 ... } } } 其中两处 \u0026hellip; 表示的更新窗口数据的地方。\n而且，这两个 \u0026hellip; 处的操作分别是右移和左移窗口更新操作，它们操作是完全对称的。\n套模板要思考下面的问题：\n1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？\n2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？\n3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？\n4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？\n典型题 3. 无重复字符的最长子串\n76. 最小覆盖子串\n递归 视频链接:递归\n如何编写递归函数 第一步：确定问题\n阶乘：求n的阶乘\n1 2 3 int factorial(int n) { } 斐波那契问题：求第n个斐波那契数\n1 2 3 int fibonacci(int n) { } 汉诺塔问题：将n个盘子从A移动到C\n1 2 3 void hanoi(int n, char A, char B, char C) { } 第二步：解决基准问题（边界条件）\n阶乘：当n为0或1时，阶乘为1\n1 2 3 4 5 int factorial(int n) { if (n == 1) { return 1; } } 斐波那契：当n小于等于2时，答案是1\n1 2 3 4 5 int fibonacci(int n) { if (n \u0026lt;= 2) { return 1; } } 汉诺塔：当n为1时，直接从A移动到C\n1 2 3 4 5 6 void hanoi(int n, char A, char B, char C) { if (n == 1) { cout \u0026lt;\u0026lt; \u0026#34;Move disk 1 from \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; return; } } 第三步：拆解问题\n阶乘：n的阶乘等于n乘以(n-1)的阶乘\n1 2 3 4 5 6 int factorial(int n) { if (n == 1) { return 1; } return n * factorial(n - 1); } 斐波那契：第n个斐波那契数等于第n-1和第n-2个斐波那契数之和\n1 2 3 4 5 6 int fibonacci(int n) { if (n \u0026lt;= 2) { return 1; } return fibonacci(n - 1) + fibonacci(n - 2); } 汉诺塔：将n-1个盘子从A移动到B，将第n个盘子从A移动到C，再将n-1个盘子从B移动到C\n1 2 3 4 5 6 7 8 9 void hanoi(int n, char A, char B, char C) { if (n == 1) { cout \u0026lt;\u0026lt; \u0026#34;Move disk 1 from \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; return; } hanoi(n - 1, A, C, B); cout \u0026lt;\u0026lt; \u0026#34;Move disk \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; from \u0026#34; \u0026lt;\u0026lt; A \u0026lt;\u0026lt; \u0026#34; to \u0026#34; \u0026lt;\u0026lt; C \u0026lt;\u0026lt; endl; hanoi(n - 1, B, A, C); } 思维小技巧 在编写函数时，可以当系统库中有一个同名函数，能实现你所需要的功能，直接调用即可。\n典型题 138. 随机链表的复制\n哈希表 更多是起到一个辅助\n典型题 1. 两数之和\n236. 二叉树的最近公共祖先\n","date":"2025-01-10T00:00:00Z","image":"https://serennan.github.io/post/algorithm/algorithm.jpg","permalink":"https://serennan.github.io/post/algorithm/","title":"算法思路"},{"content":"语音生成与感知模型 发音与感知模型 声门 声带之间的间隙称为声门。\n主要功能：产生激励。\n声道 声道指声门至嘴唇的所有发音器官，包括咽喉、口腔和鼻腔。\n主要功能：传输并调制声波。\n声道的形状变化由舌、软腭、唇、牙决定。\n语音生成动作 语音生成可分为两种功能：\n激励：由声门产生的基本声波。 调制：通过声道形状的变化改变声波的频率特性。 语音生成框图 声门 (激励) ➔ 声道 (调制) ➔ 嘴唇 (辐射语音)\n基音频率 由声带张开闭合的周期决定。\n男性：50-250Hz 女性：100-500Hz 浊音与清音 浊音：由声带振动产生，包括所有元音和部分辅音。 清音：不通过声带振动产生，包括另一部分辅音。 语音生成过程 空气从肺部排出形成气流。 冲击声带： 声带紧绷：形成准周期性脉冲空气流，产生浊音。 声带舒展：形成摩擦音或爆破音。 空气流经过声道调制后从口或鼻腔辐射，形成语音。 共振峰 声道是谐振腔，有许多谐振频率，称为共振峰。 共振峰是声道的重要声学特征。\n听觉掩蔽效应 人耳听觉频率范围：20Hz-20kHz。 语音感知强度范围：0-130dB声压级。 掩蔽效应：一个声音的听觉感受性受到同时存在的另一个声音的影响。 语音信号数字模型的组成 语音信号数字模型：激励模型，声道模型，辐射模型 声道模型：声管模型，共振峰模型 共振峰模型：分为级联型，并联型和混合型 数字语音处理 语音信号基本特性 语音信号频率范围：300-3400Hz。 常用采样率：8kHz。 语音预处理 预处理 包括：预加重，端点检测，加窗分帧\n预加重 目的：增强高频分辨率，减少口唇辐射影响。\n短时处理 加窗：窗长一般选取100-200ms。 窗宽较大：平滑作用明显，反映能量变化较小。 窗宽较小：反映细节快变，包络变化不明显。 短时平均能量 用途：\n区分清音与浊音。 区分有声与无声。 语音识别的辅助参数。 短时自相关函数 浊音：具有明显周期性。 清音：无周期性，类似噪声。 倒谱分析 实现：解卷（卷积关系变换为求和关系）\n将语音信号的声门激励信息与声道响应信息分离。 用于提取声道共振特征和基音周期。 倒谱：频谱(Spectrum)的前四个字母倒过来。 共振峰 语音的主要频率成分，携带声音的辨识属性 提取共振峰：共振峰的位置和转变过程 语音端点检测 端点检测法 指从包含语音的一段信息中确定出语音的起始点和结束点。\n双门限比较法 第一级判决： 根据短时能量选较高门限T1，粗判定语音段。 根据背景噪声平均能量确定较低门限T2，精确定位语音段。 第二级判决： 用短时平均过零率，进一步搜索语音段的起止点。 门限T3由背景噪声平均过零率确定。 语音特性与噪声 语音特性 语音是时变、非平稳的随机信号，同时具有短时平稳性。 语音分为清音与浊音。 语音信号可用统计分析描述。 噪声特性 加性噪声：直接叠加在语音信号上。 非加性噪声：需通过变换处理成加性噪声。 噪声分类 周期性噪声：如机械噪声，用功率谱与滤波去除。 冲激噪声（脉冲噪声）：通过幅度阈值检测并消除。 宽带噪声：难以去除，用白化处理或其他方法。 语音干扰噪声：如“鸡尾酒会效应”，通过语音增强算法处理。 语音增强算法分类 根据是否建立模型： 模型算法： 参数方法 统计方法 非模型算法 根据麦克风数量： 单通道语音增强算法 多通道语音增强算法 根据处理域： 时域 频域 巴克域 子空间域 小波域 谱减法优缺点 优点： 无需使用端点检测方法区分语音段和无声段。 算法简单，易于实现。 缺点： 频谱直接相减会导致增强后的语音产生“音乐噪声”。 适用的信噪比范围较窄。 在低信噪比时对语音可懂度损伤较大。 语音识别系统 系统组成 流程图： 预处理：包括预加重、端点检测。 特征提取：获取语音信号特征参数。 训练识别网络：建立模板和模型。 识别方法 基于声道模型与语音知识。 模式匹配方法：如VQ、DTW。 统计模型方法：如HMM。 人工神经网络方法：如深度学习。 语音识别过程 训练过程\n预处理：输入语音经过预处理。 特征提取：提取语音信号的特征。 模板建立：基于提取的特征建立语音模板。 识别过程\n特征比较：将输入语音特征与现有语音模板进行比较。 最优匹配：找出一系列最优匹配的模板。 结果输出：通过查表给出计算机的识别结果。 隐马尔可夫模型 (HMM) 是一个统计模型\n双重随机过程： 短时平稳段统计特征。 段间动态转变特性。 在语音识别的应用 语音识别的困难：对语音的发音速率和声学变化建立模型 HMM通过以下方式解决上述问题：\n状态转移概率：模拟发音速率的变化，反映大脑根据语法和言语需求调整音素参数的过程。 观察输出概率：模拟声学变化，通过依赖状态的输出概率来描述可观测的语音时变序列。 步骤： 信号预处理。 特征提取。 训练HMM。 测试集识别。 参数 N：模型的状态数目 M：观测符号数 A：状态转移概率分布 B：状态的观测符号概率分布 π：初始状态分布 题目 判断题 声门的主要功能是传输并调制声波。 答案：错误 解析： 声门的主要功能是产生激励，而传输并调制声波是声道的功能。 基音频率由声带张开闭合的周期决定，男性的基音频率范围通常为50-250Hz。 答案：正确 解析： 基音频率确实由声带振动周期决定，男性的基音频率范围通常为50-250Hz。 清音是通过声带振动产生的。 答案：错误 解析： 清音不通过声带振动产生，浊音才是通过声带振动产生的。 共振峰是声道的重要声学特征，反映了声道的谐振频率。 答案：正确 解析： 共振峰是声道的谐振频率，是语音的重要声学特征。 预加重的目的是增强低频分辨率。 答案：错误 解析： 预加重的目的是增强高频分辨率，减少口唇辐射的影响。 单选题 声道的形状变化主要由哪些器官决定？ A. 声带 B. 舌、软腭、唇、牙 C. 肺部 D. 鼻腔 答案：B 解析： 声道的形状变化由舌、软腭、唇、牙决定。 以下哪个频率范围是语音信号的常用频率范围？ A. 20Hz-20kHz B. 300-3400Hz C. 50-250Hz D. 100-500Hz 答案：B 解析： 语音信号的常用频率范围是300-3400Hz。 以下哪种噪声属于周期性噪声？ A. 冲激噪声 B. 宽带噪声 C. 机械噪声 D. 语音干扰噪声 答案：C 解析： 周期性噪声如机械噪声，可以通过功率谱与滤波去除。 在语音识别系统中，以下哪一步骤不属于预处理阶段？ A. 预加重 B. 端点检测 C. 特征提取 D. 加窗 答案：C 解析： 特征提取属于特征提取阶段，而不是预处理阶段。 以下哪种方法属于语音识别的统计模型方法？ A. VQ（矢量量化） B. DTW（动态时间规整） C. HMM（隐马尔可夫模型） D. 深度学习 答案：C\n解析： HMM（隐马尔可夫模型）是一种统计模型方法。 简述题 简述语音生成的过程。 答案： 空气从肺部排出形成气流。 气流冲击声带，声带振动产生基本声波（激励）。 声波经过声道（包括咽喉、口腔和鼻腔）的调制，声道的形状变化由舌、软腭、唇、牙等器官决定。 调制后的声波从口或鼻腔辐射出去，形成语音。 什么是听觉掩蔽效应？ 答案： 听觉掩蔽效应是指一个声音的听觉感受性受到同时存在的另一个声音的影响。具体来说，当一个声音（掩蔽声）存在时，另一个声音（被掩蔽声）的听觉阈值会升高，导致被掩蔽声难以被感知。 简述短时处理中加窗的作用。 答案： 加窗的作用是将语音信号分割成短时段进行处理，以便分析语音的短时特性。窗长一般选取100-200ms，窗宽较大时平滑作用明显，反映能量变化较小；窗宽较小时反映细节快变，包络变化不明显。 什么是倒谱分析？它的主要用途是什么？ 答案： 倒谱分析是将语音信号的声门激励信息与声道响应信息分离的一种方法。它的主要用途是提取声道的共振特征和基音周期，从而帮助分析语音的声学特性。 简述语音识别系统的基本组成。 答案： 预处理：包括预加重、端点检测等。 特征提取：获取语音信号的特征参数。 训练识别网络：建立模板和模型。 识别：通过模式匹配、统计模型或人工神经网络等方法进行语音识别。 综合题 请详细描述语音生成与感知模型中的声道和声门的作用，并结合语音生成框图解释语音生成的过程。 答案： 在语音生成与感知模型中，声门和声道是两个关键部分。 声门： 声门是声带之间的间隙，主要功能是产生激励。当空气从肺部排出时，气流通过声门，声带振动产生基本声波，这个声波是语音生成的起点。 声道： 声道指从声门到嘴唇的所有发音器官，包括咽喉、口腔和鼻腔。声道的主要功能是传输并调制声波。声道的形状变化由舌、软腭、唇、牙等器官决定，这些变化会改变声波的频率特性，从而形成不同的语音。 语音生成框图： 声门（激励）：声带振动产生基本声波。 声道（调制）：声波经过声道的调制，声道的形状变化改变声波的频率特性。 嘴唇（辐射语音）：调制后的声波从嘴唇或鼻腔辐射出去，形成最终的语音。 请结合语音信号的短时处理，解释短时平均能量和短时自相关函数在语音分析中的作用。 答案： 短时平均能量： 短时平均能量是语音信号在短时段内的能量平均值。它的主要用途包括： 区分清音与浊音：浊音的能量通常较高，而清音的能量较低。 区分有声与无声：有声段（如元音）的能量较高，而无声段（如停顿）的能量较低。 作为语音识别的辅助参数：短时平均能量可以帮助识别语音的起始和结束点。 短时自相关函数： 短时自相关函数用于分析语音信号的周期性。它的主要用途包括： 区分浊音与清音：浊音具有明显的周期性，自相关函数会显示出周期性的峰值；而清音无周期性，自相关函数类似噪声。 提取基音周期：通过自相关函数的峰值间隔，可以估计浊音的基音周期。 请详细描述语音识别系统中的隐马尔可夫模型（HMM）的基本原理及其在语音识别中的应用。 答案： 隐马尔可夫模型（HMM）的基本原理： HMM是一种统计模型，用于描述由隐藏的马尔可夫链随机生成的观测序列。HMM包含两个随机过程： 隐藏状态序列：表示系统的内部状态，状态之间的转移遵循马尔可夫性质，即当前状态只依赖于前一个状态。 观测序列：每个隐藏状态生成一个观测值，观测值依赖于当前状态。 HMM在语音识别中的应用： 信号预处理：对语音信号进行预加重、加窗等处理。 特征提取：提取语音信号的特征参数，如MFCC（梅尔频率倒谱系数）。 训练HMM：使用训练数据对HMM进行训练，建立语音模板和模型。 测试集识别：使用训练好的HMM对测试语音进行识别，通过计算观测序列的概率来确定最可能的语音类别。 HMM在语音识别中广泛应用，因为它能够很好地处理语音信号的时变性和短时平稳性，并且能够通过统计方法有效地建模语音的动态特性。 ","date":"2025-01-06T00:00:00Z","image":"https://serennan.github.io/post/speech-signal/image-2.png","permalink":"https://serennan.github.io/post/speech-signal/","title":"语音信号期末复习"},{"content":"我是直接把这些动画效果全放一个css文件了\n创建一个hover-animation.css文件(可自定义)，然后记得在assets/scss/style.scss下添加@import \u0026quot;hover-animation\u0026quot;; 然后在创建的css文件添加以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /* 主页博客卡片 */ .article-list article { transition: transform 0.6s ease; -webkit-font-smoothing: antialiased; will-change: transform; transform-origin: center; \u0026amp;:hover { transform: scale(1.02, 1.02); } } /* 左侧栏选项 */ #main-menu { overflow: visible; li { a { -webkit-font-smoothing: antialiased; will-change: transform; transition: transform 0.6s ease; \u0026amp;:hover { transform: scale(1.1, 1.1); will-change: transform; } } } } /* 归档和链接卡片 */ .article-list--compact { overflow: visible; } .article-list--compact article { transition: transform 0.6s ease; -webkit-font-smoothing: antialiased; will-change: transform; \u0026amp;:hover { transform: scale(1.05,1.05); z-index: 4; } } /* 分类页面 */ .article-list--tile article { transition: 0.6s ease; } .article-list--tile article:hover { transform: scale(1.05, 1.05); will-change: transform; } /* 右侧导航栏 */ // 搜索 .search-form.widget { transition: transform 0.6s ease; } .search-form.widget:hover { transform: scale(1.1, 1.1); will-change: transform; -webkit-font-smoothing: antialiased; } //归档 .widget.archives .widget-archive--list { transition: transform .3s ease; will-change: transform; } .widget.archives .widget-archive--list:hover { transform: scale(1.05, 1.05); } // 标签 .tagCloud .tagCloud-tags a { border-radius: 10px; font-size: 1.4rem; transition: transform .3s ease; } .tagCloud .tagCloud-tags a:hover { transform: scale(1.1, 1.1); will-change: transform; -webkit-font-smoothing: antialiased; } 参数简单介绍:\n1 2 3 4 5 6 7 8 9 10 11 12 // 动画时间 transition: 0.6s ease; // 放大 transform: scale(1.1, 1.1); // 允许超出边框 overflow: visible; // 这个是为了放大别出现字体抖动（但好像没什么效果） will-change: transform; -webkit-font-smoothing: antialiased; ","date":"2025-01-05T00:00:00Z","image":"https://serennan.github.io/post/hugo-animation/word.jpg","permalink":"https://serennan.github.io/post/hugo-animation/","title":"【Hugo】动画"},{"content":"这个表盘的设计可能还是有些局限，后续会优化一下\nHTML部分 在\u0026rsquo;layouts/partials/widget/\u0026lsquo;文件夹下创建clock.html文件，并添加以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;时钟表盘\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section class=\u0026#34;widget clock\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;widget--clock\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;clock-face\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;digital-clock\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hand hour-hand\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hand minute-hand\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hand second-hand\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;center-dot\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script\u0026gt; const clockFace = document.querySelector(\u0026#39;.clock-face\u0026#39;); const radius = 83; // 刻度圆半径 const center = 88; // 刻度圆中心 for (let i = 0; i \u0026lt; 60; i++) { const angle = i * 6; const radians = (angle * Math.PI) / 180; const x = center + radius * Math.sin(radians); const y = center - radius * Math.cos(radians); const mark = document.createElement(\u0026#39;div\u0026#39;); mark.className = \u0026#39;mark\u0026#39;; mark.style.left = `${x}px`; mark.style.top = `${y}px`; mark.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`; if (i % 15 === 0) { mark.classList.add(\u0026#39;long-mark\u0026#39;); const numberRadius = radius - 15; const numberX = center + numberRadius * Math.sin(radians); const numberY = center - numberRadius * Math.cos(radians); const number = document.createElement(\u0026#39;div\u0026#39;); number.textContent = (i / 5) || 12; number.className = \u0026#39;clock-number\u0026#39;; number.style.left = `${numberX}px`; number.style.top = `${numberY}px`; number.style.transform = `translate(-50%, -50%)`; clockFace.appendChild(number); } else if (i % 5 === 0) { mark.classList.add(\u0026#39;middle-mark\u0026#39;); } else { mark.classList.add(\u0026#39;short-mark\u0026#39;); } clockFace.appendChild(mark); } function updateClock() { const now = new Date(); const hour = now.getHours(); const minute = now.getMinutes(); const second = now.getSeconds(); const hourHand = document.querySelector(\u0026#39;.hour-hand\u0026#39;); const minuteHand = document.querySelector(\u0026#39;.minute-hand\u0026#39;); const secondHand = document.querySelector(\u0026#39;.second-hand\u0026#39;); const hourDeg = (hour % 12) * 30 + (minute / 60) * 30; const minuteDeg = minute * 6 + (second / 60) * 6; const secondDeg = second * 6; hourHand.style.transform = `rotate(${hourDeg}deg)`; minuteHand.style.transform = `rotate(${minuteDeg}deg)`; secondHand.style.transition = second === 0 ? \u0026#39;none\u0026#39; : \u0026#39;transform 0.5s linear\u0026#39;; secondHand.style.transform = `rotate(${secondDeg}deg)`; const digitalClock = document.querySelector(\u0026#39;.digital-clock\u0026#39;); const timeString = `${hour}:${minute.toString().padStart(2, \u0026#39;0\u0026#39;)}`; digitalClock.textContent = timeString; setTimeout(updateClock, 1000); } updateClock(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; css部分 然后在assets/scss文件夹下创建clock.scss文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 /* 时钟容器样式 */ .widget.clock { margin-top: 50px; } /* 时钟表盘样式 */ .clock-face { position: relative; width: 200px; height: 200px; border: 12px solid #858b8b; /* 表盘边框颜色 */ border-radius: 50%; margin: 0 auto; background: var(--card-background); /* 动态背景 */ box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2), inset 0 0 8px rgba(255, 255, 255, 0.8); } /* 刻度线通用样式 */ .mark { position: absolute; width: 2px; background: #535656; border-radius: 2px; transform-origin: center center; } /* 长刻度（小时刻度）样式 */ .long-mark { top: 5px; height: 18px; background: #65656c; /* 长刻度颜色稍深 */ box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); } /* 数字样式 */ .clock-number { position: absolute; font-size: 12px; /* 字体大小 */ color: #797F7F !important; /* 强制覆盖其他样式 */ text-align: center; font-weight: bold; } /* 中刻度（分钟刻度）样式 */ .middle-mark { height: 10px; background: #7f8686; /* 中刻度颜色稍浅 */ box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); } /* 短刻度（秒刻度）样式 */ .short-mark { height: 5px; background: #c0baba; /* 短刻度颜色稍浅 */ box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); } /* 指针通用样式 */ .hand { position: absolute; top: 50%; left: 50%; transform-origin: 50% 100%; /* 旋转中心在底部 */ background: #444444; border-radius: 2px; transition: transform 0.5s cubic-bezier(0.4, 2.3, 0.6, 1); } /* 时针样式 */ .hour-hand { width: 6px; height: 40px; background: #6A4C9C; /* 紫色 */ z-index: 3; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4); top: calc(50% - 40px); left: calc(50% - 3px); } /* 分针样式 */ .minute-hand { width: 4px; height: 60px; background: #B497BD; /* 浅紫色 */ z-index: 2; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4); top: calc(50% - 60px); left: calc(50% - 2px); } /* 秒针样式 */ .second-hand { width: 2px; height: 70px; background: #FF69B4; /* 亮粉色 */ z-index: 1; box-shadow: 0 2px 8px rgba(255, 99, 71, 0.6); top: calc(50% - 70px); left: calc(50% - 1px); } /* 中心点样式 */ .center-dot { position: absolute; width: 12px; height: 12px; background: #845EC2; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.8); z-index: 4; } .digital-clock { position: absolute; /* 绝对定位 */ top: 50%; /* 垂直居中 */ left: 50%; /* 水平居中 */ transform: translate(-50%, -50%); /* 精确居中 */ font-size: 24px; /* 字体大小 */ font-family: Arial, sans-serif; /* 字体 */ color: #7C8181; /* 字体颜色 */ opacity: 0; /* 默认隐藏 */ transition: opacity 0.3s ease; /* 添加过渡效果 */ z-index: 5; } .clock:hover .digital-clock { opacity: 1; /* 鼠标悬停时显示 */ } .clock-face { cursor: pointer; /* 鼠标悬停时显示手型指针 */ } 问题 如果时钟刻度有些错位，就修改html文件的\n1 2 const radius = 83; // 刻度圆半径 const center = 88; // 刻度圆中心 ","date":"2025-01-05T00:00:00Z","image":"https://serennan.github.io/post/hugo-clock/clock.jpg","permalink":"https://serennan.github.io/post/hugo-clock/","title":"【Hugo】时钟"},{"content":"字体 字体文件放在assets/fonts下，然后在layouts/partials/footer/costom.html(没有就创建)中引入,格式如下\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;MapleMono2\u0026#39;; src: url(\u0026#39;{{ (resources.Get \u0026#34;font/MapleMono2.ttf\u0026#34;).Permalink }}\u0026#39;) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;MapleMono2\u0026#39;; --code-font-family: \u0026#39;MapleMono2\u0026#39;; } \u0026lt;/style\u0026gt; 注意: 字体文件路径src要有后缀\n自定义分类页面样式 我不喜欢原本默认的归档页面，想把归档和分类分成两个页面，具体操作写在了我的Hugo配置博客Hugo配置(stack主题)\n后续想添加对应的页面样式，就在 layouts 添加对应的 html 文件，比如 layouts/page/category.html ，然后在 contents/page/category.md 中添加 layout: \u0026quot;category\u0026quot; ，这样就会使用 layouts/page/category.html 的样式了\n评论功能 这里使用的giscus配置\n先在 github page 上打开 discussion 功能 点击setting，向下滑找到discussion，勾选discussion\n下载 giscus giscus app\n选择仓库地址 配置 hugo 进入giscus官网 giscus\n按照步骤配置，最后复制代码 五个重要参数：\ndata-repo data-repo-id data-category data-category-id data-mapping 添加到配置文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 comments: enabled: true provider: giscus giscus: repo: serenNan/serenNan.github.io repoID: category: Announcements categoryID: mapping: pathname lightTheme: light darkTheme: dark reactionsEnabled: 1 emitMetadata: 0 inputPosition: bottom lang: zh-CN 博客背景 我这里用的是particles动态粒子背景\n配置：\n进入网站自定义配置：particles 唯一需要注意的是有个选项改成window\n配置好后下载文件 将particles.min.js 和 particlesjs-config.json放在assets/background文件夹下\n在layouts/partials/footer/custom.html中添加以下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;div id=\u0026#34;particles-js\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{ (resources.Get \u0026#34;background/particles.min.js\u0026#34;).RelPermalink }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; particlesJS.load(\u0026#39;particles-js\u0026#39;, \u0026#39;{{ (resources.Get \u0026#34;background/particlesjs-config.json\u0026#34;).RelPermalink }}\u0026#39;, function() { console.log(\u0026#39;particles.js loaded - callback\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #particles-js { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; } \u0026lt;/style\u0026gt; ","date":"2025-01-02T00:00:00Z","image":"https://serennan.github.io/post/hugo-beautify/blog2.jpg","permalink":"https://serennan.github.io/post/hugo-beautify/","title":"【Hugo】美化\u0026优化(stack主题)"},{"content":"拷贝构造函数 参考文章 csdn：C++拷贝构造函数\n概述 拷贝构造函数，又称复制构造函数，是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构造及初始化。\n其唯一的形参必须是引用，但并不限制为const，一般普遍的会加上const限制。\n调用拷贝构造函数的情形 一个对象作为函数参数，以值传递的方式传入函数体（函数传参，类类型的值传递） 1 2 3 4 5 6 7 8 9 10 11 12 class Complex { }; void Fun(Complex c1) { } int main() { Complex c1(1,2); Fun(c1); // 这里就调用了默认的拷贝构造函数 } 一个对象作为函数返回值，以值传递的方式从函数返回;（函数的返回类型是类，从局部对象到临时对象的拷贝构造） 1 2 3 4 5 Complex Fun() { Complex c(10,20); return c; // 这里会调用 } 一个对象用于给另外一个对象进行初始化(常称为赋值初始化);（用已有对象去初始化本类的其他对象） 1 2 3 4 5 6 int main() { Complex c1(1,2); Complex c2(c1); // 此处 Complex c3=c1; // 此处 } 浅拷贝与深拷贝 当对象的成员变量中存在指针变量时，用存在的对象初始化新建对象时指针变量一同初始化，但这时调用一般拷贝构造函数（浅拷贝）会使新对象中的指针指向和初始化对象指针指向一致，那么当用来初始化的对象在释放内存时会释放掉指针指向的内存，而当新创建的对象释放时会出现程序错误，以为这个指针指向的内存被释放了两次。因此我们需要手动提供另一种拷贝构造函数（深拷贝）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyClass { public: int* data; MyClass(int d) { data = new int(d); // 动态分配内存 } ~MyClass() { delete data; // 释放内存 } MyClass(const MyClass\u0026amp; other) { data = new int(*other.data); // 深拷贝：分配新内存并复制内容 } }; int main() { MyClass original(10); MyClass copy(original); // 调用深拷贝构造函数 return 0; } 虚析构函数 总的来说虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。也就说虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的.\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; class Fish { public: Fish() { cout \u0026lt;\u0026lt; \u0026#34;Constructed Fish\u0026#34; \u0026lt;\u0026lt; endl; } // 如果这里不是虚析构函数，那么delete pFish时只会调用基类的析构函数，而不会调用子类的析构函数 virtual ~Fish() // virtual destructor! { cout \u0026lt;\u0026lt; \u0026#34;Destroyed Fish\u0026#34; \u0026lt;\u0026lt; endl; } }; class Tuna : public Fish { public: Tuna() { cout \u0026lt;\u0026lt; \u0026#34;Constructed Tuna\u0026#34; \u0026lt;\u0026lt; endl; } ~Tuna() { cout \u0026lt;\u0026lt; \u0026#34;Destroyed Tuna\u0026#34; \u0026lt;\u0026lt; endl; } }; void DeleteFishMemory(Fish *pFish) { delete pFish; } int main() { cout \u0026lt;\u0026lt; \u0026#34;Allocating a Tuna on the free store:\u0026#34; \u0026lt;\u0026lt; endl; Tuna *pTuna = new Tuna; cout \u0026lt;\u0026lt; \u0026#34;Deleting the Tuna: \u0026#34; \u0026lt;\u0026lt; endl; DeleteFishMemory(pTuna); cout \u0026lt;\u0026lt; \u0026#34;Instantiating a Tuna on the stack:\u0026#34; \u0026lt;\u0026lt; endl; Tuna myDinner; cout \u0026lt;\u0026lt; \u0026#34;Automatic destruction as it goes out of scope: \u0026#34; \u0026lt;\u0026lt; endl; return 0; } 常量成员函数 常量对象和非常量对象 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; class MyClass { private: int x; public: MyClass(int n) { x = n; } void setX(int n) // 非常量成员函数 { x = n; } int getX() const // 常量成员函数 { return x; } }; int main() { MyClass obj1(10); // 非常量对象 const MyClass obj2(20); // 常量对象 obj1.setX(30); // 可以修改obj1的数据成员 cout \u0026lt;\u0026lt; \u0026#34;obj1.x = \u0026#34; \u0026lt;\u0026lt; obj1.getX() \u0026lt;\u0026lt; endl; // obj1.x = 30 // obj2.setX(40); // 编译错误，不能修改obj2的数据成员（常量对象不能调用非常量成员函数） cout \u0026lt;\u0026lt; \u0026#34;obj2.x = \u0026#34; \u0026lt;\u0026lt; obj2.getX() \u0026lt;\u0026lt; endl; // obj1.x = 20 return 0; } 常量成员函数 常量成员函数的特点 常量成员函数不会修改类的成员函数，即它们是只读的。因此，常量成员函数不能修改类的数据成员，也不能调用非常量成员函数,因为非常量成员函数可能会修改类的数据成员。 常量成员函数可以被常量对象和非常量对象调用。如果一个对象是常量对象，则只能调用该对象的常量成员函数，而不能调用非常量成员函数。 常量成员函数可以访问类的所有成员变量和常量成员函数。 常量成员函数的作用是保证类的数据成员不被修改，从而提高程序的安全性和可靠性。 常量成员函数通常用于访问类的数据成员，而不是修改它们。 例如：可以使用常量成员函数来实现类的数据成员的读取操作，而使用非常量成员函数来实现类的数据成员的写入操作。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { private: string name; int age; public: Person(string n, int a) { name = n; age = a; } string getName() const { return name; } int getAge() const { return age; } void show() const { cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;, Age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } }; int main() { Person p(\u0026#34;Alice\u0026#34;, 20); p.show(); return 0; } 左值和右值 参考文章 csdn：C++ 左值和右值\n左值和右值的定义 左值（loactor value）:存储在内存中、可寻址的数据\n右值（read value）:可以提供数据值的数据（不一定可寻址，例如存储在寄存器中的数据）\n右值引用 左值引用无法引用右值； 常量左值引用可以操作右值，但是无法对右值进行修改； 右值引用可以对右值进行修改； 常量右值引用：引用一个右值，并且不可更改。可以常量左值引用代替。 1 2 3 4 5 6 7 int a = 10; int \u0026amp;b = a; // 左值引用 // int \u0026amp;c = 10; // 错误，左值引用无法操作右值 b = 20; const int \u0026amp;d = 10; // 常量左值引用可以操作右值 int \u0026amp;\u0026amp;e = 20; // 右值引用 e = 25; // 修改右值 因此c++11中引入右值引用\u0026amp;\u0026amp;。\n右值引用使用场景 拷贝构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; class demo { public: // 构造函数 demo() : num(new int(0)) { cout \u0026lt;\u0026lt; \u0026#34;construct!\u0026#34; \u0026lt;\u0026lt; endl; } // 拷贝构造函数（深拷贝） demo(const demo \u0026amp;d) : num(new int(*d.num)) { cout \u0026lt;\u0026lt; \u0026#34;copy construct!\u0026#34; \u0026lt;\u0026lt; endl; } ~demo() { cout \u0026lt;\u0026lt; \u0026#34;class destruct!\u0026#34; \u0026lt;\u0026lt; endl; } private: int *num; }; demo get_demo() { return demo(); // 返回一个demo对象，是一个右值 } int main() { demo a (get_demo()); // 拷贝构造 return 0; } 输出：\nconstruct! copy construct! copy construct! class destruct! class destruct! 有些编译器可能会优化，只输出一次拷贝构造函数。\n如上所示，demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。\ndemo a (get_demo()) 的流程：\n执行 get_demo() 函数，demo()调用构造函数生成一个匿名对象 执行 return demo() ，调用拷贝构造函数拷贝匿名对象，作为函数get_demo()的返回值（get_demo()执行完毕，匿名对象会被销毁） 执行 a(get_demo()), 调用拷贝构造函数(此行代码执行完毕，get_demo()的返回值会被析构) 程序结束前，a被析构。 在这个过程中，底层执行了2次深拷贝。如果指针指向的堆空间较大，会大大降低执行的效率。通过移动构造函数可以解决这个问题。\n何时调用拷贝构造函数？（详见：拷贝构造函数）\n移动构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; class demo { public: // 构造函数 demo() : num(new int(0)) { cout \u0026lt;\u0026lt; \u0026#34;construct!\u0026#34; \u0026lt;\u0026lt; endl; } // 拷贝构造函数（深拷贝） demo(const demo \u0026amp;d) : num(new int(*d.num)) { cout \u0026lt;\u0026lt; \u0026#34;copy construct!\u0026#34; \u0026lt;\u0026lt; endl; } // 移动构造函数 demo(demo \u0026amp;\u0026amp;d) : num(d.num) { d.num = nullptr; cout \u0026lt;\u0026lt; \u0026#34;move construct!\u0026#34; \u0026lt;\u0026lt; endl; } ~demo() { cout \u0026lt;\u0026lt; \u0026#34;class destruct!\u0026#34; \u0026lt;\u0026lt; endl; } private: int *num; }; demo get_demo() { demo temp; // 创建一个局部对象 return temp; // 返回局部对象 } int main() { demo a(get_demo()); // 调用移动构造函数 return 0; } 输出：\nconstruct! move construct! class destruct! class destruct! 使用右值引用类型的参数，指针浅拷贝，右值对象指针置为nullptr, 从而，避免拷贝堆空间，完成初始化。\n当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。\nstd::move()可以将左值转换为右值，从而使用移动构造。\n1 2 3 4 5 demo get_demo() { demo temp; // 创建一个局部对象 return std::move(temp); // 使用 std::move 触发移动构造函数 } 输出是一样的\nmove函数 参考文章 csdn：C++11中的move函数\n智能指针 参考文章 csdn：C++智能指针\n智能指针概述 是原始指针的封装，会自动分配内存，不需要担心潜在的内存泄露。\n为什么使用智能指针 一句话带过：智能指针就是帮我们C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而避免内存泄漏。\n下面的内存泄露的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; // 动态分配内存，没有释放就return void memoryLeak1() { string *str = new string(\u0026#34;动态分配内存！\u0026#34;); return; } // 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了 int memoryLeak2() { string *str = new string(\u0026#34;内存泄露！\u0026#34;); // ...此处省略一万行代码 // 发生某些异常，需要结束函数 if (1) { return -1; } / // 另外，使用try、catch结束函数，也会造成内存泄漏！ / delete str;\t// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放 return 1; } int main(void) { memoryLeak1(); memoryLeak2(); return 0; } memoryLeak1函数中，new了一个字符串指针，但是没有delete就已经return结束函数了，导致内存没有被释放，内存泄露！ memoryLeak2函数中，new了一个字符串指针，虽然在函数末尾有些释放内存的代码delete str，但是在delete之前就已经return了，所以内存也没有被释放，内存泄露！\n使用指针，我们没有释放，就会造成内存泄露。但是我们使用普通对象却不会。\n而智能指针本质是对一个普通指针的封装，利用有生命周期的对象自动释放的特性，来实现内存的自动管理。\nauto_ptr auto_ptr 是c++ 98定义的智能指针模板，其定义了管理指针的对象，可以将new获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete来释放内存！\n用法： 头文件：#include \u0026lt;memory\u0026gt; 用法： auto_ptr\u0026lt;类型\u0026gt; 变量名(new 类型)\n例如：\n1 2 3 auto_ptr\u0026lt; string \u0026gt; str(new string(“我要成为大牛~ 变得很牛逼！”)); auto_ptr\u0026lt;vector\u0026lt; int \u0026gt;\u0026gt; av(new vector\u0026lt; int \u0026gt;()); auto_ptr\u0026lt; int \u0026gt; array(new int[10]); 下面的代码使用new创建一个对象，但是不使用delete，就会发生内存泄露。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026#34;iostream\u0026#34; using namespace std; class Test { public: Test() { cout \u0026lt;\u0026lt; \u0026#34;Test的构造函数...\u0026#34; \u0026lt;\u0026lt; endl; } ~Test() { cout \u0026lt;\u0026lt; \u0026#34;Test的析构函数...\u0026#34; \u0026lt;\u0026lt; endl; } int getDebug() { return this-\u0026gt;debug; } private: int debug = 20; }; int main(void) { Test *test = new Test; cout \u0026lt;\u0026lt; test-\u0026gt;getDebug() \u0026lt;\u0026lt; endl; // delete test; return 0; } 输出：\nTest的构造函数... 要释放内存，就得手动delete，或者使用智能指针\n使用智能指针：\n1 2 3 4 5 6 7 8 9 10 11 int main(void) { // Test *test = new Test; auto_ptr\u0026lt;Test\u0026gt; test(new Test); cout \u0026lt;\u0026lt; \u0026#34;test-\u0026gt;debug：\u0026#34; \u0026lt;\u0026lt; test-\u0026gt;getDebug() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;(*test).debug：\u0026#34; \u0026lt;\u0026lt; (*test).getDebug() \u0026lt;\u0026lt; endl; return 0; } 输出：\nTest的构造函数... test-\u0026gt;debug：20 (*test).debug：20 Test的析构函数... 智能指针可以像普通指针一样使用，并且会自动释放内存\n智能指针有三个常用函数：\nget()：获取智能指针管理的指针\n1 2 3 4 5 // 定义智能指针 auto_ptr\u0026lt;Test\u0026gt; test(new Test); Test *tmp = test.get();\t// 获取指针返回 cout \u0026lt;\u0026lt; \u0026#34;tmp-\u0026gt;debug：\u0026#34; \u0026lt;\u0026lt; tmp-\u0026gt;getDebug() \u0026lt;\u0026lt; endl; 但一般不这么使用，因为可以直接使用智能指针操作\nrelease()：释放智能指针管理的指针\n1 2 3 4 5 // 定义智能指针 auto_ptr\u0026lt;Test\u0026gt; test(new Test); Test *tmp2 = test.release();\t// 取消智能指针对动态内存的托管 delete tmp2;\t// 之前分配的内存需要自己手动释放 reset()：重置智能指针管理的指针\n1 2 3 4 5 6 // 定义智能指针 auto_ptr\u0026lt;Test\u0026gt; test(new Test); test.reset();\t// 释放掉智能指针托管的指针内存，并将其置NULL test.reset(new Test());\t// 释放掉智能指针托管的指针内存，并将参数指针取代之 unique_ptr c++11使用unique_ptr替代auto_ptr\nunique_ptr特性：\n基于排他所有权模式：两个指针不能指向同一个资源 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。 在容器中保存指针是安全的 ","date":"2024-12-30T00:00:00Z","image":"https://serennan.github.io/post/cpp_study/cpp.jpg","permalink":"https://serennan.github.io/post/cpp_study/","title":"C++语法"},{"content":"yaml参数 主框架 1 2 3 4 5 6 baseurl: https://example.com/ languageCode: en-us theme: hugo-theme-stack paginate: 10 title: 个人博客 copyright: serenNan baseurl: 目前是github pages的地址 my-blog\nlanguageCode: 语言代码\ntheme: 主题名称\npaginate: 每页显示的文章数量\ntitle: 网站标题（目前没使用）\ncopyright: 网页最下方显示\n语言 1 2 3 # Theme i18n support # Available values: ar, bn, ca, de, el, en, es, fr, hu, id, it, ja, ko, nl, pt-br, th, uk, zh-cn, zh-hk, zh-tw DefaultContentLanguage: zh-cn DefaultContentLanguage: 默认语言\n网页图标 1 favicon: # e.g.: favicon placed in `static/favicon.ico` of your site folder, then set this field to `/favicon.ico` (`/` is necessary) favicon: 网站图标(将 favicon 放置在站点文件夹的 static/favicon.ico 中，然后将此字段设置为 /favicon.ico（/ 是必需的）。)\n页脚 1 2 3 footer: since: 2024 customText: footer: 页脚\nsince: 年份\ncustomText: 自定义文本\n头像 1 2 3 4 5 6 7 sidebar: emoji: 🐈‍⬛ subtitle: 欢迎来到我的个人博客 avatar: enabled: true local: true src: img/avatar.png sidebar: 侧边栏\navatar: 头像\nsrc: 头像路径\n头像是在 assets/img/avatar.png 中\n文章信息 1 2 3 4 5 6 7 article: math: false toc: true readingTime: true license: enabled: true default: Licensed under CC BY-NC-SA 4.0 article: 文章\nmath: 数学公式\ntoc: 目录\nreadingTime: 阅读时间\nlicense: 许可证\nenabled: 是否启用\ndefault: 默认许可证\n右侧侧边栏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 widgets: homepage: - type: search - type: archives params: limit: 5 - type: categories params: limit: 10 - type: tag-cloud params: limit: 10 page: - type: toc widgets: 小工具 (右边侧边栏)\nsearch: 搜索\narchives: 归档\ncategories: 分类\ntag-cloud: 标签云\ntoc: 目录\n头像下方图标 1 2 3 4 5 6 7 8 9 10 11 12 social: - identifier: github name: GitHub url: https://github.com/CaiJimmy/hugo-theme-stack params: icon: github-2 - identifier: bilibili name: Bilibili url: https://space.bilibili.com/450940909 params: icon: bilibili 头像下方的链接，icon图标放在assets/icons文件夹下，svg后缀。\n左侧侧边栏导航 在content/page文件夹下\nlink链接 在content/page/links.md下 格式:\n1 2 3 4 5 6 7 8 9 links: - title: GitHub description: GitHub is the world\u0026#39;s largest software development platform. website: https://github.com image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png - title: TypeScript description: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. website: https://www.typescriptlang.org image: ts-logo-128.jpg 自定义分类页面 我这里是自定义的分类页面，将归档和分类分开\n在content/categories.md下，每有一个分类就创建一个文件夹，文件夹下放_index.md文件，格式如下：\n注意：是_index.md要加个_\n1 2 3 4 5 6 7 8 title: \u0026#34;文档\u0026#34; date: 2020-03-14T15:40:24+06:00 description : \u0026#34;文档分类\u0026#34; slug: \u0026#34;document\u0026#34; image: 猫.png style: background: \u0026#34;#2a9d8f\u0026#34; color: \u0026#34;#fff\u0026#34; 如果想完善页面，可以在layouts/page/categories.html添加下面的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 {{ define \u0026#34;body-class\u0026#34; }}template-categories{{ end }} {{ define \u0026#34;main\u0026#34; }} \u0026lt;header\u0026gt; {{- $taxonomy := $.Site.GetPage \u0026#34;taxonomyTerm\u0026#34; \u0026#34;categories\u0026#34; -}} {{- $terms := $taxonomy.Pages -}} {{ if $terms }} \u0026lt;h1 class=\u0026#34;section-title\u0026#34;\u0026gt;分类\u0026lt;/h1\u0026gt; \u0026lt;!-- 这里是标题 --\u0026gt; \u0026lt;div class=\u0026#34;subsection-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;article-list--tile\u0026#34; style=\u0026#34;display: flex; flex-direction: column;\u0026#34;\u0026gt; {{ range $terms }} \u0026lt;div class=\u0026#34;category-group\u0026#34; style=\u0026#34;flex: 1 1 auto; margin: 10px;\u0026#34;\u0026gt; \u0026lt;h3 class=\u0026#34;category-title\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;article-list--horizontal\u0026#34; style=\u0026#34;display: flex; overflow-x: auto;\u0026#34;\u0026gt; {{ $articles := where .Site.RegularPages \u0026#34;Params.categories\u0026#34; \u0026#34;intersect\u0026#34; (slice .Title) }} {{ range $articles }} \u0026lt;div class=\u0026#34;article-tile\u0026#34; style=\u0026#34;flex: 0 0 auto; margin: 5px;\u0026#34;\u0026gt; {{ partial \u0026#34;article-list/tile\u0026#34; (dict \u0026#34;context\u0026#34; . \u0026#34;size\u0026#34; \u0026#34;250x150\u0026#34; \u0026#34;Type\u0026#34; \u0026#34;taxonomy\u0026#34;) }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/header\u0026gt; {{ partialCached \u0026#34;footer/footer\u0026#34; . }} {{ end }} 文章 在content/post文件夹下，正文就用markdown格式\n主页blog显示 1 2 3 4 5 6 7 8 title: Chinese Test description: 这是一个副标题 date: 2020-09-09 slug: test-chinese # url显示 image: helena-hertz-wWZzXlDpMog-unsplash.jpg categories: - Test - 测试 创建时间\u0026amp;更新时间 1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息\tenableGitInfo: true 在部署文件.github/workflows/deploy.yaml 添加：\n1 2 3 4 5 6 - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false 注意缩进要对\nstack默认显示在文章最后面，如果想在主页面的博客文章显示，在layouts/partials/article/components/details.html添加：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!-- 创建时间\u0026amp;阅读时长 --\u0026gt; \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; {{ if $showDate }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;date\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--published\u0026#34;\u0026gt; {{- .Date | time.Format (or .Site.Params.dateFormat.published \u0026#34;Jan 02, 2006\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{ if $showReadingTime }} \u0026lt;div\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; {{ T \u0026#34;article.readingTime\u0026#34; .ReadingTime }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{ if and $showDate (ne .Lastmod .Date) }} \u0026lt;span class=\u0026#34;time-divider\u0026#34;\u0026gt;|\u0026lt;/span\u0026gt; {{ end }} {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-time--lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} 自带的有阅读时长，我没开启\n文章末尾也会显示最后修改时间，想删除就去layouts/partials/article/components/footer.html删掉：\n1 2 3 4 5 6 7 8 {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;span\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }} {{ .Lastmod | time.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{- end -}} ","date":"2024-12-29T00:00:00Z","image":"https://serennan.github.io/post/hugo-config/blog1.jpg","permalink":"https://serennan.github.io/post/hugo-config/","title":"【Hugo】配置(stack主题)"},{"content":"基础命令 CSDN博主总结常用命令\n获得基础信息，输出Metadata 打开媒体文件，获取Meta信息，关闭媒体文件\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026#34;libavutil/log.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; // 传入命令行参数个数 int main(int argc, char **argv) { // 设置日志级别 av_log_set_level(AV_LOG_DEBUG); // 设置日志输出函数 // 检查参数个数 if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_DEBUG, \u0026#34;Usage:%s infileName.\\n\u0026#34;, argv[0]); return -1; } // 获取输入文件名 const char *infileName = argv[1]; // 初始化所有组件 AVFormatContext *pFormatCtx = NULL; // 打开媒体文件 int ret = avformat_open_input(\u0026amp;pFormatCtx, infileName, NULL, NULL); // av_err2str()函数返回错误信息 if (ret != 0) { // av_err2str()函数返回错误信息 av_log(NULL, AV_LOG_DEBUG, \u0026#34;open input file:%s failed: %s\\n\u0026#34;, infileName, av_err2str(ret)); return -1; } // 获取媒体文件信息 av_dump_format(pFormatCtx, 0, infileName, 0); // 关闭媒体文件 avformat_close_input(\u0026amp;pFormatCtx); return 0; } 容器/文件 (Container/File) 定义: 特定格式的多媒体文件，如 .mp4, .flv, .mov 等。 作用: 存储和组织多媒体数据，包括音频、视频、字幕等。 常见格式: MP4: 广泛用于视频存储和流媒体。 FLV: 主要用于Flash视频。 MOV: 苹果公司开发的视频格式。 媒体流 (Stream) 定义: 一段连续的数据，如一段声音数据、一段视频或者一段字幕数据。 特点: 由不同编码器编码。 类型: 音频流: 存储音频数据。 视频流: 存储视频数据。 字幕流: 存储字幕数据。 数据包 (Packet) 定义: 一个媒体流由大量的数据包组成，是压缩后的数据。 作用: 传输和存储媒体数据的基本单位。 特点: 数据包是压缩后的数据，便于传输和存储。 数据帧 (Frame) 定义: 一个数据包由一个或多个数据帧组成，是非压缩数据。 作用: 原始的、未压缩的媒体数据。 类型: I帧 (Intra Frame): 独立帧，不依赖其他帧。 P帧 (Predictive Frame): 依赖前一帧进行预测。 B帧 (Bidirectional Frame): 依赖前后帧进行预测。 编解码器 (Codec) 定义: 编解码器是以帧为单位实现压缩数据和原始数据之间相互转换的工具。 作用: 用于压缩和解压缩媒体数据。 常见编解码器: 视频编解码器: H.264, H.265, VP9 等。 音频编解码器: AAC, MP3, Vorbis 等。 重要结构体 AVFormatContext: 管理整个多媒体文件的格式和结构。 AVStream: 表示媒体文件中的一个单独的媒体流。 AVCodecContext 与 AVCodec: 管理媒体数据的编码和解码过程。 AVPacket: 表示压缩后的媒体数据。 AVFrame: 表示未压缩的原始媒体数据。 解封装-提取aac数据 AAC（Advanced Audio Coding）是一种高级音频编码技术，广泛用于数字音频压缩和传输。它是由MPEG（Moving Picture Experts Group）开发的，旨在提供比MP3更高的音质和更高的压缩效率。AAC通常用于各种音频应用，包括音乐、视频、广播和流媒体服务。\nAAC的主要特点：\n高音质：AAC能够在较低的比特率下提供比MP3更高的音质。 多通道支持：AAC支持多通道音频，包括立体声、5.1环绕声和7.1环绕声。 低延迟：AAC设计用于低延迟应用，适合实时音频传输。 灵活性：AAC支持多种比特率和采样率，适用于不同的应用场景。 1 2 ffmpeg -y -i out.mp4 -vn -acodec copy out.aac ffplay out.aac 流程 操作步骤 函数名 打开媒体文件 avformat_open_input 获取码流信息 avformat_find_stream_info 获取音频流 av_find_best_stream 初始化 packet av_packet_alloc 读取 packet 数据 av_read_frame 释放 packet 数据 av_packet_unref 关闭媒体文件 avformat_close_input 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; int main(int argc, char *argv[]) { // 设置日志级别 av_log_set_level(AV_LOG_DEBUG); // 如果参数小于3，输出使用方法 if (argc \u0026lt; 3) { // argv[0]是程序名 av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input file\u0026gt; \u0026lt;output file\u0026gt;\\n\u0026#34;, argv[0]); return -1; } // 获取命令行的输入音频 const char *inputName = argv[1]; // 获取命令行的输出音频 const char *outputName = argv[2]; av_sdp_create; // 打开输入音频文件 AVFormatContext *inFormatCtx = NULL; // 打开媒体文件，并获取流信息 int ret = avformat_open_input(\u0026amp;inFormatCtx, inputName, NULL, NULL); // 如果打开输入文件失败，返回错误信息 if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open input file \u0026#39;%s\u0026#39;\\n\u0026#34;, inputName); return -1; } // 获取码流信息 ret = avformat_find_stream_info(inFormatCtx, NULL); // 如果ret小于0，则打印错误信息 if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); // 就算获取失败，也要关闭输入文件 avformat_close_input(\u0026amp;inFormatCtx); return -1; } // 如果获取成功，则打印信息 int audioIndex = av_find_best_stream(inFormatCtx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (audioIndex \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find audio stream in the input file\\n\u0026#34;); avformat_close_input(\u0026amp;inFormatCtx); return -1; } if (audioIndex \u0026lt; 0) { // 输出错误信息，表示找不到最佳音频流 av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream failed, index is %d\\n\u0026#34;, audioIndex); avformat_close_input(\u0026amp;inFormatCtx); return -1; } // 打印音频信息 av_log(NULL, AV_LOG_INFO, \u0026#34;the audio index is %d\\n\u0026#34;, audioIndex); // 初始化AVPacket结构体 AVPacket *packet = av_packet_alloc(); if (!packet) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate packet\\n\u0026#34;); avformat_close_input(\u0026amp;inFormatCtx); return -1; } // 存储音频流信息 输出文件 FILE *dest_fp = fopen(outputName, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open %s file failed\\n\u0026#34;, outputName); // 就算打不开文件也得关闭音频文件 avformat_close_input(\u0026amp;inFormatCtx); // 释放分配的AVPacket av_packet_free(\u0026amp;packet); return -1; } // 有许多PC数据，所以需要循环读取 while (av_read_frame(inFormatCtx, packet) == 0) { // 检查当前包是否属于音频流 if (packet-\u0026gt;stream_index == audioIndex) { // 将音频数据写入输出文件 fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); // 检查写入是否成功 if (ret != packet-\u0026gt;size) { // 如果写入的数据大小不等于包的大小，则输出错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;write data failed\\n\u0026#34;); // 关闭输出文件 fclose(dest_fp); // 关闭输入文件 avformat_close_input(\u0026amp;inFormatCtx); // 释放整个结构体 av_packet_free(\u0026amp;packet); return -1; } } // 释放当前包的引用 av_packet_unref(packet); } // 检查输入格式上下文是否已初始化 if (inFormatCtx != NULL) { // 关闭输入文件 avformat_close_input(\u0026amp;inFormatCtx); } // 检查输出文件指针是否已初始化 if (dest_fp != NULL) { // 关闭输出文件 fclose(dest_fp); } if (packet != NULL) { // 释放AVPacket结构体 av_packet_free(\u0026amp;packet); } return 0; } aac音频格式分析 ADTS（Audio Data Transport Stream）和ADIF（Audio Data Interchange Format）是两种用于音频编码的容器格式，主要用于AAC（Advanced Audio Codec）音频编码。它们的主要区别在于数据流的组织方式和使用场景。\nADTS（Audio Data Transport Stream） 定义: ADTS是一种流式传输格式，适用于音频数据的实时传输，如广播、流媒体等。 结构: 每个ADTS帧都包含一个头信息，后面跟着音频数据。头信息中包含了帧的长度、采样率、声道数等信息。 特点: 自包含: 每个ADTS帧都是自包含的，可以独立解码。 流式传输: 适合流式传输，因为每个帧都可以独立处理。 头部信息: 每个帧的头部信息较大，可能会增加一些开销。 ADIF（Audio Data Interchange Format） 定义: ADIF是一种文件格式，适用于音频数据的存储和交换，如音频文件的存储。 结构: ADIF文件包含一个唯一的头信息，后面跟着所有的音频数据。头信息中包含了编码参数、采样率、声道数等信息。 特点: 单一头部: 整个文件只有一个头部信息，减少了冗余。 非流式: 不适合流式传输，因为需要整个文件的头信息才能开始解码。 存储和交换: 适合存储和交换音频数据，因为头部信息只出现一次，减少了文件大小。 总结 ADTS: 适用于流式传输，每个帧自包含，适合实时传输。 ADIF: 适用于文件存储和交换，整个文件只有一个头部信息，适合存储和交换音频数据。 选择哪种格式取决于具体的应用场景：如果需要实时传输音频数据，ADTS是更好的选择；如果需要存储或交换音频文件，ADIF更为合适。\n提取H264视频数据 流程 流程和提取aac文件一样\n操作步骤 函数名 打开媒体文件 avformat_open_input 获取码流信息 avformat_find_stream_info 获取音频流 av_find_best_stream 初始化 packet av_packet_alloc 读取 packet 数据 av_read_frame 释放 packet 数据 av_packet_unref 关闭媒体文件 avformat_close_input 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFilename = argv[1]; const char *outFilename = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFilename, NULL, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } int videoIndex = ret; FILE *dest_fp = fopen(outFilename, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open output file failed:%s\\n\u0026#34;, outFilename); ret = -1; goto fail; } AVPacket *packet = av_packet_alloc(); while (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == videoIndex) { int writeSize = fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); if (writeSize != packet-\u0026gt;size) { // 这里不能释放整个packet，只能释放packet中的data，因为循环之后还会用到packet av_packet_unref(packet); ret = -1; break; } } av_packet_free(\u0026amp;packet); } fclose(dest_fp); fail: if(inFmtCtx != NULL) { avformat_close_input(\u0026amp;inFmtCtx); } if(dest_fp != NULL) { fclose(dest_fp); } return ret; } 成功运行，要用avi格式的视频文件\n如果想提取mp4格式的文件，需要进行以下步骤\nmp4→h264 流程 函数名 描述 av_bsf_get_by_name 根据名称获取比特流过滤器 av_bsf_alloc 分配比特流过滤器上下文 avcodec_parameters_copy 复制编解码器参数 av_bsf_init 初始化比特流过滤器 av_bsf_send_packet 发送数据包到比特流过滤器 av_bsf_receive_packet 从比特流过滤器接收处理后的数据包 av_bsf_free 释放比特流过滤器上下文及相关资源 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavcodec/bsf.h\u0026gt; int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFilename = argv[1]; const char *outFilename = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFilename, NULL, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); ret = -1; goto fail; } int videoIndex = ret; FILE *dest_fp = fopen(outFilename, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Open output file failed:%s\\n\u0026#34;, outFilename); ret = -1; goto fail; } AVPacket *packet = av_packet_alloc(); const AVBitStreamFilter *bsf = av_bsf_get_by_name(\u0026#34;h264_mp4toannexb\u0026#34;); if(bsf == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;get h264_mp4toannexb bsf failed\\n\u0026#34;); ret = -1; goto fail; } AVBSFContext *bsfCtx = NULL; av_bsf_alloc(bsf, \u0026amp;bsfCtx); avcodec_parameters_copy(bsfCtx-\u0026gt;par_in, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); av_bsf_init(bsfCtx); while (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == videoIndex) { if(av_bsf_send_packet(bsfCtx, packet) == 0) { while(av_bsf_receive_packet(bsfCtx, packet) == 0) { int writeSize = fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); if (writeSize != packet-\u0026gt;size) { // 这里不能释放整个packet，只能释放packet中的data，因为循环之后还会用到packet av_packet_unref(packet); ret = -1; break; } } } } av_packet_free(\u0026amp;packet); } fclose(dest_fp); fail: if(inFmtCtx != NULL) { avformat_close_input(\u0026amp;inFmtCtx); } if(bsfCtx != NULL) { av_bsf_free(\u0026amp;bsfCtx); } if(dest_fp != NULL) { fclose(dest_fp); } return ret; } 转封装-mp4转flv I帧，P帧，B帧 I帧：帧内编码帧（Intra picture），I帧通常是一个GOP的第一帧，经过轻度地压缩，作为随机访问的参考点，可以当成静态图像，I帧压缩可去掉视频的空间冗余信息。\nP帧：前向预测编码帧（predictive frame），通过将图像序列中前面已编码帧的时间冗余信息充分去除来压缩传输数据量的编码图像，也称为预测帧。\nB帧：双向预测内插编码帧，既考虑源图像序列前面的已编码帧，又顾及源图像序列后面的已编码帧之间的时间冗余信息，来压缩传输数据量的编码图像，也称为双向预测帧\nPTS-显示时间戳\nDTS-解码时间戳\n流程 步骤 对应函数 打开输入媒体文件 avformat_open_input 获取输入流信息 avformat_find_stream_info 创建输出流上下文 avformat_alloc_output_context2 创建输出码流的AVStream avformat_new_stream 拷贝编码参数 avcodec_parameters_copy 写入视频文件头 avformat_write_header 读取输入视频流 av_read_frame 计算pts/dts/duration av_rescale_q_rnd/av_rescale_q 写入视频流数据 av_interleaved_write_frame 写入视频文件末尾 av_write_trailer 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;infileName\u0026gt; \u0026lt;outfileName\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFileName = argv[1]; const char *outFileName = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find input stream failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } AVFormatContext *outFmtCtx = NULL; // 分配输出格式上下文 ret = avformat_alloc_output_context2(\u0026amp;outFmtCtx, NULL, NULL, outFileName); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc output format failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // 输入文件的流数量 int streamCount = inFmtCtx-\u0026gt;nb_streams; // 分配一个整数数组，用于存储输入流索引到输出流索引的映射关系，并将其初始化为零 int *handleStreamIndexArray = av_malloc_array(streamCount, sizeof(int)); if (handleStreamIndexArray == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;malloc handle stream index array failed\\n\u0026#34;); goto fail; } int streamIndex = 0; // 用于多媒体处理的循环，主要功能是将输入文件中的音视频流复制到输出文件中 for (int i = 0; i \u0026lt; streamCount; i++) { // 获取输入文件的流 AVStream *inStream = inFmtCtx-\u0026gt;streams[i]; // 判断流的类型（视频，音频或字幕） if (inStream-\u0026gt;codecpar-\u0026gt;codec_type != AVMEDIA_TYPE_VIDEO \u0026amp;\u0026amp; inStream-\u0026gt;codecpar-\u0026gt;codec_type != AVMEDIA_TYPE_AUDIO \u0026amp;\u0026amp; inStream-\u0026gt;codecpar-\u0026gt;codec_type != AVMEDIA_TYPE_SUBTITLE) { // 不处理该流 handleStreamIndexArray[i] = -1; continue; } handleStreamIndexArray[i] = streamIndex++; // 创建新的输出流 AVStream *outStream = NULL; // 在输出文件中创建一个新的流 outStream = avformat_new_stream(outFmtCtx, NULL); if (outStream == NULL) { ret = -1; av_log(NULL, AV_LOG_ERROR, \u0026#34;new output stream failed\\n\u0026#34;); goto fail; } // 复制编解码器参数 avcodec_parameters_copy(outStream-\u0026gt;codecpar, inStream-\u0026gt;codecpar); // 设置输出流的编解码器标签为0 outStream-\u0026gt;codecpar-\u0026gt;codec_tag = 0; } // 判断outFmtCtx-\u0026gt;oformat-\u0026gt;flags是否包含AVFMT_NOFILE标志 [\u0026amp;解释（点击跳转）](https://www.notion.so/if-outFmtCtx-oformat-flags-AVFMT_NOFILE-1187c25c79d08036bde1c286d0b3c943?pvs=21) if (!(outFmtCtx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { // 以写入模式打开 ret = avio_open(\u0026amp;outFmtCtx-\u0026gt;pb, outFileName, AVIO_FLAG_WRITE); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open output file failed:%s\\n\u0026#34;, outFileName); goto fail; } } // 将输出文件的头部信息写入到输出文件中 ret = avformat_write_header(outFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;write header failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } AVPacket *packet = av_packet_alloc(); // 读取输入文件的数据包 while (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index \u0026gt;= streamCount || handleStreamIndexArray[packet-\u0026gt;stream_index == -1]) { av_packet_unref(packet); } // 获取输入输出文件中对应流索引的流 AVStream *inStream = inFmtCtx-\u0026gt;streams[packet-\u0026gt;stream_index]; AVStream *outStream = outFmtCtx-\u0026gt;streams[packet-\u0026gt;stream_index]; packet-\u0026gt;stream_index = handleStreamIndexArray[packet-\u0026gt;stream_index]; packet-\u0026gt;pts = av_rescale_q(packet-\u0026gt;pts, inStream-\u0026gt;time_base, outStream-\u0026gt;time_base); packet-\u0026gt;dts = av_rescale_q(packet-\u0026gt;dts, inStream-\u0026gt;time_base, outStream-\u0026gt;time_base); packet-\u0026gt;duration = av_rescale_q(packet-\u0026gt;duration, inStream-\u0026gt;time_base, outStream-\u0026gt;time_base); // 将数据包的位置设置为-1 packet-\u0026gt;pos = -1; ret = av_interleaved_write_frame(outFmtCtx, packet); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;write interleaved failed:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } av_packet_unref(packet); } ret = av_write_trailer(outFmtCtx); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;write trailer failed :%s\\n\u0026#34;, av_err2str(ret)); } fail: if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } if (outFmtCtx \u0026amp;\u0026amp; !(outFmtCtx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { avio_closep(\u0026amp;outFmtCtx-\u0026gt;pb); } if (outFmtCtx) { avformat_free_context(outFmtCtx); } if (handleStreamIndexArray) { av_freep(\u0026amp;handleStreamIndexArray); } return ret; } 截取封装文件 时间基与时间戳 时间基：时间刻度，表示每个刻度多少秒（就像一把尺子的刻度）\n时间戳：表示占多少个时间刻度，单位不是秒，而是时间刻度（多少多少cm）\n时间基和时间戳相乘就是时间\nPTS：显示时间戳，在什么时候开始显示这一帧数据，转成时间：PTS * 时间基\nDTS：解码时间戳，在什么时候开始解码这一帧数据，转成时间：DTS * 时间基\n流程 截取封装文件处理流程和转封装流程几乎一样，只是多了一个跳转指定时间戳的步骤。以下是详细流程：\n步骤 对应函数 1. 打开输入媒体文件 avformat_open_input 2. 获取输入流信息 avformat_find_stream_info 3. 创建输出流上下文 avformat_alloc_output_context2 4. 创建输出码流的AVStream avformat_new_stream 5. 拷贝编码参数 avcodec_parameters_copy 6. 写入视频文件头 avformat_write_header 7. 读取输入视频流 av_read_frame 8. 跳转指定时间戳 av_seek_frame 9. 计算pts/dts/duration av_rescale_q_rnd/av_rescale_q 10. 写入视频流数据 av_interleaved_write_frame 11. 写入视频文件末尾 av_write_trailer 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;libavutil/avutil.h\u0026gt; #include \u0026lt;libavformat/avformat.h\u0026gt; #include \u0026lt;libavcodec/avcodec.h\u0026gt; int main(int argc, char **argv) { // 设置日志级别 av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage:%s \u0026lt;infileName\u0026gt;\\n\u0026#34;, argv[0]); } const char *inFileName = argv[1]; // 打开输入文件 AVFormatContext *inFmtCtx = NULL; // 用于存储输入文件的格式信息 avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); // 打开输入文件inFileName，并将格式信息存储在inFmtCtx中 avformat_find_stream_info(inFmtCtx, NULL); // 查找输入文件的流信息，并将流信息存储在inFmtCtx中 av_dump_format(inFmtCtx, 0, inFileName, 0); // 打印输入文件inFileName的格式信息 av_log(NULL, AV_LOG_INFO, \u0026#34;input file duration:%ld us, %lf s \\n\u0026#34;, inFmtCtx-\u0026gt;duration, inFmtCtx-\u0026gt;duration * av_q2d(AV_TIME_BASE_Q)); // 打印输入文件的总时长，单位为微秒和秒 AV_TIME_BASE_Q是ffmpeg内部的时间基，值为{1, AV_TIME_BASE}，AV_TIME_BASE的值为1000000，即1秒 // AVRational是ffmpeg内部的时间基，值为{num, den}，num为分子，den为分母 AVRational videoTimeBase; AVRational audioTimeBase; for (int i = 0; i \u0026lt; inFmtCtx-\u0026gt;nb_streams; i++) // 遍历输入文件中的所有流 { AVStream *inStream = inFmtCtx-\u0026gt;streams[i]; // 获取输入文件中的第i个流 // 分别判断是否为音频或视频流 if (inStream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_VIDEO) { videoTimeBase = inStream-\u0026gt;time_base; av_log(NULL, AV_LOG_INFO, \u0026#34;video timebase:num = %d,den = %d\\n\u0026#34;, videoTimeBase.num, videoTimeBase.den); } else if (inStream-\u0026gt;codecpar-\u0026gt;codec_type == AVMEDIA_TYPE_AUDIO) { audioTimeBase = inStream-\u0026gt;time_base; av_log(NULL, AV_LOG_INFO, \u0026#34;audio timebase:num = %d,den = %d\\n\u0026#34;, audioTimeBase.num, audioTimeBase.den); } } AVPacket *packet = av_packet_alloc(); // 分配一个AVPacket结构体，用于存储解码后的数据 while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) // 循环读取输入文件中的每个数据包，并将数据包存储在packet中 { AVStream *inStream = inFmtCtx-\u0026gt;streams[packet-\u0026gt;stream_index]; // 获取当前数据包所属的流 av_log(NULL, AV_LOG_INFO, \u0026#34;streamIndex = %d,pts = %ld,ptsTime = %lf,dts = %ld,dtsTime = %lf\\n\u0026#34;, packet-\u0026gt;stream_index, packet-\u0026gt;pts, packet-\u0026gt;pts * av_q2d(inStream-\u0026gt;time_base), packet-\u0026gt;dts, packet-\u0026gt;dts * av_q2d(inStream-\u0026gt;time_base)); // 打印当前数据包的流索引、pts、pts时间、dts、dts时间 } return 0; } 视频解码 如何使用ffmpeg接口对视频解码\nRGB介绍 三原色：RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。\n显示器：使用RGB三种颜色的发光体作为基本发光单元\n分辨率：手机屏幕分辨率是1280*720，表示屏幕上有1280*720个像素点，每个像素点由RGB三种颜色组成\nRGB格式 调色版：通过编号映射到颜色的一张二维表，如01索引，表示红色 索引格式： RGB1、RGB4、RGB8 是计算机图形学中常见的颜色编码格式，它们代表了不同的颜色深度和存储方式。以下是对这些格式的解释：\nRGB1：\n颜色深度：1位（bit）。 颜色数量：2种颜色（通常是黑色和白色）。 应用场景：常用于早期的单色显示器或简单的图形界面，如文本模式下的显示。 RGB4：\n颜色深度：4位（bit）。 颜色数量：16种颜色。 应用场景：常用于早期的彩色显示器或低分辨率图形界面，如早期的计算机游戏或简单的图形应用程序。 RGB8：\n颜色深度：8位（bit）。 颜色数量：256种颜色。 应用场景：常用于早期的彩色显示器或低分辨率图形界面，如早期的计算机游戏、网页设计中的调色板模式等。 这些格式在现代计算机图形处理中已经较少使用，但在某些特定的应用场景或历史研究中仍然具有参考价值。 像素格式：。。。（后续觉得有必要再补上）\n命令\nffmpeg命令将图片转RGB数据\n1 ffmpeg -i input.png -pix_fmt rgb24 output.rgb 注意输出信息中会输出图片大小，下面的ffplay需要用\n1 Stream #0:0: Video: png, rgba(pc, gbr/bt709/iec61966-2-1), 1920x1200 [SAR 5669:5669 DAR 8:5], 25 fps, 25 tbr, 25 tbn ffplay命令播放RGB数据\n1 ffplay -f output.rgb -pix_fmt rgb24 -s widthxheight output.rgb 其中，width 和 height 是图片的宽度和高度，是必要的信息。\n通过解码，会发现照片内存明显变大，因为RGB格式存储了更多的颜色信息，所以我们需要对照片进行编码\nYUV介绍 YUV 是一种颜色编码系统，常用于视频和图像处理中。Y 代表亮度（Luminance），U 和 V 代表色度（Chrominance）。YUV 格式有多种变体，如 YUV420、YUV422、YUV444 等。\n流程 函数名 描述 av_find_best_stream 在媒体文件中查找最佳流 avcodec_alloc_context3 分配一个编解码器上下文 avcodec_parameters_to_context 复制编解码器参数 avcodec_find_decoder 查找并获取视频解码器 avcodec_open2 打开解码器上下文，并与指定的解码器关联 av_read_frame 读取帧 avcodec_send_packet 发送数据包到解码器 avcodec_receive_frame 从解码器接收帧 输入指令\n1 2 ./demoBin ../video/test.mp4 test.yuv ffplay test.yuv -video_size 720x1280 -pixel_format yuv420p 如果播放的视频乱码，主要是由于width和linesize大小不一样 后续的更改视频格式的时候会解决这个问题\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavcodec/avcodec.h\u0026#34; // 定义一个全局变量，用于记录解码的帧数 int frameCount = 0; // 解码视频帧的函数 int decodeVideo(AVCodecContext *codecCtx, AVPacket *packet, FILE *dest_fp) { // 将数据包发送到解码器 int ret = avcodec_send_packet(codecCtx, packet); if (ret != 0) { // 如果发送失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not send packet:%s\\n\u0026#34;, av_err2str(ret)); return -1; } // 分配一个AVFrame结构体，用于存储解码后的帧数据 AVFrame *frame = av_frame_alloc(); // 循环接收解码后的帧数据 while (avcodec_receive_frame(codecCtx, frame) == 0) { // 将帧数据写入输出文件 fwrite(frame-\u0026gt;data[0], 1, codecCtx-\u0026gt;width * codecCtx-\u0026gt;height, dest_fp); fwrite(frame-\u0026gt;data[1], 1, codecCtx-\u0026gt;width * codecCtx-\u0026gt;height / 4, dest_fp); fwrite(frame-\u0026gt;data[2], 1, codecCtx-\u0026gt;width * codecCtx-\u0026gt;height / 4, dest_fp); // 增加帧计数 frameCount++; // 记录当前帧数 av_log(NULL, AV_LOG_INFO, \u0026#34;frameCount:%d\\n\u0026#34;, frameCount); } // 如果帧数据不为空，释放帧内存 if (frame) { av_frame_free(\u0026amp;frame); } return 0; } int main(int argc, char **argv) { // 设置日志级别为调试模式 av_log_set_level(AV_LOG_DEBUG); // 检查命令行参数是否正确 if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); return -1; } // 获取输入和输出文件名 const char *inFileName = argv[1]; const char *outFileName = argv[2]; // 定义一个AVFormatContext结构体，用于存储输入文件的格式信息 AVFormatContext *inFmtCtx = NULL; // 打开输入文件 int ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret != 0) { // 如果打开失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open input file %s\\n\u0026#34;, inFileName); return -1; } // 获取输入文件的流信息 ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { // 如果获取失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find stream information:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // 查找最佳的视频流索引 ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { // 如果查找失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find best stream index:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // 获取视频流的索引 int videoIndex = ret; // 分配一个AVCodecContext结构体，用于存储解码器上下文信息 AVCodecContext *codecCtx = avcodec_alloc_context3(NULL); if (codecCtx == NULL) { // 如果分配失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate codec context\\n\u0026#34;); ret = -1; goto fail; } // 将流参数复制到解码器上下文 avcodec_parameters_to_context(codecCtx, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); // 查找解码器 const AVCodec *decoder = avcodec_find_decoder(codecCtx-\u0026gt;codec_id); if (decoder == NULL) { // 如果查找失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find codec\\n\u0026#34;); ret = -1; goto fail; } // 打开解码器 ret = avcodec_open2(codecCtx, decoder, NULL); if (ret != 0) { // 如果打开失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open codec:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // 打开输出文件 FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { // 如果打开失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open output file %s\\n\u0026#34;, outFileName); ret = -1; goto fail; } // 分配一个AVPacket结构体，用于存储数据包 AVPacket *packet = av_packet_alloc(); // 分配一个AVFrame结构体，用于存储解码后的帧数据 AVFrame *frame = av_frame_alloc(); // 循环读取输入文件中的数据包 while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) { // 如果数据包属于视频流ff if (packet-\u0026gt;stream_index == videoIndex) { // 解码视频帧 if (decodeVideo(codecCtx, packet, dest_fp) == -1) { ret = -1; av_packet_unref(packet); goto fail; } // 释放数据包引用 av_packet_unref(packet); } } // 刷新解码器，确保所有帧都被解码 decodeVideo(codecCtx, NULL, dest_fp); fail: // 如果输入文件格式上下文不为空，关闭输入文件 if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } // 如果解码器上下文不为空，释放解码器上下文 if (codecCtx) { avcodec_free_context(\u0026amp;codecCtx); } // 如果输出文件指针不为空，关闭输出文件 if (dest_fp) { fclose(dest_fp); } return ret; } 更改视频格式 流程 函数名 描述 av_parse_video_size 解析视频尺寸字符串（如 \u0026ldquo;1920x1080\u0026rdquo;）并返回宽度和高度。 sws_getContext 创建一个 SwsContext，用于图像缩放和格式转换。 av_frame_alloc 分配一个 AVFrame 结构体，用于存储解码后的视频帧。 av_image_get_buffer_size 计算给定图像格式和尺寸所需的缓冲区大小。 av_malloc 分配内存，用于存储图像数据。 av_image_fill_arrays 将图像数据填充到 AVFrame 的缓冲区中，并设置相关的行大小和数据指针。 sws_scale 使用 SwsContext 对图像进行缩放或格式转换。 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026#34;libavutil/parseutils.h\u0026#34; #include \u0026#34;libavutil/imgutils.h\u0026#34; // 定义一个全局变量，用于记录解码的帧数 int frameCount = 0; // 解码视频帧的函数 int decodeVideo(AVCodecContext *codecCtx, AVPacket *packet, struct SwsContext *swsCtx, int destWidth, int destHeight, AVFrame *destFrame, FILE *dest_fp) { // 将数据包发送到解码器 int ret = avcodec_send_packet(codecCtx, packet); if (ret != 0) { // 如果发送失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not send packet:%s\\n\u0026#34;, av_err2str(ret)); return -1; } // 分配一个AVFrame结构体，用于存储解码后的帧数据 AVFrame *frame = av_frame_alloc(); // 循环接收解码后的帧数据 while (avcodec_receive_frame(codecCtx, frame) == 0) { sws_scale(swsCtx, (const uint8_t *const*)frame-\u0026gt;data, frame-\u0026gt;linesize, 0, codecCtx-\u0026gt;height, destFrame-\u0026gt;data, destFrame-\u0026gt;linesize); // 将帧数据写入输出文件 fwrite(destFrame-\u0026gt;data[0], 1, destWidth * destHeight, dest_fp); fwrite(destFrame-\u0026gt;data[1], 1, destWidth * destHeight / 4, dest_fp); fwrite(destFrame-\u0026gt;data[2], 1, destWidth * destHeight / 4, dest_fp); // 增加帧计数 frameCount++; // 记录当前帧数 av_log(NULL, AV_LOG_INFO, \u0026#34;frameCount:%d\\n\u0026#34;, frameCount); // 输出宽高信息,linesize0 1 2 av_log(NULL, AV_LOG_INFO, \u0026#34;width:%d,height:%d,linesize0:%d,linesize1:%d,linesize2:%d\\n\u0026#34;, destWidth, destHeight, destFrame-\u0026gt;linesize[0], destFrame-\u0026gt;linesize[1], destFrame-\u0026gt;linesize[2]); } // 如果帧数据不为空，释放帧内存 if (frame) { av_frame_free(\u0026amp;frame); } return 0; } int main(int argc, char **argv) { // 设置日志级别为调试模式 av_log_set_level(AV_LOG_DEBUG); // 检查命令行参数是否正确 if (argc \u0026lt; 4) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt; \u0026lt;width*height\u0026gt;\\n\u0026#34;, argv[0]); return -1; } // 获取输入和输出文件名 const char *inFileName = argv[1]; const char *outFileName = argv[2]; const char *destVideoSizeString = argv[3]; int destWidth = 0, destHeight = 0; int ret = av_parse_video_size(\u0026amp;destWidth, \u0026amp;destHeight, destVideoSizeString); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;invalid video size:%s\\n\u0026#34;, destVideoSizeString); return -1; } av_log(NULL, AV_LOG_INFO, \u0026#34;destWith:%d,destHeight:%d\\n\u0026#34;, destWidth, destHeight); // 定义一个AVFormatContext结构体，用于存储输入文件的格式信息 AVFormatContext *inFmtCtx = NULL; // 打开输入文件 ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret != 0) { // 如果打开失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open input file %s\\n\u0026#34;, inFileName); return -1; } // 获取输入文件的流信息 ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { // 如果获取失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find stream information:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // 查找最佳的视频流索引 ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { // 如果查找失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find best stream index:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } // 获取视频流的索引 int videoIndex = ret; // 分配一个AVCodecContext结构体，用于存储解码器上下文信息 AVCodecContext *codecCtx = avcodec_alloc_context3(NULL); if (codecCtx == NULL) { // 如果分配失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate codec context\\n\u0026#34;); ret = -1; goto fail; } // 将流参数复制到解码器上下文 avcodec_parameters_to_context(codecCtx, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); // 查找解码器 const AVCodec *decoder = avcodec_find_decoder(codecCtx-\u0026gt;codec_id); if (decoder == NULL) { // 如果查找失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not find codec\\n\u0026#34;); ret = -1; goto fail; } // 打开解码器 ret = avcodec_open2(codecCtx, decoder, NULL); if (ret != 0) { // 如果打开失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open codec:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } enum AVPixelFormat destPixfmt = codecCtx-\u0026gt;pix_fmt; struct SwsContext *swsCtx = sws_getContext(codecCtx-\u0026gt;width, codecCtx-\u0026gt;height, codecCtx-\u0026gt;pix_fmt, destWidth, destHeight, destPixfmt, SWS_BICUBIC, NULL, NULL, NULL); if (swsCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not create SwsContext\\n\u0026#34;); ret = -1; goto fail; } AVFrame *destFrame = av_frame_alloc(); uint8_t *outBuffer = av_malloc(av_image_get_buffer_size(destPixfmt, destWidth, destHeight, 1)); av_image_fill_arrays(destFrame-\u0026gt;data, destFrame-\u0026gt;linesize, outBuffer, destPixfmt, destWidth, destHeight, 1); // 打开输出文件 FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { // 如果打开失败，记录错误信息 av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not open output file %s\\n\u0026#34;, outFileName); ret = -1; goto fail; } // 分配一个AVPacket结构体，用于存储数据包 AVPacket *packet = av_packet_alloc(); // 分配一个AVFrame结构体，用于存储解码后的帧数据 AVFrame *frame = av_frame_alloc(); // 循环读取输入文件中的数据包 while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) { // 如果数据包属于视频流 if (packet-\u0026gt;stream_index == videoIndex) { // 解码视频帧 // if (decodeVideo(codecCtx, packet, dest_fp) == -1) if (decodeVideo(codecCtx, packet, swsCtx, destWidth, destHeight, destFrame, dest_fp) == -1) { ret = -1; av_packet_unref(packet); goto fail; } // 释放数据包引用 av_packet_unref(packet); } } // 刷新解码器，确保所有帧都被解码 // decodeVideo(codecCtx, NULL, dest_fp); decodeVideo(codecCtx, NULL, swsCtx, destWidth, destHeight, destFrame, dest_fp); fail: // 如果输入文件格式上下文不为空，关闭输入文件 if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } // 如果解码器上下文不为空，释放解码器上下文 if (codecCtx) { avcodec_free_context(\u0026amp;codecCtx); } // 如果输出文件指针不为空，关闭输出文件 if (dest_fp) { fclose(dest_fp); } if (destFrame) { av_frame_free(\u0026amp;destFrame); } if (outBuffer) { av_free(outBuffer); } return ret; } 解码后的数据存储 解码后的视频数据通常存储在 data[0]、data[1]、data[2] 等数组中。具体来说：\ndata[0]: 存储了 linesize[0] * height 个数据。 data[1] 和 data[2]: 存储了其他平面的数据（如YUV格式中的U和V平面）。 内存对齐和 linesize linesize[0]: 实际上并不等于图像的宽度 width，而是比宽度大。 这种差异是由于内存对齐的需求，以及解码器的CPU和其他优化原因导致的。 sws_scale 函数功能 sws_scale 函数是 FFmpeg 中用于图像缩放和格式转换的核心函数。它主要完成以下功能：\n图像色彩空间转换：\n将图像从一种色彩空间转换为另一种色彩空间，例如从 RGB 转换为 YUV，或者从 YUV420P 转换为 YUV444P。 分辨率缩放：\n调整图像的分辨率，例如将 1920x1080 的图像缩放到 1280x720。 前后图像滤波处理：\n在进行缩放和色彩空间转换时，应用滤波器以平滑图像，减少锯齿和伪影。 BMP文件格式 概念：BMP文件格式，又称为Bitmap（位图）或是DIB（Device-Independent Device，设备无光位图），是Windows操作系统中的标准图像文件格式。由于它可以不作任何变换地保存图像像素域的数据，因此成为我们取得RAW数据的好来源。\n扫描方式：从左到右，从下到上\n文件组成：\n位图文件头（Bitmap File Header）：提供文件的格式，大小等信息 位图信息头（Bitmap Information）：提供图像的尺寸，位平面数，压缩方式，颜色索引等信息。 调色板（Color Palette）：可选，有些位图需要调色板，有些位图，比如真彩色图（24位的BMP）就不需要调色板。 位图数据（Bitmap Data）：图像数据区 文件头结构体：\n1 2 3 4 5 6 7 typedef struct tagBITMAPFILEHEADER { WORD bfType; // 文件类型，必须是0x424D，即字符“BM” DWORD bfSize; // bmp文件大小 WORD bfReserved1; // 保留字 WORD bfReserved2; // 保留字 DWORD bfOffBits; // 实际位图数据的偏移字节数，即前三个部分长度之和 } BITMAPFILEHEADER; 信息头结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct tagBITMAPINFOHEADER { DWORD biSize; //表示struct tagBITMAPINFOHEADER的长度，设为40 LONG biWidth; //bmp图片宽度 LONG biHeight; //bmp图片高度 WORD biPlanes; //bmp图片平面树，设为1 WORD biBitCount; //bmp图片位数，即1位图，4位图，8位图，24位图等 DWORD biCompression; //bmp图片压缩类型，0表示不压缩 DWORD biSizeImage; //bmp图片数据大小，必须是4的整数倍 LONG biXPelsPerMeter; //bmp图片水平分辨率 LONG biYPelsPerMeter; //bmp图片垂直分辨率 DWORD biClrUsed; //bmp图片实际使用的颜色表中的颜色数 DWORD biClrImportant; //bmp图片对显示有重要影响的颜色索引的数目 } BITMAPINFOHEADER; 视频编码（yuv到h264） 流程 函数名 描述 avcodec_find_encoder 查找编码器 avcodec_alloc_context3 创建编码器上下文 avcodec_open2 打开编码器 av_frame_alloc 分配帧内存 av_image_get_buffer_size 获取图像缓冲区大小 av_image_fill_arrays 填充图像数据数组 avcodec_send_frame 发送帧到编码器 avcodec_receive_packet 从编码器接收数据包 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavutil/parseutils.h\u0026#34; #include \u0026lt;libavcodec/codec.h\u0026gt; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/imgutils.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;libavutil/rational.h\u0026gt; #include \u0026lt;time.h\u0026gt; int writePacketCount = 0; int encodeVideo(AVCodecContext *encoderCtx, AVFrame *frame, AVPacket *packet, FILE *dest_fp) { int ret = avcodec_send_frame(encoderCtx, frame); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;send frame error:%s\\n\u0026#34;, av_err2str(ret)); return -1; } while (ret \u0026gt;= 0) { avcodec_receive_packet(encoderCtx, packet); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { return 0; } else if (ret \u0026lt; 0) { av_log(NULL,AV_LOG_ERROR,\u0026#34;encoder frrame failed:%s\\n\u0026#34;,av_err2str(ret)); return -1; } fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); writePacketCount++; av_log(NULL,AV_LOG_INFO,\u0026#34;writePacketCount : %d\\n\u0026#34;,writePacketCount); av_packet_unref(packet); } } int main(int argc, char **argv) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 5) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;inFile\u0026gt; \u0026lt;outFile\u0026gt; \u0026lt;encodeName\u0026gt; \u0026lt;width x height\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFileName = argv[1]; const char *outFileName = argv[2]; const char *encoderName = argv[3]; int width = 0, height = 0; int ret = av_parse_video_size(\u0026amp;width, \u0026amp;height, argv[4]); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Invalid size \u0026#39;%s\u0026#39;, must be in the form WxH or a valid size abbreviation\\n\u0026#34;, argv[4]); return -1; } enum AVPixelFormat pixFmt = AV_PIX_FMT_YUV420P; int fps = 30; const AVCodec *encoder = avcodec_find_encoder_by_name(encoderName); if (encoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find encoder %s failed\\n\u0026#34;, encoderName); return -1; } AVCodecContext *encoderCtx = avcodec_alloc_context3(encoder); if (encoderCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc encoder context failed!\\n\u0026#34;); return -1; } encoderCtx-\u0026gt;codec_type = AVMEDIA_TYPE_VIDEO; encoderCtx-\u0026gt;pix_fmt = pixFmt; encoderCtx-\u0026gt;width = width; encoderCtx-\u0026gt;height = height; encoderCtx-\u0026gt;time_base = (AVRational){1, fps}; encoderCtx-\u0026gt;bit_rate = 4096000; encoderCtx-\u0026gt;max_b_frames = 0; encoderCtx-\u0026gt;gop_size = 10; ret = avcodec_open2(encoderCtx, encoder, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open encoder failed! %s\\n\u0026#34;, av_err2str(ret)); goto end; } FILE *src_fp = fopen(inFileName, \u0026#34;rb\u0026#34;); if (src_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open infilename error\u0026#34;); ret = -1; goto end; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open outfilename error\u0026#34;); ret = -1; goto end; } AVFrame *frame = av_frame_alloc(); int frameSize = av_image_get_buffer_size(pixFmt, width, height, 1); uint8_t *frameBuffer = av_malloc(frameSize); av_image_fill_arrays(frame-\u0026gt;data, frame-\u0026gt;linesize, frameBuffer, pixFmt, width, height, 1); int pictureSize = width * height; AVPacket *packet = av_packet_alloc(); int readFrameCount = 0; while (fread(frameBuffer, 1, pictureSize * 3 / 2, src_fp) == pictureSize * 3 / 2) { // Y 1 U 1/4 V 1/4 frame-\u0026gt;data[0] = frameBuffer; frame-\u0026gt;data[1] = frameBuffer + pictureSize; frame-\u0026gt;data[2] = frameBuffer + pictureSize + pictureSize / 4; readFrameCount++; av_log(NULL, AV_LOG_INFO, \u0026#34;readFrameCount: %d\\n\u0026#34;, readFrameCount); encodeVideo(encoderCtx, frame, packet, dest_fp); } end: if (encoderCtx) { avcodec_free_context(\u0026amp;encoderCtx); } if (src_fp) { fclose(src_fp); } if (dest_fp) { fclose(dest_fp); } if (frameBuffer) { av_freep(\u0026amp;frameBuffer); } return ret; } 音频解码 PCM介绍 PCM（Pulse Code Modulation）是一种用于数字音频的标准编码格式。它通过将模拟音频信号转换为数字信号来表示音频数据。PCM 编码的基本原理是将模拟音频信号在时间上进行采样，并将每个采样点的幅度值量化为离散的数字值。\n核心过程：采样-\u0026gt;量化-\u0026gt;编码\nPCM关键要素 采样率（Sample Rate）：每秒采样的次数，常见的采样率有 44.1 kHz、48 kHz 等。 量化格式（Sample Format）：每个采样点的位数，常见的量化格式有 16 位、24 位等。 声道数（Channels）：音频信号的声道数，如单声道、立体声等。 PCM数据格式 存储格式\n双声道：采样数据按LRLR方式存储，即左声道和右声道交替存储，存储的时候与字节序有关。 单声道：采样数据按时间顺序存储（有时也会采用LRLR方式，但另一个声道数据为0）。 存储格式分为Packed和Planner两种，对于双通道音频，Packed为两个声道的数据交错存储;Planner为两个声道的数据分开存储。\nPacked：LRLRLR Planner：LLLRRR ffmpeg音频解码后的数据存放在AVFrame结构体中：\nPacked格式下，frame.data[0]存放所有声道的数据。 Planner格式下，frame.data[i]存放第i个声道的数据。 左声道data[0]:LLLL\u0026hellip; 右声道data[1]:RRRR\u0026hellip; Planner模式是ffmpeg内部存储模式，实际使用的音频文件都是Packed模式。\nPCM计算 大小计算：以CD的音质为例：量化格式为16比特（2字节），采样率为44100，声道数为2。 比特率为：16 * 44100 * 2 = 1378.125 kbps 每秒存储空间：1378.125 * 60/8/1024 = 10.09MB ffmpeg提取pcm数据命令： 1 ffmpeg -i input.aac -ar 48000 -ac 2 -f s16le output.pcm ffplay播放pcm数据命令： 1 ffplay -ar 48000 -ac 2 -f s16le output.pcm 通过上述指令播放不成功的话，可以尝试转换PCM文件\n1 2 ffmpeg -f s16le -ar 48000 -ac 2 -i output.pcm output_stereo.wav ffplay output_stereo.wav 流程 函数名 描述 avformat_open_input() 打开输入文件或流并读取头部信息。 avformat_find_stream_info() 读取一些数据包以获取流信息。 av_find_best_stream() 查找最佳流（音频、视频或字幕）。 avcodec_alloc_context3() 分配解码器上下文。 avcodec_parameters_to_context() 将流参数复制到解码器上下文中。 avcodec_find_decoder() 查找合适的解码器。 avcodec_open2() 打开解码器。 av_frame_alloc() 分配AVFrame结构体。 av_samples_get_buffer_size() 计算音频缓冲区的大小。 avcodec_fill_audio_frame() 填充音频帧的缓冲区。 av_read_frame() 从输入文件或流中读取数据包。 avcodec_send_packet() 将数据包发送到解码器进行解码。 avcodec_receive_frame() 从解码器接收解码后的帧。 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026lt;libavcodec/codec.h\u0026gt; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;time.h\u0026gt; int decodeAudio(AVCodecContext *decoderCtx, AVPacket *packet, AVFrame *frame, FILE *dest_fp) { int ret = avcodec_send_packet(decoderCtx, packet); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;send packet to decoder failed: %s\\n\u0026#34;, av_err2str(ret)); return -1; } int channel = 0; while (ret \u0026gt;= 0) { ret = avcodec_receive_frame(decoderCtx, frame); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { return 0; } else if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;decode packet failed: %s\\n\u0026#34;, av_err2str(ret)); return -1; } int dataSize = av_get_bytes_per_sample(decoderCtx-\u0026gt;sample_fmt); if (dataSize \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;get bytes per sample failed\\n\u0026#34;); return -1; } // frame fltp 2 /* data[0] L L L L data[1] R R R R --\u0026gt; L R L R L R L R */ for (int i = 0; i \u0026lt; frame-\u0026gt;nb_samples; i++) { for (channel = 0; channel \u0026lt; decoderCtx-\u0026gt;ch_layout.nb_channels; channel++) { fwrite(frame-\u0026gt;data[channel] + dataSize * i, 1, dataSize, dest_fp); } } } return 0; } int main(int argc, char **argv) { av_log_set_level(AV_LOG_DEBUG); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input\u0026gt; \u0026lt;output\u0026gt;\\n\u0026#34;, argv[0]); } const char *inFileName = argv[1]; const char *outFileName = argv[2]; AVFormatContext *inFmtCtx = NULL; int ret = avformat_open_input(\u0026amp;inFmtCtx, inFileName, NULL, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open %s failed\\n\u0026#34;, inFileName); return -1; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream error:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream error:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } int audioStreamIndex = ret; AVCodecContext *decoderCtx = avcodec_alloc_context3(NULL); if (decoderCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc codec context failed\\n\u0026#34;); goto fail; } ret = avcodec_parameters_to_context(decoderCtx, inFmtCtx-\u0026gt;streams[audioStreamIndex]-\u0026gt;codecpar); const AVCodec *decoder = avcodec_find_decoder(decoderCtx-\u0026gt;codec_id); if (decoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find decoder %d failed\\n\u0026#34;, decoderCtx-\u0026gt;codec_id); ret = -1; goto fail; } ret = avcodec_open2(decoderCtx, decoder, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open decoder error:%s\\n\u0026#34;, av_err2str(ret)); goto fail; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open %s failed\\n\u0026#34;, outFileName); ret = -1; goto fail; } AVFrame *frame = av_frame_alloc(); int frameSize = av_samples_get_buffer_size(NULL, decoderCtx-\u0026gt;ch_layout.nb_channels, frame-\u0026gt;nb_samples, decoderCtx-\u0026gt;sample_fmt, 1); uint8_t *frameBuffer = av_malloc(frameSize); avcodec_fill_audio_frame(frame, decoderCtx-\u0026gt;ch_layout.nb_channels, decoderCtx-\u0026gt;sample_fmt, frameBuffer, frameSize, 1); AVPacket *packet = av_packet_alloc(); while (av_read_frame(inFmtCtx, packet) \u0026gt;= 0) { if (packet-\u0026gt;stream_index == audioStreamIndex) { decodeAudio(decoderCtx, packet, frame, dest_fp); } av_packet_unref(packet); } decodeAudio(decoderCtx, NULL, frame, dest_fp); fail: if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); } if (decoderCtx) { avcodec_free_context(\u0026amp;decoderCtx); } if (frame) { av_frame_free(\u0026amp;frame); } if (frameBuffer) { av_freep(frameBuffer); } if (dest_fp) { fclose(dest_fp); } return ret; } 运行指令\n1 2 3 4 5 ./demoBin ../video/test.aac ../video/test_decode_by_code.pcm ffmpeg -f f32le -ar 44100 -ac 2 -i ../video/test_decode_by_code.pcm ../video/test_decode_by_code_stereo.wav ffplay ../video/test_decode_by_code_stereo.wav 音频编码 流程 函数名 描述 av_frame_alloc 分配一个AVFrame结构体 av_frame_get_buffer 为AVFrame分配缓冲区 avcodec_find_encoder_by_name 根据名称查找编码器 avcodec_alloc_context3 分配编码器上下文 avcodec_open2 打开编码器 avcodec_send_frame 发送帧到编码器 avcodec_receive_packet 从编码器接收编码后的数据包 运行指令\n1 2 3 ffmpeg -ac 2 -ar 44100 -f s16le -i test.pcm -acodec libfdk_aac test1.aac ffplay test1.aac 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026lt;libavcodec/codec.h\u0026gt; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/channel_layout.h\u0026gt; #include \u0026lt;libavutil/error.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/samplefmt.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; int encodeAudio(AVCodecContext *encoderCtx, AVFrame *frame, AVPacket *packet, FILE *dest_fp) { int ret = avcodec_send_frame(encoderCtx, frame); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;send frame to encoder failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } while (ret \u0026gt;= 0) { ret = avcodec_receive_packet(encoderCtx, packet); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) { return 0; } else if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;receive packet from encoder failed:%s\\n\u0026#34;, av_err2str(ret)); return -1; } fwrite(packet-\u0026gt;data, 1, packet-\u0026gt;size, dest_fp); av_packet_unref(packet); } return 0; } int main(int argc, char **argv) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 3) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage: %s \u0026lt;input file\u0026gt; \u0026lt;output file\u0026gt;\\n\u0026#34;, argv[0]); return -1; } const char *inFileName = argv[1]; const char *outFileName = argv[2]; AVFrame *frame = av_frame_alloc(); if (!frame) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Could not allocate video frame\\n\u0026#34;); return -1; } frame-\u0026gt;sample_rate = 44100; // 这里代码有些不同 frame-\u0026gt;ch_layout.nb_channels = 2; av_channel_layout_from_mask(\u0026amp;frame-\u0026gt;ch_layout, AV_CH_LAYOUT_STEREO); frame-\u0026gt;format = AV_SAMPLE_FMT_S16; frame-\u0026gt;nb_samples = 1024; av_frame_get_buffer(frame, 0); int ret = 0; const AVCodec *encoder = avcodec_find_encoder_by_name(\u0026#34;libfdk_aac\u0026#34;); if (!encoder) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find encoder failed\\n\u0026#34;); ret = -1; goto end; } AVCodecContext *encoderCtx = avcodec_alloc_context3(encoder); if (!encoderCtx) { av_log(NULL, AV_LOG_ERROR, \u0026#34;alloc encoder context failed\\n\u0026#34;); ret = -1; goto end; } encoderCtx-\u0026gt;sample_fmt = frame-\u0026gt;format; encoderCtx-\u0026gt;sample_rate = frame-\u0026gt;sample_rate; encoderCtx-\u0026gt;ch_layout.nb_channels = frame-\u0026gt;ch_layout.nb_channels; encoderCtx-\u0026gt;ch_layout = frame-\u0026gt;ch_layout; ret = avcodec_open2(encoderCtx, encoder, NULL); if (ret \u0026lt; 0) { av_log(NULL,AV_LOG_ERROR,\u0026#34;open encoder failed:%s\\n\u0026#34;,av_err2str(ret)); ret = -1; goto end; } FILE *src_fp = fopen(inFileName, \u0026#34;rb\u0026#34;); if (src_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input file failed\\n\u0026#34;); ret = -1; goto end; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (src_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open output file failed\\n\u0026#34;); ret = -1; goto end; } AVPacket *packet = av_packet_alloc(); while (1) { int readSize = fread(frame-\u0026gt;data[0], 1, frame-\u0026gt;linesize[0], src_fp); if (readSize == 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;finish read infile\\n\u0026#34;); break; } encodeAudio(encoderCtx, frame, packet, dest_fp); } encodeAudio(encoderCtx, NULL, packet, dest_fp); end: if (frame) { av_frame_free(\u0026amp;frame); } if (encoderCtx) { avcodec_free_context(\u0026amp;encoderCtx); } if (src_fp) { fclose(src_fp); } if (dest_fp) { fclose(dest_fp); } return ret; } 指令\n1 2 3 ./demoBin test.pcm aac_by_code.aac ffplay aac_by_code.aac 视频采集 视频采集命令 查看设备列表： 1 ffmpeg -hide_banner -devices 查看dshow支持的参数： 1 ffmpeg -h demuxer=dshow 查看dshow支持的设备： 1 ffmpeg -f dshow -list_devices true -i dummy 一般是Integrated Camera，这是本地摄像头\n采集摄像头画面： 1 ffmpeg -f dshow -i video=\u0026#34;Integrated Camera\u0026#34; ./video/output.mp4 播放摄像头采集画面：\n1 ffplay output.mp4 流程 函数名 描述 avdevice_register_all 注册所有可用的设备 avformat_alloc_context 分配格式上下文 av_dict_set 设置字典选项 av_find_input_format 查找输入格式 avformat_open_input 打开输入文件 avformat_find_stream_info 查找流信息 av_find_best_stream 查找最佳流 avcodec_alloc_context3 分配编解码器上下文 avcode_parameters_to_context 将参数复制到上下文 avcodec_find_decoder 查找解码器 avcodec_open2 打开编解码器 av_read_frame 读取帧 avcode_send_packet 发送数据包 avcodec_receive_frame 接收帧 颜色空间格式转换：\n函数名 描述 sws_getContext 获取缩放上下文 av_frame_alloc 分配帧 av_image_get_buffer_size 获取图像缓冲区大小 av_malloc 分配内存 av_image_fill_arrays 填充图像数组 sws_scale 缩放图像 先用ffmpeg指令试一下视频采集格式，后续代码写的时候要用对应采集的格式。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavdevice/avdevice.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavutil/imgutils.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/dict.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; // 显示可用的摄像头设备 // ffmpeg -f dshow -list_devices true -i dummy void dshowListDevices() { const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find dshow failed!\\n\u0026#34;); } // 设置参数 AVDictionary *options = NULL; av_dict_set(\u0026amp;options, \u0026#34;list_devices\u0026#34;, \u0026#34;true\u0026#34;, 0); AVFormatContext *inFmtCtx = avformat_alloc_context(); // 第二个参数是URL int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;video=Integrated Camera\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return; } if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); avformat_free_context(inFmtCtx); } } void decodeVideo(struct SwsContext *swsCtx, AVCodecContext *decoderCtx, AVFrame *destFrame, AVPacket *packet, FILE *dest_fp) { if (avcodec_send_packet(decoderCtx, packet) == 0) { AVFrame *frame = av_frame_alloc(); while (avcodec_receive_frame(decoderCtx, frame) \u0026gt;= 0) { sws_scale(swsCtx, (const uint8_t *const *)frame-\u0026gt;data, frame-\u0026gt;linesize, 0, decoderCtx-\u0026gt;height, destFrame-\u0026gt;data, destFrame-\u0026gt;linesize); fwrite(destFrame-\u0026gt;data[0], 1, decoderCtx-\u0026gt;width * decoderCtx-\u0026gt;height, dest_fp); fwrite(destFrame-\u0026gt;data[1], 1, decoderCtx-\u0026gt;width * decoderCtx-\u0026gt;height / 4, dest_fp); fwrite(destFrame-\u0026gt;data[2], 1, decoderCtx-\u0026gt;width * decoderCtx-\u0026gt;height / 4, dest_fp); } av_frame_free(\u0026amp;frame); } } int main(int argc, char *argv[]) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage:%s \u0026lt;outFileName\u0026gt; \\n\u0026#34;, argv[0]); return -1; } const char *outFileName = argv[1]; avdevice_register_all(); dshowListDevices(); AVFormatContext *inFmtCtx = avformat_alloc_context(); const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed!\\n\u0026#34;); goto end; } AVDictionary *options = NULL; av_dict_set(\u0026amp;options, \u0026#34;framerate\u0026#34;, \u0026#34;30\u0026#34;, 0); int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;video=Integrated Camera\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } int videoIndex = ret; // 创建解码器上下文 AVCodecContext *decoderCtx = avcodec_alloc_context3(NULL); ret = avcodec_parameters_to_context(decoderCtx, inFmtCtx-\u0026gt;streams[videoIndex]-\u0026gt;codecpar); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;copy parameters to context failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } const AVCodec *decoder = avcodec_find_decoder(decoderCtx-\u0026gt;codec_id); if (decoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find decoder failed!\\n\u0026#34;); ret = -1; goto end; } ret = avcodec_open2(decoderCtx, decoder, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open decoder failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } AVFrame *destFrame = av_frame_alloc(); enum AVPixelFormat destPixFmt = AV_PIX_FMT_YUV420P; uint8_t *outBuffer = av_malloc(av_image_get_buffer_size(destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1)); av_image_fill_arrays(destFrame-\u0026gt;data, destFrame-\u0026gt;linesize, outBuffer, destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1); struct SwsContext *swsCtx = sws_getContext(decoderCtx-\u0026gt;coded_width, decoderCtx-\u0026gt;coded_height, decoderCtx-\u0026gt;pix_fmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, destPixFmt, 0, NULL, NULL, NULL); if (swsCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;create sws context failed!\\n\u0026#34;); ret = -1; goto end; } FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open out put file %s failed!\\n\u0026#34;, outFileName); ret = -1; goto end; } AVPacket *packet = av_packet_alloc(); while (1) { if (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == videoIndex) { decodeVideo(swsCtx, decoderCtx, destFrame, packet, dest_fp); } } av_packet_unref(packet); } decodeVideo(swsCtx,decoderCtx, destFrame,NULL, dest_fp); end: if (inFmtCtx) { avformat_free_context(inFmtCtx); } if (decoderCtx) { avcodec_free_context(\u0026amp;decoderCtx); } if (dest_fp) { fclose(dest_fp); } if (outBuffer) { av_freep(\u0026amp;outBuffer); } return ret; } 音频采集 音频采集命令 采集麦克风声音：\n1 ffmpeg -f dshow -i audio=\u0026#34;阵列麦克风 (AMD Audio Device)\u0026#34; -ar 44100 -f f32le output.pcm 播放麦克风采集：\n1 ffplay -ar 44100 -f f32le output.pcm 流程 函数名 描述 avdevice_register_all 注册所有可用的设备 avformat_alloc_context 分配格式上下文 av_dict_set 设置字典选项 av_find_input_format 查找输入格式 avformat_open_input 打开输入文件 avformat_find_stream_info 查找流信息 av_find_best_stream 查找最佳流 avcodec_alloc_context3 分配编解码器上下文 avcode_parameters_to_context 将参数复制到上下文 avcodec_find_decoder 查找解码器 avcodec_open2 打开编解码器 av_read_frame 读取帧 avcode_send_packet 发送数据包 avcodec_receive_frame 接收帧 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 #include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavdevice/avdevice.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/avutil.h\u0026#34; #include \u0026#34;libavutil/imgutils.h\u0026#34; #include \u0026#34;libswscale/swscale.h\u0026#34; #include \u0026lt;libavcodec/packet.h\u0026gt; #include \u0026lt;libavutil/dict.h\u0026gt; #include \u0026lt;libavutil/frame.h\u0026gt; #include \u0026lt;libavutil/log.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; // 显示可用的摄像头设备 // ffmpeg -f dshow -list_devices true -i dummy void dshowListDevices() { const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find dshow failed!\\n\u0026#34;); } // 设置参数 AVDictionary *options = NULL; av_dict_set(\u0026amp;options, \u0026#34;list_devices\u0026#34;, \u0026#34;true\u0026#34;, 0); AVFormatContext *inFmtCtx = avformat_alloc_context(); // 第二个参数是URL int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;video=Integrated Camera\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed:%s\\n\u0026#34;, av_err2str(ret)); return; } if (inFmtCtx) { avformat_close_input(\u0026amp;inFmtCtx); avformat_free_context(inFmtCtx); } } void decodeAudio(AVCodecContext *decoderCtx, AVPacket *packet, FILE *dest_fp) { if (avcodec_send_packet(decoderCtx, packet) == 0) { AVFrame *frame = av_frame_alloc(); while (avcodec_receive_frame(decoderCtx, frame) \u0026gt;= 0) { fwrite(frame-\u0026gt;data[0], 1, frame-\u0026gt;linesize[0], dest_fp); } av_frame_free(\u0026amp;frame); } } int main(int argc, char *argv[]) { av_log_set_level(AV_LOG_INFO); if (argc \u0026lt; 2) { av_log(NULL, AV_LOG_ERROR, \u0026#34;Usage:%s \u0026lt;outFileName\u0026gt; \\n\u0026#34;, argv[0]); return -1; } const char *outFileName = argv[1]; avdevice_register_all(); dshowListDevices(); AVFormatContext *inFmtCtx = avformat_alloc_context(); const AVInputFormat *inFmt = av_find_input_format(\u0026#34;dshow\u0026#34;); if (inFmt == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input format failed!\\n\u0026#34;); goto end; } AVDictionary *options = NULL; // av_dict_set(\u0026amp;options, \u0026#34;framerate\u0026#34;, \u0026#34;30\u0026#34;, 0); int ret = avformat_open_input(\u0026amp;inFmtCtx, \u0026#34;audio=阵列麦克风 (AMD Audio Device)\u0026#34;, inFmt, \u0026amp;options); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open input failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = avformat_find_stream_info(inFmtCtx, NULL); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find stream info failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } ret = av_find_best_stream(inFmtCtx, AVMEDIA_TYPE_AUDIO, -1, -1, NULL, 0); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find best stream failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } int audioIndex = ret; // 创建解码器上下文 AVCodecContext *decoderCtx = avcodec_alloc_context3(NULL); ret = avcodec_parameters_to_context(decoderCtx, inFmtCtx-\u0026gt;streams[audioIndex]-\u0026gt;codecpar); if (ret \u0026lt; 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;copy parameters to context failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } const AVCodec *decoder = avcodec_find_decoder(decoderCtx-\u0026gt;codec_id); if (decoder == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;find decoder failed!\\n\u0026#34;); ret = -1; goto end; } ret = avcodec_open2(decoderCtx, decoder, NULL); if (ret != 0) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open decoder failed:%s\\n\u0026#34;, av_err2str(ret)); goto end; } #if 0 AVFrame *destFrame = av_frame_alloc(); enum AVPixelFormat destPixFmt = AV_PIX_FMT_YUV420P; uint8_t *outBuffer = av_malloc(av_image_get_buffer_size(destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1)); av_image_fill_arrays(destFrame-\u0026gt;data, destFrame-\u0026gt;linesize, outBuffer, destPixFmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, 1); struct SwsContext *swsCtx = sws_getContext(decoderCtx-\u0026gt;coded_width, decoderCtx-\u0026gt;coded_height, decoderCtx-\u0026gt;pix_fmt, decoderCtx-\u0026gt;width, decoderCtx-\u0026gt;height, destPixFmt, 0, NULL, NULL, NULL); if (swsCtx == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;create sws context failed!\\n\u0026#34;); ret = -1; goto end; } #endif FILE *dest_fp = fopen(outFileName, \u0026#34;wb+\u0026#34;); if (dest_fp == NULL) { av_log(NULL, AV_LOG_ERROR, \u0026#34;open out put file %s failed!\\n\u0026#34;, outFileName); ret = -1; goto end; } AVPacket *packet = av_packet_alloc(); while (1) { if (av_read_frame(inFmtCtx, packet) == 0) { if (packet-\u0026gt;stream_index == audioIndex) { // decodeVideo(swsCtx, decoderCtx, destFrame, packet, dest_fp); decodeAudio(decoderCtx, packet, dest_fp); } } av_packet_unref(packet); } // decodeVideo(swsCtx, decoderCtx, destFrame, NULL, dest_fp); decodeAudio(decoderCtx, NULL, dest_fp); end: if (inFmtCtx) { avformat_free_context(inFmtCtx); } if (decoderCtx) { avcodec_free_context(\u0026amp;decoderCtx); } if (dest_fp) { fclose(dest_fp); } return ret; } 采集完后要用指令\n1 ffplay -f s16le -ar 44100 code.pcm 才可以播放，可能是参数的不同\n","date":"2024-12-29T00:00:00Z","image":"https://serennan.github.io/post/video_base/player1.jpg","permalink":"https://serennan.github.io/post/video_base/","title":"音视频基础"}]